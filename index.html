<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QMX Transceiver Interface</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        :root {
            --transceiver-bg: #2c3e50;
            --panel-bg: rgba(0, 0, 0, 0.2);
            --display-bg: #1a252f;
            --display-text: #00ff88;
            --accent-color: #00ff88;
            --knob-color: #bdc3c7;
            --knob-highlight: #ecf0f1;
            --button-bg: #34495e;
            --button-hover: #4a627a;
            --button-active: #00ff88;
            --font-color: #ecf0f1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1f2937;
            color: var(--font-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            user-select: none;
        }

        .transceiver-container {
            width: 1400px;
            height: 750px;
            background: linear-gradient(145deg, #3a4b60, #233140);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.5), inset 0 2px 2px rgba(255,255,255,0.1);
            border: 2px solid #1d2a38;
            padding: 20px;
            display: flex;
            gap: 20px;
            overflow: hidden;
        }

        /* Sections */
        .left-panel, .center-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
        }
        .left-panel { flex: 1; }
        .center-panel { flex: 1.5; }
        .right-panel { flex: 1.2; }

        /* Custom Scrollbar */
        .left-panel::-webkit-scrollbar, .center-panel::-webkit-scrollbar, .right-panel::-webkit-scrollbar { width: 8px; }
        .left-panel::-webkit-scrollbar-track, .center-panel::-webkit-scrollbar-track, .right-panel::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        .left-panel::-webkit-scrollbar-thumb, .center-panel::-webkit-scrollbar-thumb, .right-panel::-webkit-scrollbar-thumb { background: var(--button-bg); border-radius: 4px; }
        .left-panel::-webkit-scrollbar-thumb:hover, .center-panel::-webkit-scrollbar-thumb:hover, .right-panel::-webkit-scrollbar-thumb:hover { background: var(--button-hover); }

        .panel {
            background: var(--panel-bg);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel h3 {
            margin-top: 0; margin-bottom: 15px; font-size: 1em; color: var(--accent-color);
            text-shadow: 0 0 5px rgba(0,255,136,0.5); cursor: grab; padding-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .panel h3:active { cursor: grabbing; }

        .sortable-ghost { opacity: 0.4; background: var(--accent-color); }
        .sortable-drag { opacity: 0.9; transform: rotate(1deg); }
        .panels-locked .panel h3 { cursor: not-allowed !important; opacity: 0.8; position: relative; }
        .panels-locked .panel h3::after { content: " ðŸ”’"; font-size: 0.8em; opacity: 0.6; margin-left: 5px; }

        .frequency-display.lcd-panel {
            background: var(--display-bg); border-radius: 10px; padding: 15px 20px; text-align: left;
            border: 2px solid var(--accent-color); box-shadow: 0 0 20px rgba(0, 255, 136, 0.3), inset 0 0 10px rgba(0,0,0,0.5);
            min-height: 100px; display: flex; flex-direction: column; justify-content: center; cursor: pointer; transition: all 0.3s ease;
        }
        .lcd-row { font-family: 'Courier New', monospace; color: var(--display-text); text-shadow: 0 0 8px var(--accent-color); }
        #lcdRow1 { font-size: 2.2em; font-weight: bold; }
        #lcdRow2 { font-size: 1.3em; opacity: 0.8; }

        .tuning-knob-container { width: 220px; height: 220px; position: relative; margin: 10px auto; cursor: grab; }
        .tuning-knob {
            width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, var(--knob-highlight), #a0a0a0);
            box-shadow: 0 12px 24px rgba(0,0,0,0.4), inset 0 4px 6px rgba(255,255,255,0.8), inset 0 -4px 6px rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center;
        }
        .tuning-knob::before { content: ""; position: absolute; width: 90%; height: 90%; border-radius: 50%; background: linear-gradient(135deg, #e5e5e5, var(--knob-color)); }
        .tuning-knob::after { content: ""; position: absolute; width: 8px; height: 90px; background-color: #333; border-radius: 8px; top: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .tuning-knob-center { width: 60px; height: 60px; border-radius: 50%; background: linear-gradient(135deg, #888, #666); box-shadow: inset 0 2px 6px rgba(0,0,0,0.5); z-index: 2; }
        .tuning-knob:hover::after { background-color: var(--accent-color); }
        
        /* Styles for frequency markings, required by the script */
        .frequency-markings { position: absolute; width: 280px; height: 280px; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 0; }
        .frequency-mark { position: absolute; background: rgba(255, 255, 255, 0.6); transform-origin: center; }
        .frequency-mark.major { width: 3px; height: 20px; background: rgba(0, 255, 136, 0.8); }
        .frequency-mark.minor { width: 1px; height: 10px; background: rgba(255, 255, 255, 0.4); }

        .btn { padding: 10px 15px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; font-size: 0.9em; font-weight: bold; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; background: var(--button-bg); color: var(--font-color); }
        .btn:hover { background: var(--button-hover); transform: translateY(-1px); }
        .btn-primary { background: var(--button-active); color: #000; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
        .btn-secondary { background: var(--button-bg); }
        .btn-danger { background: linear-gradient(45deg, #ff4757, #ff3838); color: #fff; }
/* --- START: Scan Button Flash Style --- */
.btn-flash {
    background: var(--accent-color) !important;
    color: #000 !important;
    box-shadow: 0 0 15px var(--accent-color) !important;
    transition: background-color 0.05s ease, color 0.05s ease;
}
/* --- END: Scan Button Flash Style --- */
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .mode-buttons, .band-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .band-buttons { grid-template-columns: repeat(3, 1fr); }
        .mode-btn { padding: 10px; border: 2px solid rgba(255, 255, 255, 0.3); background: rgba(255, 255, 255, 0.1); color: #fff; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-weight: bold; text-align:center;}
        .mode-btn.active { background: linear-gradient(45deg, #00ff88, #00ccff); color: #000; border-color: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.5); }
        
        select { width: 100%; padding: 8px; background: rgba(0,0,0,0.3); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; }
        select option { background: #1a1a2e; }

        .meter { height: 25px; background: #111; border-radius: 5px; padding: 5px; border: 1px solid rgba(255,255,255,0.3); position: relative; overflow: hidden; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5); }
        .meter-bar { height: 100%; background: #222; border-radius: 5px; }
        .meter-indicator { position: absolute; top: 0; left: 0; height: 100%; width: 0; border-radius: 5px; transition: width 0.3s ease; }
        #sMeter { background: linear-gradient(90deg, #00ff88 0%, #ffff00 70%, #ff4757 100%); }
        #swrMeter { background: linear-gradient(90deg, #00ff88 0%, #ffff00 50%, #ff4757 100%); }

        .knobs-row {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    margin-top: 10px;
    align-items: end; /* Add this line */
}
        .knob-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .knob-group label { font-size: 0.8em; opacity: 0.8; text-transform: uppercase; }
        .volume-knob-container { width: 70px; height: 70px; cursor: grab; }
        .volume-knob { width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, var(--knob-highlight), #a0a0a0); box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 2px 3px rgba(255,255,255,0.8), inset 0 -2px 3px rgba(0,0,0,0.3); position: relative; }
        .volume-knob::after { content: ""; position: absolute; width: 5px; height: 33px; background-color: #333; border-radius: 5px; top: 4px; left: 50%; transform: translateX(-50%); }
        .volume-knob:hover::after { background-color: var(--accent-color); }
        .knob-level { font-family: "Courier New", monospace; font-size: 0.9rem; }
        
        .memory-buttons { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 10px; }
        .memory-btn { padding: 8px 4px; border: 1px solid rgba(255,255,255,0.3); background: var(--button-bg); color: #fff; border-radius: 4px; font-size: 0.8em; min-height: 45px; text-align: center; }
        .memory-btn.memory-occupied { background: rgba(0,255,136,0.2); border-color: rgba(0,255,136,0.5); color: #00ff88; }
        .memory-btn.memory-selected { background: var(--button-active); color: #000; }
        .memory-label { font-size: 0.7em; display: block; margin-top: 2px; color: var(--accent-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .cat-log { background: #000; border-radius: 8px; padding: 10px; height: 120px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.8em; }
        .cat-log-entry.tx { color: #00ff88; }
        .cat-log-entry.rx { color: #00ccff; }
        .cat-log-entry.error { color: #ff4757; }
        
        .qso-inputs-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .qso-inputs-grid input, .qso-info-bar, .log-management input { width: 100%; padding: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; background: rgba(0,0,0,0.2); color: #fff; box-sizing: border-box; }
        .qth-group, .comments-group { grid-column: 1 / -1; }
        .qso-log-table { background: #000; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; display: flex; flex-direction: column; flex-grow: 1; min-height: 150px; }
        .log-header, .log-row { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 8px 10px; }
        .log-header { background: rgba(0,255,136,0.2); font-weight: bold; font-size: 0.8em;}
        .log-body { overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.9em; flex-grow: 1; }
        .log-row { border-bottom: 1px solid rgba(255,255,255,0.1); }

        .audio-meter-bar { height: 10px; background: #222; border-radius: 5px; position: relative; overflow: hidden; border: 1px solid rgba(255,255,255,0.3); }
        .audio-meter-indicator { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--accent-color); transition: width 0.1s ease; }
        .audio-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .audio-device-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
        
        .rit-status-display { background: #000; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; padding: 10px; margin-bottom: 15px; display: flex; justify-content: space-between; }
        .rit-status-display.active { border-color: var(--accent-color); }
        .rit-status.active { color: var(--accent-color); }
        .rit-offset-value.positive { color: #00ff88; }
        .rit-offset-value.negative { color: #ff9500; }
        
        .panel-lock-controls { text-align: center; margin-bottom: -10px; position: relative; z-index: 10;}
        #panelLockToggle { padding: 6px 12px; font-size: 0.8em; border-radius: 15px; }
        
        .status-bar { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--panel-bg); border-radius: 10px; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; background: #ff4757; }
        .status-dot.connected { background: var(--accent-color); }

        /* Add missing styles for step size dropdown */
        .step-panel { margin-bottom: 15px; }
        .step-panel select { width: 100%; }
    
	/* Frequency Input Modal Styles */
.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
}

.modal-overlay.active {
    display: flex;
    justify-content: center;
    align-items: center;
}

.freq-input-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--transceiver-bg);
    border: 2px solid var(--accent-color);
    border-radius: 15px;
    padding: 20px;
    z-index: 1001;
    min-width: 300px;
}

.freq-input-modal.active {
    display: block;
}

.freq-modal-content h3 {
    text-align: center;
    margin-bottom: 15px;
    color: var(--accent-color);
}

.freq-format-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
}

.freq-format-btn {
    padding: 8px 16px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: var(--button-bg);
    color: var(--font-color);
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.freq-format-btn.active {
    background: var(--accent-color);
    color: #000;
}

.freq-display-input {
    width: 100%;
    padding: 12px;
    font-size: 1.2em;
    text-align: center;
    background: var(--display-bg);
    color: var(--display-text);
    border: 2px solid var(--accent-color);
    border-radius: 8px;
    margin-bottom: 10px;
    font-family: 'Courier New', monospace;
}

.freq-error {
    color: #ff4757;
    font-size: 0.9em;
    text-align: center;
    margin-bottom: 10px;
    min-height: 20px;
}

.freq-keypad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 15px;
}

.freq-key {
    padding: 12px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: var(--button-bg);
    color: var(--font-color);
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.1em;
    transition: all 0.3s ease;
}

.freq-key:hover {
    background: var(--button-hover);
}

.freq-modal-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
}

.freq-modal-buttons .btn {
    flex: 1;
}
/* Add these modal styles to your CSS */
.memory-edit-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--transceiver-bg);
    border: 2px solid var(--accent-color);
    border-radius: 15px;
    padding: 20px;
    z-index: 1001;
    min-width: 300px;
}

.memory-edit-modal.active {
    display: block;
}

.modal-content h3 {
    text-align: center;
    margin-bottom: 15px;
    color: var(--accent-color);
}

.modal-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    margin-top: 15px;
}

.modal-buttons .btn {
    flex: 1;
}


/* Keyer Mode Toggle Styles */
.keyer-mode-toggle {
    margin-bottom: 8px;
    display: flex;
    justify-content: center;
}

.toggle-switch {
    position: relative;
    width: 96px;
    height: 24px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
}

.toggle-switch:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.4);
}

.toggle-slider {
   position: absolute;
    top: 2px;
    left: 2px;
    width: 36px; /* Increased length */
    height: 18px;
    background: linear-gradient(45deg, #ff4757, #ff6b7a);
    border-radius: 9px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 2;
}

.toggle-switch.bug .toggle-slider {
    left: 52px; /* Adjusted for new width */
    background: linear-gradient(45deg, #00ff88, #00ccff);
}

.toggle-label {
    position: absolute;
    font-size: 0.7em;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.6);
    transition: all 0.3s ease;
    z-index: 1;
    pointer-events: none;
}

.toggle-label.left {
    left: 8px;
}

.toggle-label.right {
    right: 8px;
}

.toggle-switch:not(.bug) .toggle-label.left {
    color: #fff;
    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
}

.toggle-switch.bug .toggle-label.right {
    color: #fff;
    text-shadow: 0 0 3px rgba(0, 255, 136, 0.8);
}

/* Make the keyer knob less prominent when in STRAIGHT mode */
.keyer-straight .volume-knob {
    opacity: 0.5;
    pointer-events: none;
}

.keyer-straight .knob-level {
    opacity: 0.6;
}
	
	
.rit-status-display.active {
    border-color: #00ff88;
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
}

.rit-indicator {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

.rit-label {
    font-size: 0.8em;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.rit-status {
    font-size: 1.1em;
    font-weight: bold;
    color: #ff4757;
    text-transform: uppercase;
}

.rit-status.active {
    color: #00ff88;
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
}

.rit-offset-display {
    text-align: right;
}

.rit-offset-value {
    font-family: 'Courier New', monospace;
    font-size: 1.2em;
    font-weight: bold;
    color: #fff;
}

.rit-offset-value.positive {
    color: #00ff88;
}

.rit-offset-value.negative {
    color: #ff9500;
}

.rit-controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.rit-adjust-buttons {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}

.rit-adjust-buttons .btn {
    padding: 8px 4px;
    font-size: 0.8em;
    min-height: 35px;
}

.rit-fine-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.rit-fine-control label {
    font-size: 0.8em;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.rit-knob-container {
    width: 60px;
    height: 60px;
    cursor: grab;
    user-select: none;
}

.rit-knob-container:active {
    cursor: grabbing;
}

.rit-knob-container .volume-knob {
    border: 1px solid #666;
}

.rit-knob-container .volume-knob:hover::after {
    background-color: #00ff88 !important;
}

#ritKnob.rit-active::after {
    background-color: #00ff88 !important;
}

/* RIT Active State */
.panel#ritPanel.rit-active {
    border-color: #00ff88;
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
}

.panel#ritPanel.rit-active h3 {
    color: #00ff88;
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
}

/* Responsive RIT */
@media (max-width: 599px) {
    .rit-adjust-buttons {
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
    }
    
    .rit-adjust-buttons .btn {
        font-size: 0.7em;
        padding: 6px 2px;
        min-height: 32px;
    }
    
    .rit-knob-container {
        width: 50px;
        height: 50px;
    }
}	
	/* --- START: CSS for PRONOUNCED Radial Knob Lines --- */

/* For the main tuning knob's inner face */
.tuning-knob::before {
    content: "";
    position: absolute;
    width: 90%;
    height: 90%;
    border-radius: 50%;
    /*
       FIX: The background is now ONLY the radial lines, making them visible.
       The lines are also darker and thicker.
    */
    background: repeating-conic-gradient(
        from 0deg,
        rgba(0, 0, 0, 0.35) 0deg 0.6deg,  /* Darker, thicker line */
        transparent 0.6deg 10deg         /* Gap between lines */
    );
}

/* Adds more pronounced radial lines to the smaller control knobs */
.volume-knob::before {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    box-shadow: inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3);
    /* Darker and thicker lines for better visibility */
   background: repeating-conic-gradient(
        from 0deg,
        rgba(0, 0, 0, 0.4) 0deg 0.7deg,   /* Darker, thicker line */
        transparent 0.7deg 10deg         /* Gap between lines */
    );
    z-index: -1;
}

/* --- END: CSS for Pronounced Radial Knob Lines --- */
/* --- START: Spectrum Display Styles --- */
#spectrumPanel {
    background: #000; /* Dark background for better contrast */
}

.spectrum-container {
    width: 100%;
    height: 120px;
    background-color: #10151a;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 5px;
    margin-bottom: 10px;
    cursor: crosshair;
}

#spectrumCanvas {
    width: 100%;
    height: 100%;
    display: block;
}

.spectrum-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    font-size: 0.9em;
}

.spectrum-controls select {
    width: 100px;
}
/* --- END: Spectrum Display Styles --- */
/* --- START: Autotune Button Style --- */
.btn.autotune-active {
    background: var(--button-active);
    color: #000;
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
    font-weight: bold;
}
/* --- END: Autotune Button Style --- */
	</style>
</head>
<body>
    <div class="transceiver-container">
        
        <div class="left-panel">
            <div class="panel" id="serialPanel">
                <h3>Serial</h3>
                <div class="control-group">
                    <label>Baud Rate</label>
                    <select id="baudRate"><option value="115200" selected>115200</option></select>
                </div>
                <button id="connectBtn" class="btn btn-primary" style="margin-top:10px;">Connect</button>
            </div>
            
			<div class="panel step-panel" id="stepPanel">
    <h3>Tuning Step</h3>
    <div class="control-group">
        <label>Step Size</label>
        <select id="stepSize">
            <option value="1" selected>1 Hz</option>
            <option value="10">10 Hz</option>
            <option value="100">100 Hz</option>
            <option value="1000">1 kHz</option>
            <option value="10000">10 kHz</option>
        </select>
	 </div>	
	  <div class="controls-grid" style="margin-top: 10px;">
        <button class="btn btn-secondary" id="autotuneBtn">
            AUTOTUNE OFF
        </button>
        <button class="btn btn-secondary" id="manualScanBtn">
            SCAN NOW
        </button>
    </div>

    
</div>
            
            
            <div class="panel" id="modePanel">
                <h3>Mode</h3>
                <div class="mode-buttons">
                    <div class="mode-btn active" data-mode="USB" data-catmode="2">USB</div>
                    <div class="mode-btn" data-mode="LSB" data-catmode="1">LSB</div>
                    <div class="mode-btn" data-mode="CW" data-catmode="3">CW</div>
                    <div class="mode-btn" data-mode="DIGI" data-catmode="6">DIGI</div>
                </div>
            </div>
            <div class="panel" id="bandPanel">
                <h3>Band</h3>
                <div class="band-buttons">
                    <div class="btn band-btn" data-band="160">160m</div><div class="btn band-btn" data-band="80">80m</div><div class="btn band-btn" data-band="60">60m</div>
                    <div class="btn band-btn" data-band="40">40m</div><div class="btn band-btn" data-band="30">30m</div><div class="btn band-btn active" data-band="20">20m</div>
                    <div class="btn band-btn" data-band="17">17m</div><div class="btn band-btn" data-band="15">15m</div><div class="btn band-btn" data-band="12">12m</div>
                    <div class="btn band-btn" data-band="10">10m</div><div class="btn band-btn" data-band="6">6m</div>
                </div>
            </div>
            <div class="panel" id="audioStreamPanel">
                <h3>Audio Stream</h3>
             
    <div class="audio-status-bar" style="margin-bottom: 10px;">
        <div class="status-indicator">
            <div class="status-dot" id="audioStatusDot"></div>
            <span class="status-text" id="audioStatusText">Ready to stream</span>
        </div>
    </div>
    <!-- Add audio level meter -->
    <div class="audio-meter-container" style="margin-bottom: 10px;">
        <label style="font-size: 0.8em;">Input Level</label>
        <div class="audio-meter-bar">
            <div class="audio-meter-indicator" id="inputLevelMeter"></div>
        </div>
        <div id="inputLevelText" style="font-size: 0.8em; text-align: center;">-âˆž dB</div>
    </div>
    <!-- Add audio gain control -->
    <div class="control-group" style="margin-bottom: 10px;">
        <label>Audio Gain</label>
        <input type="range" id="audioGainSlider" min="10" max="500" value="200" style="width: 100%;">
        <div id="audioGainLevel" class="knob-level" style="text-align: center;">2.0x (+6.0 dB)</div>
    </div>




			   <div class="audio-device-grid">
                     <div class="control-group"><label>Input</label><select id="audioInputDevice"><option value="">Select...</option></select></div>
                     <div class="control-group"><label>Output</label><select id="audioOutputDevice"><option value="">Select...</option></select></div>
                </div>
                <div class="audio-controls">
                    <button class="btn btn-primary" id="startStreamBtn">Start</button>
                    <button class="btn btn-secondary" id="stopStreamBtn" disabled>Stop</button>
                </div>
                 <button class="btn btn-secondary" id="refreshDevicesBtn" style="width:100%; margin-top: 8px;">Refresh</button>
            </div>
            <div class="panel" id="catPanel">
                <h3>CAT Log</h3>
                <div class="cat-log" id="catLog"></div>
            </div>
      


	  </div>

        <div class="center-panel">
            <div class="panel-lock-controls">
                <button class="btn" id="panelLockToggle"><span id="lockIcon">ðŸ”“</span> <span id="lockText">Panels Unlocked</span></button>
            </div>
            <div class="panel frequency-display lcd-panel" id="lcdPanel">
                <div id="lcdRow1" class="lcd-row">QMX Interface</div>
                <div id="lcdRow2" class="lcd-row">Connect Radio</div>
            </div>
            <div class="panel" id="tuningPanel">
                 <h3 style="text-align: center;">Main Tuning</h3>
                 <div class="tuning-knob-container" id="tuningKnobContainer">
                    <div class="frequency-markings" id="frequencyMarkings"></div>
                    <div class="tuning-knob" id="tuningKnob" tabindex="0"><div class="tuning-knob-center"></div></div>
                </div>
            </div>
			
			<div class="panel" id="spectrumPanel">
    <h3>Spectrum</h3>
    <div class="spectrum-container">
        <canvas id="spectrumCanvas"></canvas>
    </div>
    <div class="spectrum-controls">
        <span>Target CW Pitch:</span>
        <select id="targetPitch">
            <option value="600">600 Hz</option>
            <option value="700" selected>700 Hz</option>
            <option value="800">800 Hz</option>
        </select>
    </div>
</div>
             <div class="panel" id="vfoPanel">
                <h3>VFO & Transmit</h3>
                <div class="controls-grid">
                    <button class="btn btn-primary" id="vfoA">VFO A</button> 
                    <button class="btn btn-secondary" id="vfoB">VFO B</button>
                    <button class="btn btn-secondary" id="txBtn">TX</button> 
                    <button class="btn btn-primary" id="rxBtn">RX</button>
                </div>
                <div class="controls-grid" style="margin-top: 10px;">
                    <button class="btn btn-secondary" id="vfoSwap">Aâ†”B</button>
                    <button class="btn btn-secondary" id="vfoCopy">Aâ†’B</button>
                </div>
            </div>
             <div class="status-bar">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span class="status-text disconnected" id="statusText">DISCONNECTED</span>
                </div>
                <div id="currentTime"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel" id="qsoLoggerPanel">
                <h3>QSO Logger (<span id="qsoCount">0</span>)</h3>
                 <div class="qso-inputs-grid">
                    <input type="text" id="qsoCallsign" placeholder="Callsign"> <input type="text" id="qsoRstSent" value="599">
                    <input type="text" id="qsoRstRcvd" value="599"> <input type="text" id="qsoName" placeholder="Name">
                    <div class="control-group qth-group">
                        <input type="text" id="qsoQth" placeholder="QTH">
                    </div>
                    <div class="control-group comments-group">
                        <input type="text" id="qsoComments" placeholder="Comments">
                    </div>
                </div>
                <div id="qsoInfoBar" class="qso-info-bar" style="margin-top:10px;"></div>
                <div class="controls-grid" style="margin-top:10px;">
                    <button class="btn btn-primary" id="logQsoBtn">Log QSO</button>
                    <button class="btn btn-secondary" id="clearQsoInputsBtn">Clear</button>
                </div>
                <div class="log-management" style="margin-top:10px;">
                    <input type="text" id="qsoSearch" placeholder="Search Callsign...">
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="exportAdifBtn">Export</button>
                        <button class="btn btn-secondary" id="importAdifBtn">Import</button>
                        <input type="file" id="importAdifFile" accept=".adi,.adif" style="display: none;">
                        <button class="btn btn-danger" id="clearLogBtn" style="grid-column: 1 / -1;">Clear Log</button>
                    </div>
                </div>
                 <div class="qso-log-table" style="margin-top:10px;">
                    <div class="log-header">
                        <div>TIME</div><div>CALL</div><div>FREQ</div><div>MODE</div><div>RST</div>
                    </div>
                    <div class="log-body" id="qsoLogBody"></div>
                </div>
            </div>
             <div class="panel" id="memoryPanel">
                <h3>Memory</h3>
                <div class="controls-grid">
                    <button class="btn btn-secondary" id="storeBtn">Store</button> 
                    <button class="btn btn-secondary" id="recallBtn">Recall</button>
                    <button class="btn btn-secondary" id="editBtn">Edit</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear</button>
                </div>
                
				  <div class="controls-grid" style="margin-top: 10px;">
        <button class="btn btn-secondary" id="exportBtn">Export</button>
        <button class="btn btn-secondary" id="importBtn">Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;">
        <button class="btn btn-danger" id="clearAllBtn" style="grid-column: 1 / -1;">Clear All</button>
    </div>
				
				
				<div class="memory-buttons">
                    <div class="memory-btn" data-channel="1">M1</div> <div class="memory-btn" data-channel="2">M2</div>
                    <div class="memory-btn" data-channel="3">M3</div> <div class="memory-btn" data-channel="4">M4</div>
                    <div class="memory-btn" data-channel="5">M5</div> <div class="memory-btn" data-channel="6">M6</div>
                    <div class="memory-btn" data-channel="7">M7</div> <div class="memory-btn" data-channel="8">M8</div>
                    <div class="memory-btn" data-channel="9">M9</div><div class="memory-btn" data-channel="10">M10</div>
                </div>
             </div>
			 
			 <!-- Add the memory edit modal -->
<div class="memory-edit-modal" id="memoryEditModal" style="display: none;">
    <div class="modal-content">
        <h3>Edit Memory Channel M<span id="editChannelNumber">1</span></h3>
        
        <div class="control-group">
            <label>Frequency (MHz)</label>
            <input type="text" id="memoryFreqInput" placeholder="14.205">
        </div>
        
        <div class="control-group">
            <label>Mode</label>
            <select id="memoryModeSelect">
                <option value="USB">USB</option>
                <option value="LSB">LSB</option>
                <option value="CW">CW</option>
                <option value="DIGI">DIGI</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Band</label>
            <select id="memoryBandSelect">
                <option value="160">160m</option>
                <option value="80">80m</option>
                <option value="60">60m</option>
                <option value="40">40m</option>
                <option value="30">30m</option>
                <option value="20">20m</option>
                <option value="17">17m</option>
                <option value="15">15m</option>
                <option value="12">12m</option>
                <option value="10">10m</option>
                <option value="6">6m</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Label</label>
            <input type="text" id="memoryLabelInput" placeholder="Optional label">
        </div>
        
        <div class="modal-buttons">
            <button class="btn btn-primary" id="saveMemoryEdit">Save</button>
            <button class="btn btn-secondary" id="cancelMemoryEdit">Cancel</button>
        </div>
    </div>
</div>
			 
			 
			 
             <div class="panel" id="controlsPanel">
                <h3>Controls</h3>
              <div class="knobs-row">
    <div class="knob-group">
        <label>AF Gain</label>
        <div class="volume-knob-container"><div class="volume-knob" id="volumeKnob"></div></div>
        <div class="knob-level" id="volumeLevel">75db</div>
    </div>
    <div class="knob-group">
        <div class="keyer-mode-toggle">
            <div class="toggle-switch" id="keyerModeToggle">
                <div class="toggle-slider"></div>
                <span class="toggle-label left">STRAIGHT</span>
                <span class="toggle-label right">BUG</span>
            </div>
        </div>
        <label>CW Speed</label>
        <div class="volume-knob-container"><div class="volume-knob" id="rfGainKnob"></div></div>
        <div class="knob-level" id="rfGainLevel">22 WPM</div>
    </div>
    </div>
            </div>
          <div class="panel" id="sMeterPanel">
    <h3>S-Meter</h3>
    <div class="meter">
        <div class="meter-bar">
            <div class="meter-indicator" id="sMeter"></div>
        </div>
    </div>
    <div id="sMeterText" style="text-align: center; font-family: 'Courier New', monospace; color: var(--accent-color); margin-top: 5px;">S0</div>
</div>

<div class="panel" id="swrPanel">
    <h3>SWR</h3>
    <div class="meter">
        <div class="meter-bar">
            <div class="meter-indicator" id="swrMeter"></div>
        </div>
    </div>
    <div id="swrText" style="text-align: center; font-family: 'Courier New', monospace; color: var(--accent-color); margin-top: 5px;">1.0:1</div>
</div>
          <div class="panel" id="ritPanel">
    <h3>RIT</h3>
    <div class="rit-status-display" id="ritStatusDisplay">
        <span class="rit-status" id="ritStatus">OFF</span>
        <span class="rit-offset-value" id="ritOffsetValue">+0 Hz</span>
    </div>
    <div class="controls-grid">
        <button class="btn btn-secondary" id="ritToggleBtn">RIT ON/OFF</button>
        <button class="btn btn-secondary" id="ritClearBtn">CLEAR</button>
    </div>
    <!-- Optional: Add RIT adjustment buttons -->
    <div class="rit-adjust-buttons">
        <button class="btn btn-secondary rit-adjust" data-offset="-100">-100</button>
        <button class="btn btn-secondary rit-adjust" data-offset="-10">-10</button>
        <button class="btn btn-secondary rit-adjust" data-offset="-1">-1</button>
        <button class="btn btn-secondary rit-adjust" data-offset="1">+1</button>
        <button class="btn btn-secondary rit-adjust" data-offset="10">+10</button>
        <button class="btn btn-secondary rit-adjust" data-offset="100">+100</button>
    </div>
</div>
        </div>
    </div>
    
   


   <div class="modal-overlay" id="modalOverlay"></div>
	
	
 
   <script>
        class QMXInterface {
            constructor() {
                this.frequency = 14205000;
                this.stepSize = 1;
                this.mode = 'USB';
                this.connected = false;
                this.band = '20';
                this.currentVFO = 'A';
                this.transmitting = false;
				this.pollingInterval = null;
                
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.commandQueue = [];
                this.isProcessingQueue = false;
                this.catTimeout = null;
                this.connectionCheckTimeout = null;
                this.lastCommandTime = 0;
                
                this.memoryChannels = new Array(10).fill(null);
                this.selectedMemoryChannel = null;
                this.memoryMode = 'recall';
                
                this.catLogElement = null;
                
                this.tuningKnobRotation = 0;
                this.tuningLastAngle = 0;
                this.isTuningAdjusting = false;
                this.tuningAnimationFrame = null;
                
                this.totalRotationRange = 270;
                this.minRotation = -135;
                this.maxRotation = 135;
                this.volumeKnobRotation = 0;
                this.volumeLevel = 75;
                this.volumeLastAngle = 0;
                this.isVolumeAdjusting = false;
                this.volumeAnimationFrame = null;
                this.volumeTimeout = null;
                
                this.rfGainKnobRotation = 0;
                this.rfGainLevel = 22;
                this.rfGainLastAngle = 0;
                this.isRFGainAdjusting = false;
                this.rfGainAnimationFrame = null;
                this.rfGainTimeout = null;
                
                this.powerKnobRotation = 0;
                this.powerLevel = 50;
                this.powerLastAngle = 0;
                this.isPowerAdjusting = false;
                this.powerAnimationFrame = null;
                this.powerTimeout = null;
                this.powerLevelBeforeAdjust = 50;
				//...
            this.autotuneDebounceTime = 750; 
            this.lastManualFreqSet = 0; // <-- ADD THIS LINE
            try {
            //...
		// Add these after your existing properties


// Add these audio properties:
this.audioContext = null;
this.inputStream = null;
this.inputSource = null;
this.gainNode = null;
this.inputAnalyser = null;
this.isAudioStreaming = false;
this.audioDevices = { input: [], output: [] };
this.selectedInputDevice = null;
this.selectedOutputDevice = null;
				
				
  // NEW: Add these for hover keyboard control
    this.isHoveringTuningKnob = false;
    this.boundHandleTuningHoverKeys = null;
                this.qsoLog = [];
                this.qsoLogFilter = '';
                 // NEW: Variable speed tuning properties
    this.originalStepSize = 1;  // Store the user-selected step
    this.isVariableStepActive = false;  // Track if we're in fast mode
    this.lastTuningTime = 0;  // Track timing for speed detection
    this.tuningSpeedSamples = [];  // Store recent speed samples
    this.variableStepTimeout = null;  // Timeout to revert step size
    this.fastStepMultiplier = 10;
	
	this.audioGain = 1.0;
this.audioGainSlider = null;
	
	 this.keyerMode = 'straight';  // 'straight' or 'bug'
    this.bugWpmSetting = 22; 
                // NEW: Property to hold last-tuned frequencies per band - UPDATED with 60m
                this.lastFrequencies = {
                    '160': 1900000, '80': 3500000, '60': 5351500, '40': 7000000, '30': 10100000, '20': 14000000,
                    '17': 18068000, '15': 21000000, '12': 24890000, '10': 28000000, '6': 50000000
                };
                // NEW: Property for debouncing frequency saves
                this.saveFreqTimeout = null;
// ADD these RIT properties here:
    this.ritEnabled = false;
    this.ritOffset = 0;
    this.ritKnobRotation = 0;
    this.ritLastAngle = 0;
    this.isRITAdjusting = false;
    this.ritAnimationFrame = null;
    this.ritTimeout = null;
    this.ritStep = 10;
	this.isWaitingForRITConfirmation = false;
this.ritConfirmationTimeout = null;
	  this.panelsLocked = false;  // NEW: Track panel lock state
    this.sortableInstances = []; // NEW: Store Sortable instances
	// Add these for the Spectrum Display
this.spectrumEnabled = false;
this.spectrumAnimationFrame = null;
this.targetPitch = 700;
this.spectrumBandwidth = 2400;
// Add these for the Autotune feature
this.autotuneEnabled = false;
this.autotuneScanTimeout = null;

                    this.catLogElement = document.getElementById('catLog');
                    
                    this.loadLayout();
                    this.loadLastFrequencies(); // NEW: Call new method to load frequencies
                    this.frequency = this.lastFrequencies[this.band]; // NEW: Set initial frequency from saved state

                    this.initDraggablePanels();
                    this.initTuningKnob();
                    this.initEventListeners();
                    this.initVolumeControl();
                    this.initRFGainControl();
                    this.initPowerControl();
					this.initRITControl();
                    this.initMemorySystem();
                    this.initQsoLogger();
					this.initFrequencyKeyboard();
                    this.updateDisplay();
                    this.updateTXStatus();
                    this.updateConnectionStatus();
					this.initAudioStreaming();
					
                    this.initTimeSync();
                    window.qmxInterface = this;  
                    window.addEventListener('blur', () => {
                        if (this.isPowerAdjusting) this.stopPowerAdjust();
                        if (this.isVolumeAdjusting) this.stopVolumeAdjust();
                        if (this.isRFGainAdjusting) this.stopRFGainAdjust();
                        if (this.isTuningAdjusting) this.stopTuningAdjust();
                    });
					
					if (this.isRITAdjusting) this.stopRITAdjust();
					// ...
    
    this.initSpectrumDisplay(); // Add this line
this.initAutotune(); // Add this line
// ...
                } catch (error) {
                    console.error('Failed to initialize QMX Interface:', error);
                }
            }


// --- Frequency Input Keyboard ---
initFrequencyKeyboard() {
    try {
        this.freqInputFormat = 'mhz';
        this.freqInputValue = '';
        
        // Make frequency display clickable to open the popup
        document.getElementById('lcdPanel').addEventListener('click', () => this.openFrequencyKeyboard());

        // --- Listeners for the POPUP modal ---
        // Get the modal container to scope the selections
        const modal = document.getElementById('freqInputModal');
        
        // Format buttons for POPUP (scoped to modal)
        modal.querySelectorAll('.freq-format-btn').forEach(btn => {
            btn.addEventListener('click', () => this.setFreqInputFormat(btn.dataset.format));
        });
        
        // Keypad buttons for POPUP (scoped to modal)
        modal.querySelectorAll('.freq-key').forEach(key => {
            key.addEventListener('click', () => this.handleFreqKeyInput(key.dataset.key));
        });
        
        // Action buttons for POPUP
        document.getElementById('freqSetBtn').addEventListener('click', () => this.setFrequencyFromInput());
        document.getElementById('freqCancelBtn').addEventListener('click', () => this.closeFrequencyKeyboard());
        document.getElementById('freqClearBtn').addEventListener('click', () => this.clearFreqInput());
        
        // Input field events for POPUP
        const freqInput = document.getElementById('freqDisplayInput');
        freqInput.addEventListener('input', (e) => this.handleFreqInputChange(e));
        freqInput.addEventListener('keydown', (e) => this.handleFreqInputKeyboard(e));
        
        // Modal overlay listener
        document.getElementById('modalOverlay').addEventListener('click', () => {
            if (document.getElementById('freqInputModal').classList.contains('active')) {
                this.closeFrequencyKeyboard();
            }
        });
        
        // --- Initialize the PERMANENT panel and its controls (ONCE) ---
        this.initPermanentFreqInput();
        
        // Add listener for the mode toggle dropdown
        document.getElementById('freqInputMode').addEventListener('change', (e) => {
            this.setFreqInputMode(e.target.value);
        });
        
        // Set the initial input mode to 'popup'
        this.setFreqInputMode('popup');
		
        console.log('Frequency input keyboard initialized');
    } catch (error) {
        console.error('Error initializing frequency keyboard:', error);
    }
}

openFrequencyKeyboard() {
    // Set current frequency in the input
    this.freqInputValue = this.formatFrequencyForInput(this.frequency, this.freqInputFormat);
    document.getElementById('freqDisplayInput').value = this.freqInputValue;
    
    // Show modal
    document.getElementById('modalOverlay').classList.add('active');
    document.getElementById('freqInputModal').classList.add('active');
    
    // Focus the input
    setTimeout(() => {
        document.getElementById('freqDisplayInput').focus();
        document.getElementById('freqDisplayInput').select();
    }, 100);
    
    this.clearFreqError();
    this.logCAT('Frequency keyboard opened', 'info');
}

closeFrequencyKeyboard() {
    document.getElementById('modalOverlay').classList.remove('active');
    document.getElementById('freqInputModal').classList.remove('active');
    this.clearFreqError();
}

setFreqInputFormat(format) {
    this.freqInputFormat = format;
    
    // Update active button
    document.querySelectorAll('.freq-format-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.format === format) {
            btn.classList.add('active');
        }
    });
    
    // Update the input field with current frequency in new format
    this.freqInputValue = this.formatFrequencyForInput(this.frequency, format);
    document.getElementById('freqDisplayInput').value = this.freqInputValue;
    this.clearFreqError();
    
    this.logCAT(`Frequency format changed to ${format.toUpperCase()}`, 'info');
}

handleFreqKeyInput(key) {
    const freqInput = document.getElementById('freqDisplayInput');
    
    if (key === 'backspace') {
        this.freqInputValue = this.freqInputValue.slice(0, -1);
    } else {
        // Limit input length
        if (this.freqInputValue.length >= 15) return;
        
        // Handle decimal point
        if (key === '.') {
            // Only allow one decimal point
            if (this.freqInputValue.includes('.')) return;
            // Don't allow decimal at start
            if (this.freqInputValue.length === 0) return;
        }
        
        this.freqInputValue += key;
    }
    
    freqInput.value = this.freqInputValue;
    this.validateFreqInput();
    
    // Keep focus on input
    freqInput.focus();
}

handleFreqInputChange(e) {
    // Allow only numbers and decimal point
    let value = e.target.value.replace(/[^0-9.]/g, '');
    
    // Ensure only one decimal point
    const parts = value.split('.');
    if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
    }
    
    this.freqInputValue = value;
    e.target.value = value;
    this.validateFreqInput();
}

handleFreqInputKeyboard(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        this.setFrequencyFromInput();
    } else if (e.key === 'Escape') {
        e.preventDefault();
        this.closeFrequencyKeyboard();
    }
}

clearFreqInput() {
    this.freqInputValue = '';
    document.getElementById('freqDisplayInput').value = '';
    this.clearFreqError();
    document.getElementById('freqDisplayInput').focus();
}

validateFreqInput() {
    const errorEl = document.getElementById('freqError');
    errorEl.textContent = '';
    
    if (!this.freqInputValue) return true;
    
    const freq = this.parseFrequencyInput(this.freqInputValue, this.freqInputFormat);
    
    if (freq === null) {
        errorEl.textContent = 'Invalid frequency format';
        return false;
    }
    
    if (freq < 100000 || freq > 999999999) {
        errorEl.textContent = 'Frequency out of range (0.1 - 999.999 MHz)';
        return false;
    }
    
    return true;
}

clearFreqError() {
    document.getElementById('freqError').textContent = '';
}

// Replace the existing setFrequencyFromInput() method with this fixed version:

setFrequencyFromInput() {
    if (!this.validateFreqInput()) return;
    
    const freq = this.parseFrequencyInput(this.freqInputValue, this.freqInputFormat);
    if (freq === null) return;
    
    // Set the new frequency
    this.frequency = freq;
    
    // Update all displays and band selection
    this.updateDisplay();
    this.updateBandFromFrequency(); // Ensure band is updated
    
    // Update the band buttons to show the correct band
    this.updateBandButtons();
    
    // Save the frequency for this band
    this.saveLastFrequency();
    
    // Send frequency to radio if connected
    if (this.connected) {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
            // Request frequency confirmation after a brief delay
            setTimeout(() => {
               this.setFrequencyAndRestoreGain(this.frequency);
            }, 100);
        }).catch(e => {
            this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
        });
    }
    
    // Update the tuning knob visual position (optional visual feedback)
    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
    
    // Log the frequency change
    const displayStr = this.frequency.toString().padStart(9, '0');
    const mhz = displayStr.substring(0, 3);
    const khz = displayStr.substring(3, 6);
    const hz = displayStr.substring(6, 9);
    this.logCAT(`Direct frequency entry: ${mhz}.${khz}.${hz} Hz`, 'info');
    
    // Close the frequency input modal
    this.closeFrequencyKeyboard();
}

formatFrequencyForInput(freqHz, format) {
    switch (format) {
        case 'mhz':
            return (freqHz / 1000000).toFixed(6).replace(/\.?0+$/, '');
        case 'khz':
            return (freqHz / 1000).toFixed(3).replace(/\.?0+$/, '');
        case 'hz':
            return freqHz.toString();
        default:
            return (freqHz / 1000000).toFixed(6).replace(/\.?0+$/, '');
    }
}

parseFrequencyInput(input, format) {
    if (!input) return null;
    
    const value = parseFloat(input);
    if (isNaN(value) || value <= 0) return null;
    
    let freqHz;
    switch (format) {
        case 'mhz':
            freqHz = Math.round(value * 1000000);
            break;
        case 'khz':
            freqHz = Math.round(value * 1000);
            break;
        case 'hz':
            freqHz = Math.round(value);
            break;
        default:
            freqHz = Math.round(value * 1000000);
    }
    
    return freqHz;
}

            initMemorySystem() {
                try {
                    const savedMemories = localStorage.getItem('qmxMemoryChannels');
                    if (savedMemories) {
                        this.memoryChannels = JSON.parse(savedMemories);
                    }
                    document.getElementById('storeBtn').addEventListener('click', () => this.setMemoryMode('store'));
                    document.getElementById('recallBtn').addEventListener('click', () => this.setMemoryMode('recall'));
                    document.getElementById('editBtn').addEventListener('click', () => this.setMemoryMode('edit'));
                    document.getElementById('clearBtn').addEventListener('click', () => this.setMemoryMode('clear'));
                    document.getElementById('exportBtn').addEventListener('click', () => this.exportMemories());
                    document.getElementById('importBtn').addEventListener('click', () => {
                        document.getElementById('importFile').click();
                    });
                    document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAllMemories());
                    document.getElementById('importFile').addEventListener('change', (e) => this.importMemories(e));
                    document.querySelectorAll('.memory-btn').forEach((btn) => {
                        const channel = parseInt(btn.dataset.channel);
                        let clickTimer = null;
                        btn.addEventListener('click', (e) => {
                            if (clickTimer) {
                                clearTimeout(clickTimer);
                                clickTimer = null;
                                if (this.memoryMode === 'recall') {
                                    this.storeMemoryChannel(channel);
                                    this.logCAT(`Quick-stored to M${channel}`, 'info');
                                }
                            } else {
                                clickTimer = setTimeout(() => {
                                    clickTimer = null;
                                    this.handleMemoryChannel(channel);
                                }, 250);
                            }
                        });
                        btn.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.editMemoryChannel(channel);
                        });
                    });
                    document.getElementById('saveMemoryEdit').addEventListener('click', () => this.saveMemoryEdit());
                    document.getElementById('cancelMemoryEdit').addEventListener('click', () => this.closeEditModal());
                    document.getElementById('modalOverlay').addEventListener('click', () => this.closeEditModal());
                    this.updateMemoryDisplay();
                    this.setMemoryMode('recall');
                    console.log('Memory system initialized');
                } catch (error) {
                    console.error('Error initializing memory system:', error);
                }
            }

            setMemoryMode(mode) {
                this.memoryMode = mode;
                const buttons = {
                    'store': document.getElementById('storeBtn'),
                    'recall': document.getElementById('recallBtn'),
                    'edit': document.getElementById('editBtn'),
                    'clear': document.getElementById('clearBtn')
                };
                Object.values(buttons).forEach(btn => {
                    btn.classList.remove('btn-primary', 'btn-danger');
                    btn.classList.add('btn-secondary');
                });
                if (buttons[mode]) {
                    buttons[mode].classList.remove('btn-secondary');
                    if (mode === 'clear') {
                        buttons[mode].classList.add('btn-danger');
                    } else {
                        buttons[mode].classList.add('btn-primary');
                    }
                }
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    btn.classList.remove('memory-store-warning');
                    btn.style.cursor = mode === 'recall' ? 'pointer' : 
                                      mode === 'store' ? 'copy' :
                                      mode === 'edit' ? 'text' :
                                      mode === 'clear' ? 'not-allowed' : 'pointer';
                    if (mode === 'store' && this.memoryChannels[index]) {
                        btn.classList.add('memory-store-warning');
                    }
                });
                this.logCAT(`Memory mode: ${mode.toUpperCase()} (${this.getMemoryModeHint(mode)})`, 'info');
            }

            getMemoryModeHint(mode) {
                switch(mode) {
                    case 'recall': return 'Click to recall, double-click to quick-store, right-click to edit';
                    case 'store': return 'Click any memory to store current settings';
                    case 'edit': return 'Click any memory to edit its settings';
                    case 'clear': return 'Click any memory to clear it';
                    default: return '';
                }
            }

            handleMemoryChannel(channel) {
                switch(this.memoryMode) {
                    case 'store': this.storeMemoryChannel(channel); break;
                    case 'recall': this.recallMemoryChannel(channel); break;
                    case 'edit': this.editMemoryChannel(channel); break;
                    case 'clear': this.clearMemoryChannel(channel); break;
                }
            }

            storeMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const existingLabel = this.memoryChannels[channelIndex]?.label || '';
                if (this.memoryChannels[channelIndex]) {
                    const existingMem = this.memoryChannels[channelIndex];
                    const freqMHz = (existingMem.frequency / 1000000).toFixed(3);
                    const label = existingMem.label ? `"${existingMem.label}"` : '';
                    if (!confirm(`Overwrite M${channel}?\n\nCurrent: ${freqMHz} MHz, ${existingMem.mode}${label}\n\nReplace with: ${(this.frequency / 1000000).toFixed(3)} MHz, ${this.mode}?`)) {
                        return;
                    }
                }
                const memoryData = {
                    frequency: this.frequency,
                    mode: this.mode,
                    band: this.band,
                    label: existingLabel,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = channel;
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Stored M${channel}: ${mhz}.${khz}.${hz} Hz, ${this.mode}${existingLabel ? ', "' + existingLabel + '"' : ''}`, 'info');
                setTimeout(() => {
                    this.setMemoryMode('recall');
                }, 1000);
            }

            recallMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                if (!memoryData) {
                    this.logCAT(`Memory M${channel} is empty`, 'error');
                    return;
                }
                this.frequency = memoryData.frequency;
                this.mode = memoryData.mode;
                this.band = memoryData.band;
                this.updateDisplay();
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === this.mode) {
                        btn.classList.add('active');
                    }
                });
               document.querySelectorAll('.band-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        // Only change band if user manually clicks (not auto-selection)
        if (btn.dataset.band !== this.band) {
            document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.band = btn.dataset.band;
            this.setBandFrequency(btn.dataset.band);
            this.logCAT(`Manually selected ${this.band}m band`, 'info');
        }
    });
});
              if (this.connected) {
    const freqStr = this.frequency.toString().padStart(11, '0');
    const vfoCommand = this.getVFOCommand();
    this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
        setTimeout(() => {
            this.sendCommand(this.getVFOCommand());
        }, 100);
    }).catch(e => {
        this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
    });
    
    const modeBtn = document.querySelector(`[data-mode="${this.mode}"]`);
    if (modeBtn) {
        const catMode = modeBtn.dataset.catmode;
        this.sendCommand(`MD${catMode}`).catch(e => {
            console.error("Mode command error:", e);
        });
    }
	
	}
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                const label = memoryData.label ? ` "${memoryData.label}"` : '';
                this.logCAT(`Recalled M${channel}${label}: ${mhz}.${khz}.${hz} Hz, ${this.mode}`, 'info');
                this.selectedMemoryChannel = channel;
                this.updateMemoryDisplay();
            }

            editMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                this.editingChannel = channel;
                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('memoryEditModal').classList.add('active');
                document.getElementById('editChannelNumber').textContent = channel;
                const freqInput = document.getElementById('memoryFreqInput');
                const modeSelect = document.getElementById('memoryModeSelect');
                const bandSelect = document.getElementById('memoryBandSelect');
                const labelInput = document.getElementById('memoryLabelInput');
                if (memoryData) {
                    freqInput.value = (memoryData.frequency / 1000000).toFixed(6);
                    modeSelect.value = memoryData.mode;
                    bandSelect.value = memoryData.band;
                    labelInput.value = memoryData.label || '';
                } else {
                    freqInput.value = (this.frequency / 1000000).toFixed(6);
                    modeSelect.value = this.mode;
                    bandSelect.value = this.band;
                    labelInput.value = '';
                }
                freqInput.addEventListener('input', () => {
                    const freqMHz = parseFloat(freqInput.value);
                    if (!isNaN(freqMHz)) {
                        const suggestedBand = this.getBandFromFrequency(freqMHz);
                        if (suggestedBand) {
                            bandSelect.value = suggestedBand;
                        }
                    }
                });
                freqInput.focus();
                freqInput.select();
                const handleEnter = (e) => {
                    if (e.key === 'Enter') {
                        this.saveMemoryEdit();
                    } else if (e.key === 'Escape') {
                        this.closeEditModal();
                    }
                };
                freqInput.onkeydown = handleEnter;
                labelInput.onkeydown = handleEnter;
            }

            saveMemoryEdit() {
                if (this.editingChannel === null) return;
                const channelIndex = this.editingChannel - 1;
                const freqInput = document.getElementById('memoryFreqInput').value.trim();
                const mode = document.getElementById('memoryModeSelect').value;
                const band = document.getElementById('memoryBandSelect').value;
                const label = document.getElementById('memoryLabelInput').value.trim();
                let frequency;
                if (freqInput) {
                    const cleanFreq = freqInput.replace(/[^0-9.]/g, '');
                    const freqMHz = parseFloat(cleanFreq);
                    if (isNaN(freqMHz) || freqMHz < 0.1 || freqMHz > 999.999999) {
                        alert('Please enter a valid frequency');
                        document.getElementById('memoryFreqInput').focus();
                        return;
                    }
                    frequency = Math.round(freqMHz * 1000000);
                } else {
                    alert('Please enter a frequency');
                    document.getElementById('memoryFreqInput').focus();
                    return;
                }
                const memoryData = {
                    frequency: frequency,
                    mode: mode,
                    band: band,
                    label: label,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = this.editingChannel;
                const freqStr = frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Updated M${this.editingChannel}: ${mhz}.${khz}.${hz} Hz, ${mode}, ${band}m${label ? ', "' + label + '"' : ''}`, 'info');
                this.closeEditModal();
            }

            closeEditModal() {
                document.getElementById('modalOverlay').classList.remove('active');
                document.getElementById('memoryEditModal').classList.remove('active');
                this.editingChannel = null;
            }

            clearMemoryChannel(channel) {
                const channelIndex = channel - 1;
                if (this.memoryChannels[channelIndex]) {
                    const memData = this.memoryChannels[channelIndex];
                    const freqMHz = (memData.frequency / 1000000).toFixed(3);
                    const label = memData.label || `M${channel}`;
                    if (confirm(`Clear memory channel M${channel}?\n\nFrequency: ${freqMHz} MHz\nMode: ${memData.mode}\nLabel: ${label}`)) {
                        this.memoryChannels[channelIndex] = null;
                        localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                        this.updateMemoryDisplay();
                        this.logCAT(`Cleared memory channel M${channel}`, 'info');
                        if (this.selectedMemoryChannel === channel) {
                            this.selectedMemoryChannel = null;
                        }
                    }
                } else {
                    this.logCAT(`Memory M${channel} is already empty`, 'error');
                }
            }

            clearAllMemories() {
                const usedMemories = this.memoryChannels.filter(m => m !== null).length;
                if (usedMemories === 0) {
                    this.logCAT('No memory channels to clear', 'info');
                    return;
                }
                if (confirm(`Clear ALL memory channels?\n\nThis will delete ${usedMemories} stored memories.\nThis action cannot be undone!`)) {
                    this.memoryChannels = new Array(10).fill(null);
                    localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                    this.selectedMemoryChannel = null;
                    this.updateMemoryDisplay();
                    this.logCAT(`Cleared all ${usedMemories} memory channels`, 'info');
                }
            }

            updateMemoryDisplay() {
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    const channel = index + 1;
                    const memoryData = this.memoryChannels[index];
                    btn.innerHTML = '';
                    btn.classList.remove('memory-occupied', 'memory-selected', 'memory-store-warning');
                    if (memoryData) {
                        btn.classList.add('memory-occupied');
                        if (this.memoryMode === 'store') {
                            btn.classList.add('memory-store-warning');
                        }
                        const channelSpan = document.createElement('span');
                        channelSpan.textContent = `M${channel}`;
                        btn.appendChild(channelSpan);
                        if (memoryData.label) {
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'memory-label';
                            labelSpan.textContent = memoryData.label;
                            btn.appendChild(labelSpan);
                        }
                        btn.title = `M${channel}: ${(memoryData.frequency / 1000000).toFixed(3)} MHz, ${memoryData.mode}${memoryData.label ? ' - ' + memoryData.label : ''}`;
                    } else {
                        btn.textContent = `M${channel}`;
                        btn.title = `M${channel}: Empty`;
                    }
                    if (this.selectedMemoryChannel === channel) {
                        btn.classList.add('memory-selected');
                    }
                });
            }

            exportMemories() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    memories: this.memoryChannels
                };
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qmx_memories_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('Memory channels exported successfully', 'info');
            }

            importMemories(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        if (importData.memories && Array.isArray(importData.memories)) {
                            if (confirm('This will replace all current memory channels. Continue?')) {
                                this.memoryChannels = importData.memories;
                                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                                this.updateMemoryDisplay();
                                this.logCAT('Memory channels imported successfully', 'info');
                            }
                        } else {
                            throw new Error('Invalid file format');
                        }
                    } catch (error) {
                        this.logCAT(`Import failed: ${error.message}`, 'error');
                        alert('Failed to import memory file.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            logCAT(message, type = 'info') {
                if (!this.catLogElement) {
                    this.catLogElement = document.getElementById('catLog');
                }
                if (!this.catLogElement) return;
                const entry = document.createElement('div');
                entry.className = `cat-log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `${timestamp} ${type.toUpperCase()}: ${message}`;
                this.catLogElement.appendChild(entry);
                this.catLogElement.scrollTop = this.catLogElement.scrollHeight;
                while (this.catLogElement.children.length > 200) {
                    this.catLogElement.removeChild(this.catLogElement.firstChild);
                }
            }

            async initializeRadio() {
                await this.sendCommand('IF');
                await this.sendCommand('LC');
                await this.sendCommand('FA');
                await this.sendCommand('MD');
                await this.sendCommand('AG0');
                await this.sendCommand('KS');
                await this.sendCommand('SM');
                await this.sendCommand('SW');
                await this.sendCommand('PC');
				await this.sendCommand('RT');   // Get RIT status
                await this.sendCommand('RC');   // Clear RIT initially
				this.sendTimeToQMX();
            }

            initEventListeners() {
 this.initPanelLockToggle();
    
   // document.getElementById('connectBtn').addEventListener('click', async () => {               


			   document.getElementById('connectBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.disconnectSerial();
                    } else {
                        await this.connectSerial();
                    }
                });
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.mode = btn.dataset.mode;
                        if (this.connected) {
                            const catMode = btn.dataset.catmode;
                            await this.sendCommand(`MD${catMode}`);
                            this.logCAT(`Mode changed to ${this.mode}`, 'info');
                        }
                    });
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.band = btn.dataset.band;
                        this.setBandFrequency(btn.dataset.band);
                    });
                });
				
				
				
               // MODIFY your existing stepSize change handler in initEventListeners:
// Replace the existing stepSize event listener with this:
document.getElementById('stepSize').addEventListener('change', (e) => {
    this.originalStepSize = parseInt(e.target.value);
    if (!this.isVariableStepActive) {
        this.stepSize = this.originalStepSize;
    }
    this.logCAT(`Tuning step set to ${this.originalStepSize} Hz`, 'info');
});
                document.getElementById('vfoA').addEventListener('click', async () => {
    this.selectVFO('A');
    if (this.connected) {
        await this.sendCommand('FR0');  // Select VFO A for RX
        await this.sendCommand('FT0');  // Select VFO A for TX
        // Request frequency update for VFO A
        await this.sendCommand('FA');
    }
});

document.getElementById('vfoB').addEventListener('click', async () => {
    this.selectVFO('B');
    if (this.connected) {
        await this.sendCommand('FR1');  // Select VFO B for RX
        await this.sendCommand('FT1');  // Select VFO B for TX
        // Request frequency update for VFO B
        await this.sendCommand('FB');
    }
	
	 if (this.sortableInstances.length === 0) {
        this.initDraggablePanels();
    }
	
	
});
              // This is inside the initEventListeners function
			  
			  
			  
			  
			  
			  
			  
			  

document.getElementById('vfoB').addEventListener('click', async () => {
    this.selectVFO('B');
    if (this.connected) {
        await this.sendCommand('FR1');
        await this.sendCommand('FT1');
        // Add this line to ask for the new VFO's frequency
        await this.sendCommand('FB'); 
    }

                });
               







			document.getElementById('vfoSwap').addEventListener('click', async () => {
    if (this.connected) {
        try {
            this.logCAT('Swapping VFO A â†” VFO B...', 'info');
            
            // Get current frequencies from both VFOs
            await this.sendCommand('FA');  // Request VFO A frequency
            await new Promise(resolve => setTimeout(resolve, 100));
            await this.sendCommand('FB');  // Request VFO B frequency
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Store current frequencies (they should be updated from the responses)
            let vfoAFreq = null;
            let vfoBFreq = null;
            
            // Create a temporary response handler to capture VFO frequencies
            const originalProcessResponse = this.processResponse.bind(this);
            let responsesReceived = 0;
            
            this.processResponse = (response) => {
                if (response.startsWith('FA')) {
                    vfoAFreq = parseInt(response.substring(2));
                    responsesReceived++;
                } else if (response.startsWith('FB')) {
                    vfoBFreq = parseInt(response.substring(2));
                    responsesReceived++;
                } else {
                    originalProcessResponse(response);
                }
            };
            
            // Wait for responses or timeout
            let attempts = 0;
            while (responsesReceived < 2 && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 50));
                attempts++;
            }
            
            // Restore original response handler
            this.processResponse = originalProcessResponse;
            
            if (vfoAFreq && vfoBFreq && vfoAFreq !== vfoBFreq) {
                // Perform the swap
                await this.sendCommand(`FA${vfoBFreq.toString().padStart(11, '0')}`);
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendCommand(`FB${vfoAFreq.toString().padStart(11, '0')}`);
                
                this.logCAT(`VFO swap completed: A=${(vfoBFreq/1000000).toFixed(3)} MHz, B=${(vfoAFreq/1000000).toFixed(3)} MHz`, 'info');
                
                // Update display
                setTimeout(async () => {
                    await this.sendCommand('IF');
                    await this.sendCommand('LC');
                }, 200);
            } else {
                this.logCAT('VFO swap failed: Could not read frequencies', 'error');
            }
            
        } catch (e) {
            this.logCAT(`VFO swap error: ${e.message}`, 'error');
        }
    } else {
        this.logCAT('Cannot swap - radio not connected', 'error');
    }
});		   
						   
						   
						   
						   
						   
						   
						   
						   
document.getElementById('vfoCopy').addEventListener('click', async () => {
    if (this.connected) {
        try {
            // Get the current VFO's frequency first
            const currentVFOCommand = this.currentVFO === 'A' ? 'FA' : 'FB';
            await this.sendCommand(currentVFOCommand);
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Use the frequency from the interface (should be current)
            const currentFreq = this.frequency.toString().padStart(11, '0');
            
            if (this.currentVFO === 'A') {
                // Copy A to B
                await this.sendCommand(`FB${currentFreq}`);
                this.logCAT(`Aâ†’B: ${(this.frequency/1000000).toFixed(3)} MHz copied`, 'info');
            } else {
                // Copy B to A  
                await this.sendCommand(`FA${currentFreq}`);
                this.logCAT(`Bâ†’A: ${(this.frequency/1000000).toFixed(3)} MHz copied`, 'info');
            }
            
            // Update display
            setTimeout(async () => {
                await this.sendCommand('IF');
                await this.sendCommand('LC');
            }, 200);
            
        } catch (e) {
            this.logCAT(`VFO copy error: ${e.message}`, 'error');
        }
    } else {
        this.logCAT('Cannot copy - radio not connected', 'error');
    }
});
               







			   document.getElementById('txBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('TX');
                        this.transmitting = true;
                        this.updateTXStatus();
                        this.logCAT('Switched to TRANSMIT mode', 'info');
                    } else {
                        this.logCAT('Cannot transmit - radio not connected', 'error');
                    }
                });
                document.getElementById('rxBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('RX');
                        this.transmitting = false;
                        this.updateTXStatus();
                        this.logCAT('Switched to RECEIVE mode', 'info');
                    } else {
                        this.logCAT('Cannot switch to RX - radio not connected', 'error');
                    }
                });
		  }

           setBandFrequency(band) {
    if (this.lastFrequencies[band]) {
        this.frequency = this.lastFrequencies[band];
        this.updateDisplay();
        if (this.connected) {
           this.setFrequencyAndRestoreGain(this.frequency);
        }
    }
}

         getBandFromFrequency(freqMHz) {
    // More precise band edge definitions with 60m added
    if (freqMHz >= 1.800 && freqMHz <= 2.000) return '160';
    if (freqMHz >= 3.500 && freqMHz <= 4.000) return '80';
    if (freqMHz >= 5.330 && freqMHz <= 5.405) return '60'; // NEW: 60m band
    if (freqMHz >= 7.000 && freqMHz <= 7.300) return '40';
    if (freqMHz >= 10.100 && freqMHz <= 10.150) return '30';
    if (freqMHz >= 14.000 && freqMHz <= 14.350) return '20';
    if (freqMHz >= 18.068 && freqMHz <= 18.168) return '17';
    if (freqMHz >= 21.000 && freqMHz <= 21.450) return '15';
    if (freqMHz >= 24.890 && freqMHz <= 24.990) return '12';
    if (freqMHz >= 28.000 && freqMHz <= 29.700) return '10';
    if (freqMHz >= 50.000 && freqMHz <= 54.000) return '6';
    return null; 
	// Out of amateur bands
}


       
			
			selectVFO(vfo) {
    this.currentVFO = vfo;
    this.updateVFOButtons();
    this.logCAT(`VFO ${vfo} selected`, 'info');
}

            updateConnectionStatus() {
                const btn = document.getElementById('connectBtn');
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const baudDropdown = document.getElementById('baudRate');
                if (this.connected) {
                    btn.textContent = 'Disconnect';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    statusDot.classList.add('connected');
                    statusText.textContent = 'CONNECTED';
                    statusText.className = 'status-text connected';
                    baudDropdown.disabled = true;
                } else {
                    btn.textContent = 'Connect Serial';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'DISCONNECTED';
                    statusText.className = 'status-text disconnected';
                    baudDropdown.disabled = false;
                }
            }

            updateTXStatus() {
                const txBtn = document.getElementById('txBtn');
                const rxBtn = document.getElementById('rxBtn');
                if (this.transmitting) {
                    txBtn.classList.remove('btn-secondary');
                    txBtn.classList.add('btn-danger');
                    rxBtn.classList.remove('btn-primary');
                    rxBtn.classList.add('btn-secondary');
                } else {
                    txBtn.classList.remove('btn-danger');
                    txBtn.classList.add('btn-secondary');
                    rxBtn.classList.remove('btn-secondary');
                    rxBtn.classList.add('btn-primary');
                }
            }

            updateModeFromCAT(catMode) {
                const modeMap = {
                    '1': 'LSB', '2': 'USB', '3': 'CW',
                    '7': 'CW', '6': 'DIGI'
                };
                if (modeMap[catMode]) {
                    this.mode = modeMap[catMode];
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.mode === this.mode) {
                            btn.classList.add('active');
                        }
                    });
                } else {
                    this.logCAT(`Unknown mode code received: ${catMode}`, 'error');
                }
            }

           updateSMeter(percentage) {
    const meter = document.getElementById('sMeter');
    percentage = Math.max(0, Math.min(100, percentage));
    meter.style.width = percentage + '%';
    
    // Optional: Show actual S-meter reading
    const sMeterLabel = document.getElementById('sMeterLabel');
    if (sMeterLabel) {
        const sUnits = Math.floor((percentage / 100) * 9);
        sMeterLabel.textContent = `S${sUnits}`;
    }
}

updateSWRMeter(percentage) {
    const meter = document.getElementById('swrMeter');
    percentage = Math.max(0, Math.min(100, percentage));
    meter.style.width = percentage + '%';
    
    // Update SWR text display
    const swrText = document.getElementById('swrText');
    if (swrText) {
        if (percentage === 0) {
            swrText.textContent = 'RX Mode';
        } else {
            const swr = 1.0 + (percentage / 100) * 2.0;
            swrText.textContent = `${swr.toFixed(2)}:1`;
        }
    }
}

          updateLcdDisplay(row1, row2) {
    const lcdRow1El = document.getElementById('lcdRow1');
    const lcdRow2El = document.getElementById('lcdRow2');
    
    if (lcdRow1El) {
        lcdRow1El.textContent = row1;
    }
    if (lcdRow2El) {
        lcdRow2El.textContent = row2;
    }
    
    // Auto-detect VFO from LCD display
    // If the first character is 'B', we're on VFO B, otherwise VFO A
    const detectedVFO = (row1 && row1.charAt(0) === 'B') ? 'B' : 'A';
    
    if (detectedVFO !== this.currentVFO) {
        this.currentVFO = detectedVFO;
        this.updateVFOButtons();
        this.logCAT(`VFO switched to ${this.currentVFO} (auto-detected)`, 'info');
    }
}

         updateDisplay() {
    this.updateBandFromFrequency();
    this.updateLoggerInfoBar();
}

            updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('currentTime').textContent = timeString;
                setTimeout(() => this.updateClock(), 1000);
            }

            async initTimeSync() {
                try {
                    this.logCAT('Initializing time synchronization...', 'info');
                    
                    await this.syncTimeFromServer();
                    
                    this.clockUpdateInterval = setInterval(() => {
                        this.updateSyncedClock();
                        this.updateLoggerInfoBar();
                    }, 1000);
                    
                    this.timeSyncInterval = setInterval(() => {
                        this.syncTimeFromServer();
                    }, 10 * 60 * 1000);
                    
                    console.log('Time synchronization initialized');
                } catch (error) {
                    console.error('Error initializing time sync:', error);
                    this.logCAT(`Time sync init error: ${error.message}`, 'error');
                    this.updateLocalClock();
                }
            }

            async syncTimeFromServer() {
                try {
                    this.logCAT('Synchronizing with time server...', 'info');
                    
                    const timeAPIs = [
                        'https://worldtimeapi.org/api/timezone/Etc/UTC',
                        'https://timeapi.io/api/Time/current/zone?timeZone=UTC',
                        'http://worldclockapi.com/api/json/utc/now'
                    ];
                    
                    let syncSuccessful = false;
                    
                    for (const api of timeAPIs) {
                        try {
                            const response = await fetch(api, {
                                method: 'GET', cache: 'no-cache', headers: { 'Accept': 'application/json' }
                            });
                            
                            if (!response.ok) continue;
                            
                            const data = await response.json();
                            let serverTime;
                            
                            if (data.datetime) serverTime = new Date(data.datetime);
                            else if (data.dateTime) serverTime = new Date(data.dateTime);
                            else if (data.currentDateTime) serverTime = new Date(data.currentDateTime);
                            else continue;
                            
                            const localTime = new Date();
                            this.localTimeOffset = serverTime.getTime() - localTime.getTime();
                            this.lastSyncTime = localTime.getTime();
                            
                            this.logCAT(`Time synced successfully (offset: ${this.localTimeOffset}ms)`, 'info');
                            syncSuccessful = true;
                            
                            this.sendTimeToQMX();
                            break;
                            
                        } catch (apiError) {
                            console.warn(`Time API ${api} failed:`, apiError);
                            continue;
                        }
                    }
                    
                    if (!syncSuccessful) throw new Error('All time APIs failed');
                    
                } catch (error) {
                    console.error('Time sync failed:', error);
                    this.logCAT(`Time sync failed: ${error.message}`, 'error');
                    this.localTimeOffset = 0;
                }
            }

            getSyncedTime() {
                const now = new Date();
                return new Date(now.getTime() + (this.localTimeOffset || 0));
            }

            updateSyncedClock() {
                const syncedUTC = this.getSyncedTime();
                const localTime = new Date(syncedUTC.getTime() - (syncedUTC.getTimezoneOffset() * 60000));
                
                const timeString = localTime.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    const syncAge = this.lastSyncTime ? Date.now() - this.lastSyncTime : Infinity;
                    const syncIndicator = syncAge > 11 * 60 * 1000 ? ' (SYNC?)' : ' (SYNC)';
                    timeElement.textContent = timeString + (this.lastSyncTime ? syncIndicator : ' (LOCAL)');
                }
            }

          // 1. Function to update band selection based on frequency
updateBandFromFrequency() {
    const freqMHz = this.frequency / 1000000;
    const detectedBand = this.getBandFromFrequency(freqMHz);
    
    if (detectedBand && detectedBand !== this.band) {
        this.band = detectedBand;
        this.updateBandButtons();
        this.logCAT(`Auto-selected ${this.band}m band for ${freqMHz.toFixed(3)} MHz`, 'info');
    }
}

// 2. Function to update band button highlighting
updateBandButtons() {
    document.querySelectorAll('.band-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.band === this.band) {
            btn.classList.add('active');
        }
    });
} 



updateVFOButtons() {
    document.querySelectorAll('#vfoA, #vfoB').forEach(btn => {
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-secondary');
    });
    
    const activeButton = document.getElementById(`vfo${this.currentVFO}`);
    if (activeButton) {
        activeButton.classList.remove('btn-secondary');
        activeButton.classList.add('btn-primary');
    }
}

// 3. Helper function to get the correct VFO command
getVFOCommand() {
    return this.currentVFO === 'B' ? 'FB' : 'FA';
}

















		   updateLocalClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    timeElement.textContent = timeString + ' (LOCAL)';
                }
                
                setTimeout(() => this.updateLocalClock(), 1000);
            }

            sendTimeToQMX() {
                if (this.timeCommandTimeout) clearTimeout(this.timeCommandTimeout);
                
                this.timeCommandTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const syncedUTC = this.getSyncedTime();
                        const localTime = new Date(syncedUTC.getTime() - (syncedUTC.getTimezoneOffset() * 60000));
                        
                        const hours = localTime.getHours().toString().padStart(2, '0');
                        const minutes = localTime.getMinutes().toString().padStart(2, '0');
                        const seconds = localTime.getSeconds().toString().padStart(2, '0');
                        const timeCommand = `TM${hours}${minutes}${seconds}`;
                        
                        this.sendCommand(timeCommand).then(() => {
                            this.logCAT(`Local time sent to QMX: ${hours}:${minutes}:${seconds}`, 'info');
                        }).catch(e => {
                            console.error("Time command error:", e);
                        });
                    }
                    this.timeCommandTimeout = null;
                }, 100);
            }



updateBandForOutOfBand() {
    const freqMHz = this.frequency / 1000000;
    const detectedBand = this.getBandFromFrequency(freqMHz);
    
    if (!detectedBand) {
        // Clear all band selections for out-of-band frequencies
        document.querySelectorAll('.band-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        this.band = null; // or keep the last valid band
        this.logCAT(`Frequency ${freqMHz.toFixed(3)} MHz is outside amateur bands`, 'info');
    }
}


// NEW: Enable keyboard control when hovering over tuning knob
enableTuningHoverKeys() {
    this.isHoveringTuningKnob = true;
    
    if (!this.boundHandleTuningHoverKeys) {
        this.boundHandleTuningHoverKeys = this.handleTuningHoverKeys.bind(this);
    }
    
    document.addEventListener('keydown', this.boundHandleTuningHoverKeys);
    
    // Visual feedback - make the knob glow when hover-keyboard-active
    const tuningKnob = document.getElementById('tuningKnob');
    tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 255, 136, 0.6)';
}

// NEW: Disable keyboard control when not hovering over tuning knob
disableTuningHoverKeys() {
    this.isHoveringTuningKnob = false;
    
    if (this.boundHandleTuningHoverKeys) {
        document.removeEventListener('keydown', this.boundHandleTuningHoverKeys);
    }
    
    // Remove visual feedback
    const tuningKnob = document.getElementById('tuningKnob');
    tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3)';
}

// NEW: Handle keyboard input when hovering over tuning knob
handleTuningHoverKeys(e) {
    if (!this.isHoveringTuningKnob) return;
    
    // Only handle arrow keys
    if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
    
    e.preventDefault();
    
    let direction = 0;
    if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        direction = -1;
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        direction = 1;
    }
    
    if (direction !== 0) {
        // Use the selected step size
        const freqDelta = direction * this.stepSize;
        this.updateFrequency(freqDelta);
        
        // Update knob rotation for visual feedback
        const rotationDelta = direction * 2;
        this.tuningKnobRotation += rotationDelta;
        document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
        
        // Send frequency update
        this.sendFrequencyDynamically();
        
        // Brief visual feedback
        this.provideTuningKeyFeedback();
    }
}

// NEW: Provide brief visual feedback for keyboard tuning
provideTuningKeyFeedback() {
    const tuningKnob = document.getElementById('tuningKnob');
    const originalBoxShadow = tuningKnob.style.boxShadow;
    
    // Brief bright glow
    tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 30px rgba(0, 255, 136, 1)';
    
    setTimeout(() => {
        if (this.isHoveringTuningKnob) {
            // Return to hover glow
            tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 255, 136, 0.6)';
        } else {
            // Return to normal
            tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3)';
        }
    }, 150);
}




// ADD these new methods to your QMXInterface class:

updateTuningSpeed(speed) {
    // Keep track of recent speed samples (last 500ms worth)
    const now = performance.now();
    this.tuningSpeedSamples.push({ speed: speed, time: now });
    
    // Remove old samples (older than 500ms)
    this.tuningSpeedSamples = this.tuningSpeedSamples.filter(sample => 
        now - sample.time < 500
    );
    
    // Calculate average speed
    if (this.tuningSpeedSamples.length > 0) {
        const avgSpeed = this.tuningSpeedSamples.reduce((sum, sample) => 
            sum + sample.speed, 0) / this.tuningSpeedSamples.length;
        
        // Threshold for "fast" tuning (adjust these values as needed)
        const fastThreshold = 2.0;  // radians/second for rotary, or scaled for wheel
        
        if (avgSpeed > fastThreshold && !this.isVariableStepActive) {
            this.activateVariableStep();
        }
    }
    
    // Reset the timeout to revert to normal speed
    this.resetVariableStepTimeout();
}

activateVariableStep() {
    if (!this.isVariableStepActive) {
        this.originalStepSize = this.stepSize;
        this.stepSize = this.originalStepSize * this.fastStepMultiplier;
        this.isVariableStepActive = true;
        
        // Visual feedback
        const stepDisplay = document.getElementById('stepSize');
        if (stepDisplay) {
            stepDisplay.style.background = 'rgba(255, 149, 0, 0.3)';
            stepDisplay.style.borderColor = '#ff9500';
        }
        
        this.logCAT(`Fast tuning activated: ${this.stepSize} Hz step`, 'info');
    }
}

deactivateVariableStep() {
    if (this.isVariableStepActive) {
        this.stepSize = this.originalStepSize;
        this.isVariableStepActive = false;
        
        // Remove visual feedback
        const stepDisplay = document.getElementById('stepSize');
        if (stepDisplay) {
            stepDisplay.style.background = '';
            stepDisplay.style.borderColor = '';
        }
        
        this.logCAT(`Normal tuning restored: ${this.stepSize} Hz step`, 'info');
    }
}

getCurrentStepSize() {
    return this.isVariableStepActive ? this.stepSize : this.originalStepSize;
}

resetVariableStepTimeout() {
    if (this.variableStepTimeout) {
        clearTimeout(this.variableStepTimeout);
    }
    
    // Revert to normal step after 1 second of slow/no tuning
    this.variableStepTimeout = setTimeout(() => {
        this.deactivateVariableStep();
        this.tuningSpeedSamples = []; // Clear speed history
    }, 1000);
}

// This is the updated code
initKeyerToggle() {
    try {
        const keyerToggle = document.getElementById('keyerModeToggle');
        const keyerKnobContainer = document.querySelector('.knob-group:has(#rfGainKnob)');
        
        // Set initial state to BUG mode
        this.setKeyerMode('bug'); // âœ… Changed from 'straight' to 'bug'
        
        // Add click event listener
        keyerToggle.addEventListener('click', () => {
            this.toggleKeyerMode();
        });
        
        console.log('Keyer mode toggle initialized');
    } catch (error) {
        console.error('Error initializing keyer toggle:', error);
    }
}


// ADD this method to toggle between modes:
toggleKeyerMode() {
    if (this.keyerMode === 'straight') {
        this.setKeyerMode('bug');
    } else {
        this.setKeyerMode('straight');
    }
}


// ADD this method to set the keyer mode:
setKeyerMode(mode) {
    const keyerToggle = document.getElementById('keyerModeToggle');
    const keyerKnobContainer = document.querySelector('.knob-group:has(#rfGainKnob)');
    
    this.keyerMode = mode;
    
    if (mode === 'straight') {
        // Set to STRAIGHT mode (0 WPM)
        keyerToggle.classList.remove('bug');
        if (keyerKnobContainer) {
            keyerKnobContainer.classList.add('keyer-straight');
        }
        
        // Set keyer speed to 0 (STRAIGHT)
        this.rfGainLevel = 0;
        this.rfGainKnobRotation = this.minRotation;
        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        this.updateRFGainLevel();
        
        this.logCAT('Keyer mode: STRAIGHT KEY', 'info');
        
    } else if (mode === 'bug') {
        // Set to BUG mode (22 WPM)
        keyerToggle.classList.add('bug');
        if (keyerKnobContainer) {
            keyerKnobContainer.classList.remove('keyer-straight');
        }
        
        // Set keyer speed to 22 WPM
        this.rfGainLevel = (this.bugWpmSetting / 50) * 100;  // Convert 22 WPM to percentage
        this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        this.updateRFGainLevel();
        
        this.logCAT(`Keyer mode: BUG (${this.bugWpmSetting} WPM)`, 'info');
    }
    
    // Send the command to the radio
    this.sendRFGainCommand();
 }
 
 


 



            // --- Frequency & Layout Management ---
            loadLastFrequencies() {
                const savedFrequencies = localStorage.getItem('qmxLastFrequencies');
                if (savedFrequencies) {
                    try {
                        const parsedFrequencies = JSON.parse(savedFrequencies);
                        // Merge saved frequencies with defaults to ensure all bands are covered
                        this.lastFrequencies = { ...this.lastFrequencies, ...parsedFrequencies };
                        console.log('Loaded last-used frequencies.');
                    } catch(e) {
                        console.error('Could not parse saved frequencies, using defaults.');
                    }
                }
            }
            
            saveLastFrequency() {
                if (this.saveFreqTimeout) {
                    clearTimeout(this.saveFreqTimeout);
                }
                this.saveFreqTimeout = setTimeout(() => {
                    this.lastFrequencies[this.band] = this.frequency;
                    localStorage.setItem('qmxLastFrequencies', JSON.stringify(this.lastFrequencies));
                }, 1000); // Save 1 second after tuning stops
            }
            
           
           


//---------------------------------------------------------------------------

// REPLACE the existing initDraggablePanels method with this:
initDraggablePanels() {
    try {
        const leftPanel = document.querySelector('.left-panel');
        const centerPanel = document.querySelector('.center-panel');
        const rightPanel = document.querySelector('.right-panel');

        const options = {
            group: 'shared-panels',
            handle: 'h3',
            animation: 150,
            ghostClass: 'sortable-ghost',
            dragClass: 'sortable-drag',
            disabled: this.panelsLocked,
            onEnd: () => {
                this.saveLayout();
            }
        };

        this.sortableInstances = [
            Sortable.create(leftPanel, options),
            Sortable.create(centerPanel, options),
            Sortable.create(rightPanel, options)
        ];
        
        console.log('Draggable panels initialized');
    } catch(e) {
        console.warn("Could not initialize draggable panels. Is Sortable.js loaded?");
        this.sortableInstances = [];
    }
}


// ADD these new methods:
initPanelLockToggle() {
    try {
        console.log('Initializing panel lock toggle...');
        
        const toggleBtn = document.getElementById('panelLockToggle');
        if (!toggleBtn) {
            console.error('Panel lock toggle button not found! Check HTML structure.');
            return;
        }

        console.log('Panel lock toggle button found');
        this.updatePanelLockUI();

        toggleBtn.addEventListener('click', () => {
            console.log('Panel lock toggle clicked!');
            this.togglePanelLock();
        });

        console.log('Panel lock toggle initialized successfully');
    } catch (error) {
        console.error('Error initializing panel lock toggle:', error);
    }
}

togglePanelLock() {
    this.panelsLocked = !this.panelsLocked;
    
    if (this.sortableInstances && this.sortableInstances.length > 0) {
        this.sortableInstances.forEach(sortable => {
            if (sortable) {
                sortable.option('disabled', this.panelsLocked);
            }
        });
    }
    
    this.updatePanelLockUI();
    
    const status = this.panelsLocked ? 'LOCKED' : 'UNLOCKED';
    this.logCAT(`Panel positions ${status}`, 'info');
    console.log(`Panel dragging ${status}`);
}

updatePanelLockUI() {
    const toggleBtn = document.getElementById('panelLockToggle');
    const lockIcon = document.getElementById('lockIcon');
    const lockText = document.getElementById('lockText');
    
    if (!toggleBtn || !lockIcon || !lockText) {
        console.error('Panel lock UI elements missing');
        return;
    }
    
    toggleBtn.classList.remove('locked', 'unlocked');
    document.body.classList.remove('panels-locked');
    
    if (this.panelsLocked) {
        toggleBtn.classList.add('locked');
        lockIcon.textContent = 'ðŸ”’';
        lockText.textContent = 'Panels Locked';
        toggleBtn.title = 'Click to unlock panel dragging';
        document.body.classList.add('panels-locked');
    } else {
        toggleBtn.classList.add('unlocked');
        lockIcon.textContent = 'ðŸ”“';
        lockText.textContent = 'Panels Unlocked';
        toggleBtn.title = 'Click to lock panels in place';
    }
}
//-------------------------------------------------------------------------




















		   saveLayout() {
                const layout = {
                    left: [...document.querySelectorAll('.left-panel .panel')].map(p => p.id),
                    center: [...document.querySelectorAll('.center-panel .panel')].map(p => p.id),
                    right: [...document.querySelectorAll('.right-panel .panel')].map(p => p.id)
                };
                localStorage.setItem('qmxPanelLayout', JSON.stringify(layout));
                this.logCAT('Panel layout saved.', 'info');
            }

            loadLayout() {
                const savedLayout = localStorage.getItem('qmxPanelLayout');
                if (savedLayout) {
                    try {
                        const layout = JSON.parse(savedLayout);
                        const columns = {
                            left: document.querySelector('.left-panel'),
                            center: document.querySelector('.center-panel'),
                            right: document.querySelector('.right-panel')
                        };

                        Object.keys(layout).forEach(columnKey => {
                            layout[columnKey].forEach(panelId => {
                                const panelElement = document.getElementById(panelId);
                                if (panelElement && columns[columnKey]) {
                                    columns[columnKey].appendChild(panelElement);
                                }
                            });
                        });
                        console.log('Custom panel layout loaded.');
                    } catch (e) {
                        console.error("Failed to load custom layout, using default.", e);
                        localStorage.removeItem('qmxPanelLayout');
                    }
                }
            }
            
            // --- The rest of the methods ---

            // --- QSO Logger ---
            initQsoLogger() {
                try {
                    document.getElementById('logQsoBtn').addEventListener('click', () => this.logQso());
                    document.getElementById('clearQsoInputsBtn').addEventListener('click', () => this.clearQsoInputs());
                    document.getElementById('exportAdifBtn').addEventListener('click', () => this.exportAdif());
                    document.getElementById('importAdifBtn').addEventListener('click', () => document.getElementById('importAdifFile').click());
                    document.getElementById('importAdifFile').addEventListener('change', (e) => this.importAdif(e));
                    document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLog());
                    document.getElementById('qsoSearch').addEventListener('input', (e) => {
                        this.qsoLogFilter = e.target.value;
                        this.renderQsoLog();
                    });
                    document.getElementById('qsoCallsign').addEventListener('keyup', (e) => {
                         e.target.value = e.target.value.toUpperCase();
                         if (e.key === 'Enter') {
                             this.logQso();
                         }
                    });

                    this.loadQsoLog();
                    console.log('QSO Logger initialized');
                } catch (error) {
                    console.error('Failed to initialize QSO Logger:', error);
                }
            }

            updateLoggerInfoBar() {
                try {
                    const infoBar = document.getElementById('qsoInfoBar');
                    if (!infoBar) return;
                    
                    const freqMHz = (this.frequency / 1000000).toFixed(3);
                    const mode = this.mode;
                    const band = this.band + 'm';
                    
                    const syncedUTC = this.getSyncedTime();
                    const dateStr = syncedUTC.toISOString().slice(0, 10);
                    const timeStr = syncedUTC.toISOString().slice(11, 19);

                    infoBar.innerHTML = `
                        <span>${freqMHz} MHz</span> &bull; 
                        <span>${mode}</span> &bull; 
                        <span>${band}</span>
                        <span style="float: right;">${dateStr} ${timeStr} UTC</span>
                    `;
                } catch (error) {
                    // Fail silently if elements are not ready
                }
            }

            loadQsoLog() {
                const savedLog = localStorage.getItem('qmxQsoLog');
                if (savedLog) {
                    this.qsoLog = JSON.parse(savedLog);
                }
                this.renderQsoLog();
            }

            saveQsoLog() {
                localStorage.setItem('qmxQsoLog', JSON.stringify(this.qsoLog));
            }

            logQso() {
                const callsign = document.getElementById('qsoCallsign').value.trim().toUpperCase();
                if (!callsign) {
                    alert('Callsign is required.');
                    document.getElementById('qsoCallsign').focus();
                    return;
                }

                const qso = {
                    id: Date.now(),
                    call: callsign,
                    rstSent: document.getElementById('qsoRstSent').value.trim(),
                    rstRcvd: document.getElementById('qsoRstRcvd').value.trim(),
                    name: document.getElementById('qsoName').value.trim(),
                    qth: document.getElementById('qsoQth').value.trim(),
                    comments: document.getElementById('qsoComments').value.trim(),
                    freq: (this.frequency / 1000000).toFixed(6),
                    mode: this.mode,
                    band: this.band + 'm',
                    time: this.getSyncedTime().toISOString()
                };
                
                this.qsoLog.unshift(qso);
                this.saveQsoLog();
                this.renderQsoLog();
                this.clearQsoInputs(false);
            }

            clearQsoInputs(clearAll = true) {
                document.getElementById('qsoCallsign').value = '';
                document.getElementById('qsoName').value = '';
                document.getElementById('qsoQth').value = '';
                document.getElementById('qsoComments').value = '';
                if(clearAll) {
                   document.getElementById('qsoRstSent').value = '599';
                   document.getElementById('qsoRstRcvd').value = '599';
                }
                document.getElementById('qsoCallsign').focus();
            }

            clearLog() {
                if (confirm(`Are you sure you want to delete all ${this.qsoLog.length} logged QSOs? This cannot be undone.`)) {
                    this.qsoLog = [];
                    this.saveQsoLog();
                    this.renderQsoLog();
                    this.logCAT('QSO Log cleared.', 'info');
                }
            }

            renderQsoLog() {
                const logBody = document.getElementById('qsoLogBody');
                const qsoCount = document.getElementById('qsoCount');
                
                logBody.innerHTML = '';
                
                const filteredLog = this.qsoLog.filter(qso => 
                    qso.call.toUpperCase().includes(this.qsoLogFilter.toUpperCase())
                );

                if (filteredLog.length === 0) {
                    logBody.innerHTML = `<div class="log-empty-msg">${this.qsoLog.length > 0 ? 'No matching QSOs' : 'No QSOs logged yet'}</div>`;
                } else {
                    filteredLog.forEach(qso => {
                        const row = document.createElement('div');
                        row.className = 'log-row';
                        
                        const time = new Date(qso.time);
                        const timeStr = `${time.getUTCHours().toString().padStart(2, '0')}:${time.getUTCMinutes().toString().padStart(2, '0')}`;
                        const freqStr = parseFloat(qso.freq).toFixed(3);

                        row.innerHTML = `
                            <div>${timeStr}</div>
                            <div>${qso.call}</div>
                            <div>${freqStr}</div>
                            <div>${qso.mode}</div>
                            <div>${qso.rstRcvd}</div>
                        `;
                        row.title = `Date: ${time.toISOString().slice(0,10)}\nName: ${qso.name}\nQTH: ${qso.qth}\nComments: ${qso.comments}`;
                        logBody.appendChild(row);
                    });
                }
                
                qsoCount.textContent = this.qsoLog.length;
            }

            exportAdif() {
                if (this.qsoLog.length === 0) {
                    alert('Log is empty. Nothing to export.');
                    return;
                }

                let adifContent = "Generated by QMX+ Professional QRP Communications Interface\n<EOH>\n\n";

                this.qsoLog.slice().reverse().forEach(qso => {
                    const time = new Date(qso.time);
                    const qsoDate = time.toISOString().slice(0, 10).replace(/-/g, '');
                    const timeOn = time.toISOString().slice(11, 19).replace(/:/g, '');

                    let record = '';
                    const addField = (name, value) => {
                        if (value) {
                            const val = String(value);
                            record += `<${name}:${val.length}>${val} `;
                        }
                    };

                    addField('CALL', qso.call);
                    addField('QSO_DATE', qsoDate);
                    addField('TIME_ON', timeOn);
                    addField('BAND', qso.band.toUpperCase());
                    addField('FREQ', qso.freq);
                    addField('MODE', qso.mode);
                    addField('RST_SENT', qso.rstSent);
                    addField('RST_RCVD', qso.rstRcvd);
                    addField('NAME', qso.name);
                    addField('QTH', qso.qth);
                    addField('COMMENT', qso.comments);
                    
                    adifContent += record.trim() + '<EOR>\n';
                });

                const blob = new Blob([adifContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qmx_log_${new Date().toISOString().slice(0, 10)}.adi`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('QSO log exported to ADIF.', 'info');
            }

            importAdif(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        const newQsos = this.parseAdif(content);
                        if (newQsos.length === 0) {
                            alert('No valid QSO records found in the file.');
                            return;
                        }

                        if (confirm(`Found ${newQsos.length} QSOs. Do you want to add them to your log?`)) {
                            const existingKeys = new Set(this.qsoLog.map(q => `${q.call}-${q.time.slice(0,16)}`));
                            const addedQsos = [];
                            newQsos.reverse().forEach(qso => {
                                const key = `${qso.call}-${qso.time.slice(0,16)}`;
                                if (!existingKeys.has(key)) {
                                    this.qsoLog.unshift(qso);
                                    addedQsos.push(qso);
                                }
                            });
                            
                            this.qsoLog.sort((a, b) => new Date(b.time) - new Date(a.time));
                            this.saveQsoLog();
                            this.renderQsoLog();
                            alert(`Successfully imported ${addedQsos.length} new QSOs.`);
                            this.logCAT(`Imported ${addedQsos.length} QSOs from ADIF file.`, 'info');
                        }
                    } catch (error) {
                        alert('Failed to parse ADIF file. Error: ' + error.message);
                        console.error('ADIF Parse Error:', error);
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file);
            }

            parseAdif(adifContent) {
                const qsos = [];
                const records = adifContent.toUpperCase().split(/<EOR>/i);

                for (const record of records) {
                    if (!record.includes('<CALL')) continue;

                    let qso = { id: Date.now() + Math.random() };
                    const fields = record.match(/<[A-Z0-9_]+:\d+>[\s\S]*?(?=\s*<|$)/g) || [];

                    for (const field of fields) {
                        const match = field.match(/<([A-Z0-9_]+):\d+>([\s\S]*)/);
                        if (match) {
                            const [, key, value] = match;
                            qso[key] = value.trim();
                        }
                    }
                    
                    if (qso.CALL && qso.QSO_DATE && qso.TIME_ON) {
                        const date = `${qso.QSO_DATE.slice(0,4)}-${qso.QSO_DATE.slice(4,6)}-${qso.QSO_DATE.slice(6,8)}`;
                        const time = `${qso.TIME_ON.slice(0,2)}:${qso.TIME_ON.slice(2,4)}:${qso.TIME_ON.slice(4,6)}`;
                        const fullIsoTime = new Date(`${date}T${time}Z`).toISOString();

                        qsos.push({
                            id: qso.id,
                            call: qso.CALL || '',
                            rstSent: qso.RST_SENT || '',
                            rstRcvd: qso.RST_RCVD || '',
                            name: qso.NAME || '',
                            qth: qso.QTH || '',
                            comments: qso.COMMENT || '',
                            freq: qso.FREQ || '',
                            mode: qso.MODE || '',
                            band: qso.BAND ? (qso.BAND.endsWith('M') ? qso.BAND : qso.BAND + 'M') : '',
                            time: fullIsoTime,
                        });
                    }
                }
                return qsos;
            }

            initVolumeControl() {
                try {
                    const volumeKnob = document.getElementById('volumeKnob');
                    this.updateVolumeUI();
                    volumeKnob.addEventListener('mousedown', this.startVolumeAdjust.bind(this));
                    volumeKnob.addEventListener('touchstart', this.startVolumeAdjust.bind(this), { passive: false });
                    volumeKnob.addEventListener('wheel', this.handleVolumeWheel.bind(this));
                    volumeKnob.addEventListener('keydown', this.handleVolumeKeyboard.bind(this));
                    console.log('Volume control initialized');
                } catch (error) {
                    console.error('Error initializing volume control:', error);
                }
            }

            startVolumeAdjust(e) {
                e.preventDefault();
                this.isVolumeAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueVolumeAdjust = this.continueVolumeAdjust.bind(this);
                this.boundStopVolumeAdjust = this.stopVolumeAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.volumeLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.addEventListener('mouseup', this.boundStopVolumeAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.volumeLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueVolumeAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopVolumeAdjust);
                }
            }

            continueVolumeAdjust(e) {
                if (!this.isVolumeAdjusting) return;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    const volumeKnob = document.getElementById('volumeKnob');
                    const rect = volumeKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.volumeLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 1.2;
                    deltaAngle *= sensitivity;
                    const newRotation = this.volumeKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.volumeKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    volumeKnob.style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                    const newVolumeLevel = Math.round(((this.volumeKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newVolumeLevel !== this.volumeLevel) {
                        this.volumeLevel = newVolumeLevel;
                        this.updateVolumeUI();
                        this.sendVolumeDynamically();
                    }
                    this.volumeLastAngle = currentAngle;
                    this.volumeAnimationFrame = null;
                });
            }

            stopVolumeAdjust() {
                this.isVolumeAdjusting = false;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                    this.volumeAnimationFrame = null;
                }
                if (this.boundContinueVolumeAdjust && this.boundStopVolumeAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('mouseup', this.boundStopVolumeAdjust);
                    document.removeEventListener('touchmove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('touchend', this.boundStopVolumeAdjust);
                    this.boundContinueVolumeAdjust = null;
                    this.boundStopVolumeAdjust = null;
                }
                this.sendVolumeCommand();
            }

            handleVolumeKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustVolume(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustVolume(5);
                }
            }

            handleVolumeWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const volumeDelta = steps * 5;
                this.adjustVolume(volumeDelta);
            }

            adjustVolume(delta) {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel + delta));
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    this.updateVolumeUI();
                    this.sendVolumeCommand();
                    this.volumeAnimationFrame = null;
                });
            }
			
            updateVolumeUI() {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel));
                this.volumeKnobRotation = this.minRotation + (this.volumeLevel / 100) * this.totalRotationRange;
                document.getElementById('volumeKnob').style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                document.getElementById('volumeLevel').textContent = `${this.volumeLevel}db`;
                document.getElementById('volumeKnob').setAttribute('aria-valuenow', this.volumeLevel);
            }

            sendVolumeDynamically() {
                if (this.volumeTimeout) {
                    clearTimeout(this.volumeTimeout);
                }
                this.volumeTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const scaledVolume = this.volumeToCAT(this.volumeLevel);
                        
                        this.sendCommand(`AG${scaledVolume.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Volume update error:", e);
                        });
                    }
                    this.volumeTimeout = null;
                }, 50);
            }

            async sendVolumeCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const scaledVolume = this.volumeToCAT(this.volumeLevel);
                    await this.sendCommand(`AG${scaledVolume.toString().padStart(3, '0')}`);
                    this.logCAT(`Volume set to ${this.volumeLevel}%`, 'info');
                } catch (e) {
                    this.logCAT(`Volume command error: ${e.message}`, 'error');
                }
            }

            volumeToCAT(volumePercent) {
                if (volumePercent <= 0) return 0;
                if (volumePercent >= 100) return 255;
                
                const normalizedInput = volumePercent / 100;
                const logScaled = (Math.pow(10, normalizedInput * 2) - 1) / 99;
                return Math.round(logScaled * 255);
            }

            catToVolume(catValue) {
                if (catValue <= 0) return 0;
                if (catValue >= 255) return 100;
                
                const normalized = catValue / 255;
                const linearValue = (normalized * 99 + 1);
                const volumePercent = (Math.log10(linearValue) / 2) * 100;
                return Math.round(Math.max(0, Math.min(100, volumePercent)));
            }

    // Add this line at the end of initRFGainControl():
initRFGainControl() {
    try {
        const rfGainKnob = document.getElementById('rfGainKnob');
        const rfGainLevel = document.getElementById('rfGainLevel');
        this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
        rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        
        this.updateRFGainLevel();
        
        rfGainKnob.addEventListener('mousedown', this.startRFGainAdjust.bind(this));
        rfGainKnob.addEventListener('touchstart', this.startRFGainAdjust.bind(this), { passive: false });
        rfGainKnob.addEventListener('wheel', this.handleRFGainWheel.bind(this));
        rfGainKnob.addEventListener('keydown', this.handleRFGainKeyboard.bind(this));
        rfGainKnob.setAttribute('aria-valuenow', this.rfGainLevel);
        
        // NEW: Initialize the keyer toggle
        this.setKeyerMode('');      
	   this.initKeyerToggle();
        
        console.log('Keyer initialized with toggle (0=STRAIGHT, 1-50 WPM)');
    } catch (error) {
        console.error('Error initializing Keyer:', error);
    }
}

            startRFGainAdjust(e) {
               
// Don't allow manual adjustment in STRAIGHT mode
    if (this.keyerMode === 'straight') {
        return;
    }
			   e.preventDefault();
                this.isRFGainAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueRFGainAdjust = this.continueRFGainAdjust.bind(this);
                this.boundStopRFGainAdjust = this.stopRFGainAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.rfGainLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueRFGainAdjust);
                    document.addEventListener('mouseup', this.boundStopRFGainAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.rfGainLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueRFGainAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopRFGainAdjust);
                }
            }

            continueRFGainAdjust(e) {
                if (!this.isRFGainAdjusting) return;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    const rfGainKnob = document.getElementById('rfGainKnob');
                    const rect = rfGainKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
                    if (distance < rect.width * 2) {
                        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                        let deltaAngle = currentAngle - this.rfGainLastAngle;
                        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                        const sensitivity = 0.7;
                        deltaAngle *= sensitivity;
                        const newRotation = this.rfGainKnobRotation + (deltaAngle * 180 / Math.PI);
                        this.rfGainKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                        rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                        const newRFGainLevel = Math.round(((this.rfGainKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                        if (newRFGainLevel !== this.rfGainLevel) {
                            this.rfGainLevel = newRFGainLevel;
                            this.updateRFGainLevel();
                            this.sendRFGainDynamically();
                        }
                        this.rfGainLastAngle = currentAngle;
                    }
                    this.rfGainAnimationFrame = null;
                });
            }

            stopRFGainAdjust() {
                this.isRFGainAdjusting = false;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                    this.rfGainAnimationFrame = null;
                }
                if (this.boundContinueRFGainAdjust && this.boundStopRFGainAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueRFGainAdjust);
                    document.removeEventListener('mouseup', this.boundStopRFGainAdjust);
                    document.removeEventListener('touchmove', this.boundContinueRFGainAdjust);
                    document.removeEventListener('touchend', this.boundStopRFGainAdjust);
                    this.boundContinueRFGainAdjust = null;
                    this.boundStopRFGainAdjust = null;
                }
                this.sendRFGainCommand();
            }

            handleRFGainKeyboard(e) {
// Don't allow manual adjustment in STRAIGHT mode
    if (this.keyerMode === 'straight') {
        return;
    }               
			   if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustRFGain(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustRFGain(5);
                }
            }

          handleRFGainWheel(e) {
 // Don't allow manual adjustment in STRAIGHT mode
    if (this.keyerMode === 'straight') {
        return;
    }   
   e.preventDefault();
    let steps = e.deltaY > 0 ? -1 : 1;
    const cwSpeedDelta = steps * 1;
    const currentCWSpeed = Math.round((this.rfGainLevel / 100) * 50);
    const newCWSpeed = Math.max(0, Math.min(50, currentCWSpeed + cwSpeedDelta));
    this.rfGainLevel = (newCWSpeed / 50) * 100;
    this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
    if (this.rfGainAnimationFrame) {
        cancelAnimationFrame(this.rfGainAnimationFrame);
    }
    this.rfGainAnimationFrame = requestAnimationFrame(() => {
        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        this.updateRFGainLevel();
        this.sendRFGainCommand();
        this.rfGainAnimationFrame = null;
    });
}

            adjustRFGain(delta) {
                this.rfGainLevel = Math.max(0, Math.min(100, this.rfGainLevel + delta));
                this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                    this.updateRFGainLevel();
                    this.sendRFGainCommand();
                    this.rfGainAnimationFrame = null;
                });
            }

 
// MODIFY your existing updateRFGainLevel method to show mode info:
updateRFGainLevel() {
    const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
    const rfGainLevelEl = document.getElementById('rfGainLevel');
    
    if (cwSpeed === 0) {
        rfGainLevelEl.textContent = 'STRAIGHT';
        rfGainLevelEl.style.color = '#ff4757';
    } else {
        rfGainLevelEl.textContent = `${cwSpeed} WPM`;
        rfGainLevelEl.style.color = '#00ff88';
    }
    document.getElementById('rfGainKnob').setAttribute('aria-valuenow', cwSpeed);
}

           sendRFGainDynamically() {
    if (this.rfGainTimeout) {
        clearTimeout(this.rfGainTimeout);
    }
    this.rfGainTimeout = setTimeout(() => {
        if (this.connected && this.port && this.writer) {
            const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
            this.sendCommand(`KS${cwSpeed.toString().padStart(3, '0')}`).catch(e => {
                console.error("CW Speed update error:", e);
            });
        }
        this.rfGainTimeout = null;
    }, 50);
}

           async sendRFGainCommand() {
    if (!this.connected || !this.port || !this.writer) return;
    try {
        const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
        await this.sendCommand(`KS${cwSpeed.toString().padStart(3, '0')}`);
        if (cwSpeed === 0) {
            this.logCAT(`Keyer set to STRAIGHT KEY mode`, 'info');
        } else {
            this.logCAT(`CW Speed set to ${cwSpeed} WPM`, 'info');
        }
    } catch (e) {
        this.logCAT(`CW Speed command error: ${e.message}`, 'error');
    }
}

            initPowerControl() {
                try {
                    const powerKnob = document.getElementById('powerKnob');
                    const powerLevel = document.getElementById('powerLevel');
                    this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    powerKnob.style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    powerLevel.textContent = `${(this.powerLevel / 10).toFixed(1)}W`;
                    powerKnob.addEventListener('mousedown', this.startPowerAdjust.bind(this));
                    powerKnob.addEventListener('touchstart', this.startPowerAdjust.bind(this), { passive: false });
                    powerKnob.addEventListener('wheel', this.handlePowerWheel.bind(this));
                    powerKnob.addEventListener('keydown', this.handlePowerKeyboard.bind(this));
                    powerKnob.setAttribute('aria-valuenow', this.powerLevel);
                    console.log('Power control initialized at', (this.powerLevel / 10).toFixed(1), 'W');
                } catch (error) {
                    console.error('Error initializing Power control:', error);
                }
            }

            startPowerAdjust(e) {
                e.preventDefault();
                this.isPowerAdjusting = true;
                this.powerLevelBeforeAdjust = this.powerLevel;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinuePowerAdjust = this.continuePowerAdjust.bind(this);
                this.boundStopPowerAdjust = this.stopPowerAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.powerLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinuePowerAdjust);
                    document.addEventListener('mouseup', this.boundStopPowerAdjust);
                    document.addEventListener('mouseleave', this.boundStopPowerAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.powerLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinuePowerAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopPowerAdjust);
                    document.addEventListener('touchcancel', this.boundStopPowerAdjust);
                }
            }

            continuePowerAdjust(e) {
                if (!this.isPowerAdjusting) return;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                }
                this.powerAnimationFrame = requestAnimationFrame(() => {
                    const powerKnob = document.getElementById('powerKnob');
                    const rect = powerKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.powerLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 0.7;
                    deltaAngle *= sensitivity;
                    const newRotation = this.powerKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.powerKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    powerKnob.style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    const normalizedRotation = (this.powerKnobRotation - this.minRotation) / this.totalRotationRange;
                    const newPowerLevel = Math.round(normalizedRotation * 50);
                    if (newPowerLevel !== this.powerLevel && newPowerLevel >= 0 && newPowerLevel <= 50) {
                        this.powerLevel = newPowerLevel;
                        this.updatePowerLevel();
                        this.sendPowerDynamically();
                    }
                    this.powerLastAngle = currentAngle;
                    this.powerAnimationFrame = null;
                });
            }

            stopPowerAdjust() {
                this.isPowerAdjusting = false;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                    this.powerAnimationFrame = null;
                }
                if (this.boundContinuePowerAdjust && this.boundStopPowerAdjust) {
                    document.removeEventListener('mousemove', this.boundContinuePowerAdjust);
                    document.removeEventListener('mouseup', this.boundStopPowerAdjust);
                    document.removeEventListener('mouseleave', this.boundStopPowerAdjust);
                    document.removeEventListener('touchmove', this.boundContinuePowerAdjust);
                    document.removeEventListener('touchend', this.boundStopPowerAdjust);
                    document.removeEventListener('touchcancel', this.boundStopPowerAdjust);
                    this.boundContinuePowerAdjust = null;
                    this.boundStopPowerAdjust = null;
                }
                if (this.powerLevel < 0 || this.powerLevel > 50 || isNaN(this.powerLevel)) {
                    this.powerLevel = this.powerLevelBeforeAdjust || 50;
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                }
                this.updatePowerLevel();
                this.sendPowerCommand();
            }

            handlePowerKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustPower(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustPower(5);
                }
            }

            handlePowerWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const powerDelta = steps * 5;
                this.adjustPower(powerDelta);
            }

            adjustPower(delta) {
                this.powerLevel = Math.max(0, Math.min(50, this.powerLevel + delta));
                this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                }
                this.powerAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    this.updatePowerLevel();
                    this.sendPowerCommand();
                    this.powerAnimationFrame = null;
                });
            }

            updatePowerLevel() {
                const previousLevel = this.powerLevel;
                this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                if (previousLevel > 0 && this.powerLevel === 0 && !this.isPowerAdjusting) {
                    console.warn('Power level unexpectedly dropped to 0 from', previousLevel);
                }
                const watts = (this.powerLevel / 10).toFixed(1);
                document.getElementById('powerLevel').textContent = `${watts}W`;
                document.getElementById('powerKnob').setAttribute('aria-valuenow', this.powerLevel);
            }

            sendPowerDynamically() {
                if (this.powerTimeout) {
                    clearTimeout(this.powerTimeout);
                }
                this.powerTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const validPowerLevel = Math.max(0, Math.min(50, this.powerLevel));
                        this.sendCommand(`PC${validPowerLevel.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Power update error:", e);
                        });
                    }
                    this.powerTimeout = null;
                }, 50);
            }

            async sendPowerCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                    await this.sendCommand(`PC${this.powerLevel.toString().padStart(3, '0')}`);
                    this.logCAT(`Power set to ${(this.powerLevel / 10).toFixed(1)}W`, 'info');
                } catch (e) {
                    this.logCAT(`Power command error: ${e.message}`, 'error');
                }
            }

           initTuningKnob() {
    try {
        const tuningKnob = document.getElementById('tuningKnob');
        this.createFrequencyMarkings();
        this.tuningKnobRotation = 0;
        tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
        
        // Existing event listeners
        tuningKnob.addEventListener('mousedown', this.startTuningAdjust.bind(this));
        tuningKnob.addEventListener('touchstart', this.startTuningAdjust.bind(this), { passive: false });
        tuningKnob.addEventListener('wheel', this.handleTuningWheel.bind(this));
        tuningKnob.addEventListener('keydown', this.handleTuningKeyboard.bind(this));
        
        // NEW: Add hover keyboard control
        tuningKnob.addEventListener('mouseenter', this.enableTuningHoverKeys.bind(this));
        tuningKnob.addEventListener('mouseleave', this.disableTuningHoverKeys.bind(this));
        
        tuningKnob.setAttribute('aria-valuenow', this.frequency);
        console.log('CSS tuning knob initialized with hover keyboard control');
    } catch (error) {
        console.error('Error initializing tuning knob:', error);
    }
}

            createFrequencyMarkings() {
                const markingsContainer = document.getElementById('frequencyMarkings');
                markingsContainer.innerHTML = '';
                for (let i = 0; i < 72; i++) {
                    const angle = (i / 72) * 360;
                    const isLarge = i % 6 === 0;
                    const mark = document.createElement('div');
                    mark.className = `frequency-mark ${isLarge ? 'major' : 'minor'}`;
                    mark.style.transform = `rotate(${angle}deg) translate(0, -140px)`;
                    mark.style.left = '50%';
                    mark.style.top = '50%';
                    mark.style.marginLeft = isLarge ? '-1.5px' : '-0.5px';
                    mark.style.marginTop = isLarge ? '-10px' : '-5px';
                    markingsContainer.appendChild(mark);
                }
            }

            startTuningAdjust(e) {
                e.preventDefault();
                this.isTuningAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueTuningAdjust = this.continueTuningAdjust.bind(this);
                this.boundStopTuningAdjust = this.stopTuningAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.tuningLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.addEventListener('mouseup', this.boundStopTuningAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.tuningLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueTuningAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopTuningAdjust);
                }
            }

// REPLACE your existing continueTuningAdjust method with this enhanced version:
continueTuningAdjust(e) {
    if (!this.isTuningAdjusting) return;
    if (this.tuningAnimationFrame) {
        cancelAnimationFrame(this.tuningAnimationFrame);
    }
    this.tuningAnimationFrame = requestAnimationFrame(() => {
        const tuningKnob = document.getElementById('tuningKnob');
        const rect = tuningKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let currentX, currentY;
        
        if (e.type === 'mousemove') {
            currentX = e.clientX;
            currentY = e.clientY;
        } else if (e.type === 'touchmove') {
            e.preventDefault();
            const t = e.touches[0];
            currentX = t.clientX;
            currentY = t.clientY;
        }
        
        const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
        if (distance < rect.width * 2) {
            const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
            let deltaAngle = currentAngle - this.tuningLastAngle;
            if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
            if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
            
            // NEW: Calculate tuning speed
            const now = performance.now();
            const timeDelta = now - this.lastTuningTime;
            const angleDelta = Math.abs(deltaAngle);
            
            if (timeDelta > 0) {
                const speed = angleDelta / (timeDelta / 1000); // radians per second
                this.updateTuningSpeed(speed);
            }
            this.lastTuningTime = now;
            
            const sensitivity = 1.5;
            deltaAngle *= sensitivity;
            this.tuningKnobRotation += (deltaAngle * 180 / Math.PI);
            tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
            
            // NEW: Use variable step size
            const currentStepSize = this.getCurrentStepSize();
            const freqDelta = (deltaAngle * 180 / Math.PI) * currentStepSize * 0.3;
            
            if (Math.abs(freqDelta) > 0.1) {
                this.updateFrequency(freqDelta);
                this.sendFrequencyImmediate();
            }
            this.tuningLastAngle = currentAngle;
        }
        this.tuningAnimationFrame = null;
    });
}

            stopTuningAdjust() {
                this.isTuningAdjusting = false;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                    this.tuningAnimationFrame = null;
                }
                if (this.boundContinueTuningAdjust && this.boundStopTuningAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.removeEventListener('mouseup', this.boundStopTuningAdjust);
                    document.removeEventListener('touchmove', this.boundContinueTuningAdjust);
                    document.removeEventListener('touchend', this.boundStopTuningAdjust);
                    this.boundContinueTuningAdjust = null;
                    this.boundStopTuningAdjust = null;
                }
                this.sendFrequencyImmediate();
				this.triggerAutotuneScan(); // Add this line
            }

           handleTuningWheel(e) {
    e.preventDefault();
    
    // NEW: Track wheel speed
    const now = performance.now();
    const timeDelta = now - this.lastTuningTime;
    const wheelSpeed = Math.abs(e.deltaY) / Math.max(timeDelta, 16); // Normalize speed
    this.updateTuningSpeed(wheelSpeed * 0.1); // Scale wheel speed
    this.lastTuningTime = now;
    
    let steps;
    if (Math.abs(e.deltaY) < 50) {
        steps = e.deltaY > 0 ? -1 : 1;
    } else {
        steps = e.deltaY > 0 ? -1 : 1;
    }
    
    // NEW: Use variable step size
    const currentStepSize = this.getCurrentStepSize();
    const freqDelta = steps * currentStepSize;
    
    this.updateFrequency(freqDelta);
    const rotationDelta = steps * 2;
    this.tuningKnobRotation += rotationDelta;
    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
    this.sendFrequencyDynamically();
	this.triggerAutotuneScan(); // Add this line
}

            handleTuningKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustFrequency(-this.stepSize);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustFrequency(this.stepSize);
                }
            }

            adjustFrequency(delta) {
                this.updateFrequency(delta);
                const rotationDelta = (delta / this.stepSize) * 2;
                this.tuningKnobRotation += rotationDelta;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    this.sendFrequencyImmediate();
                    this.tuningAnimationFrame = null;
                });
            }

           sendFrequencyImmediate() {
  
    // Use the new combo function to set frequency and restore gain
    this.setFrequencyAndRestoreGain(this.frequency);

}

           sendFrequencyDynamically() {
   this.setFrequencyAndRestoreGain(this.frequency);
}
			
            startPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                this.pollingInterval = setInterval(async () => {
                    if (this.connected) {
                        await this.sendCommand('IF');
                        await this.sendCommand('LC');
                        await this.sendCommand('SM');
                        await this.sendCommand('SW');
                        await this.sendCommand('KS');
						await this.sendCommand('AG0');
						await this.sendCommand('RT');  // Poll RIT status
                    }
					

					
					
					
					
					
                }, 350);
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                }
            }

          parseIfResponse(data) {
    try {
        const freq = parseInt(data.substring(0, 11));
		  // --- ADD THIS LOGIC BLOCK ---
                    // Check if we manually set the frequency within the last 2 seconds.
                    // If so, ignore the (potentially rounded) frequency from the radio's report.
                    const timeSinceLastSet = Date.now() - this.lastManualFreqSet;
                    if (timeSinceLastSet < 2000) {
                         // We still process the rest of the IF response (like TX status), just not the frequency.
                    } else if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                    // --- END OF NEW LOGIC ---
        if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
            this.frequency = freq;
            this.updateDisplay(); // This will now trigger band auto-selection
            document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
        }
        const txStatus = data.substring(26, 27);
        const isTransmitting = (txStatus === '1');
        if (isTransmitting !== this.transmitting) {
            this.transmitting = isTransmitting;
            this.updateTXStatus();
        }
        const catMode = data.substring(27, 28);
        this.updateModeFromCAT(catMode);
    } catch (error) {
        this.logCAT(`Error parsing IF response: ${error.message}`, 'error');
    }
	 }

          async sendFrequencyCommand() {
    if (!this.connected || !this.port || !this.writer) return;
    try {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        await this.sendCommand(`${vfoCommand}${freqStr}`);
        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
        const displayStr = this.frequency.toString().padStart(9, '0');
        const mhz = displayStr.substring(0, 3);
        const khz = displayStr.substring(3, 6); 
        const hz = displayStr.substring(6, 9);
        this.logCAT(`VFO ${this.currentVFO} frequency set to ${mhz}.${khz}.${hz} Hz`, 'info');
    } catch (e) {
        this.logCAT(`Frequency command error: ${e.message}`, 'error');
    }
}

            async updateFrequency(delta) {
                this.frequency += delta;
                this.frequency = Math.max(100000, Math.min(999999999, this.frequency));
                this.frequency = Math.round(this.frequency);
                this.updateDisplay();
                this.saveLastFrequency();
            }

            async connectSerial() {
                try {
                    if (!navigator.serial) {
                        this.logCAT('WebSerial API not supported', 'error');
                        return false;
                    }

                    const selectedBaud = parseInt(document.getElementById('baudRate').value);
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ 
                        baudRate: selectedBaud,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    
                    this.connected = true;
                    this.lastCommandTime = Date.now();
                    this.updateConnectionStatus();
                    this.logCAT(`Serial connected at ${selectedBaud} baud`, 'rx');
                    await this.sendCommand('QB0');
                    await this.sendCommand('Q90'); 
                    
                    this.startReading();
                    this.startConnectionHealthCheck();
                    await this.initializeRadio();
                    this.startPolling();
                    return true;
                } catch (error) {
                    this.logCAT(`Connection failed: ${error.message}`, 'error');
                    this.connected = false;
                    this.updateConnectionStatus();
                    return false;
                }
            }

            async disconnectSerial() {
                try {
                    this.connected = false;
                    if (this.port) {
                        await this.sendCommand('QB1');
                    }
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.stopPolling();
                    if (this.reader) {
                        try {
                            await this.reader.cancel();
                        } catch (e) {
                            console.log('Reader cancel error:', e);
                        }
                        try {
                            await this.reader.releaseLock();
                        } catch (e) {
                            console.log('Reader release error:', e);
                        }
                        this.reader = null;
                    }
                    if (this.writer) {
                        try {
                            await this.writer.releaseLock();
                        } catch (e) {
                            console.log('Writer release error:', e);
                        }
                        this.writer = null;
                    }
                    if (this.port) {
                        try {
                            await this.port.close();
                        } catch (e) {
                            console.log('Port close error:', e);
                        }
                        this.port = null;
                    }
                    this.logCAT('Serial disconnected', 'rx');
                } catch (error) {
                    this.connected = false;
                    this.reader = null;
                    this.writer = null;
                    this.port = null;
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.logCAT(`Disconnect error: ${error.message}`, 'rx');
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.connected && this.reader) {
                        try {
                            const { value, done } = await this.reader.read();
                            if (done) {
                                this.logCAT('Hardware disconnected', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            }
                            const text = new TextDecoder().decode(value);
                            buffer += text;
                            this.lastCommandTime = Date.now();
                            while (buffer.includes(';')) {
                                const end = buffer.indexOf(';');
                                const response = buffer.substring(0, end);
                                buffer = buffer.substring(end + 1);
                                if (response.trim()) {
                                    this.processResponse(response.trim());
                                }
                            }
                        } catch (readError) {
                            if (readError.name === 'NetworkError' || 
                                readError.message.includes('device has been lost') ||
                                readError.message.includes('The port is not open') ||
                                readError.code === 19) {
                                this.logCAT('Hardware disconnected during read', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            } else {
                                this.logCAT(`Read error: ${readError.message}`, 'error');
                            }
                        }
                    }
                } catch (error) {
                    this.logCAT(`Reader stream error: ${error.message}`, 'error');
                    if (this.connected) {
                        this.handleHardwareDisconnect();
                    }
                }
            }

            async sendCommand(command) {
                if (!this.connected || !this.writer) {
                    return null;
                }
                try {
                    const fullCommand = command + ';';
                    const data = new TextEncoder().encode(fullCommand);
                    await this.writer.write(data);
                    this.logCAT(command, 'tx');
                    this.lastCommandTime = Date.now();
                    return true;
                } catch (error) {
                    if (error.name === 'NetworkError' || 
                        error.message.includes('device has been lost') ||
                        error.message.includes('The port is not open') ||
                        error.code === 19) {
                        this.logCAT('Hardware disconnected during command', 'error');
                        this.handleHardwareDisconnect();
                    } else {
                        this.logCAT(`Send error: ${error.message}`, 'error');
                    }
                    return false;
                }
            }

            handleHardwareDisconnect() {
                if (!this.connected) return;
                this.connected = false;
                this.reader = null;
                this.writer = null;
                this.port = null;
                if (this.connectionCheckTimeout) {
                    clearTimeout(this.connectionCheckTimeout);
                    this.connectionCheckTimeout = null;
                }
                this.updateConnectionStatus();
                this.logCAT('Auto-disconnect complete', 'rx');
            }

            startConnectionHealthCheck() {
                if (!this.connected) return;
                const now = Date.now();
                const timeSinceLastCommand = now - this.lastCommandTime;
                if (timeSinceLastCommand > 10000 && this.connected) {
                    this.sendCommand('ID').catch(() => {
                        this.logCAT('Connection health check failed', 'error');
                        this.handleHardwareDisconnect();
                    });
                }
                this.connectionCheckTimeout = setTimeout(() => {
                    this.startConnectionHealthCheck();
                }, 5000);
            }
			
			
			
			
	//-----------------------------------------------------------		
			
			
			
			

 processResponse(response) {
            this.logCAT(response, 'rx');
            
            if (response.startsWith('IF')) {
                this.parseIfResponse(response.substring(2));
            } else if (response.startsWith('LC')) {
                let lcdData = response.substring(2).padEnd(32, ' ');
                this.updateLcdDisplay(lcdData.substring(0, 16), lcdData.substring(16, 32));
            } else if (response.startsWith('AG')) {
                const gain = parseInt(response.substring(2));
                if (!isNaN(gain) && !this.isVolumeAdjusting) {
                    this.volumeLevel = this.catToVolume(gain);
                    this.updateVolumeUI();
                }
            } else if (response.startsWith('FA')) {
                const freq = parseInt(response.substring(2));
                if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'A') {
                    this.frequency = freq;
                    this.updateDisplay();
                    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                }
            } else if (response.startsWith('FB')) {
                const freq = parseInt(response.substring(2));
                if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'B') {
                    this.frequency = freq;
                    this.updateDisplay();
                    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                }
            } else if (response.startsWith('SM')) {
                const smeterValue = parseInt(response.substring(2));
                if (!isNaN(smeterValue)) {
                    const smeterPercent = Math.max(0, Math.min(100, (smeterValue / 255) * 100));
                    this.updateSMeter(smeterPercent);
                    this.updateSMeterLabel(smeterPercent);
                }
            } else if (response.startsWith('SW')) {
                const swrResponse = response.substring(2);
                if (swrResponse.length > 0) {
                    const swrHundredths = parseInt(swrResponse);
                    if (!isNaN(swrHundredths)) {
                        const actualSWR = swrHundredths / 100;
                        const swrPercent = Math.max(0, Math.min(100, ((actualSWR - 1.0) / 2.0) * 100));
                        this.updateSWRMeter(swrPercent);
                    }
                } else {
                    this.updateSWRMeter(0); // RX mode
                }
            } else if (response.startsWith('PC')) {
                const powerTenths = parseInt(response.substring(2));
                if (!isNaN(powerTenths) && !this.isPowerAdjusting) {
                    this.powerLevel = powerTenths;
                    this.updatePowerLevel();
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                }
            } else if (response.startsWith('MD')) {
                this.updateModeFromCAT(response.substring(2));
            } else if (response.startsWith('KS')) {
                const wpm = parseInt(response.substring(2));
                if (!isNaN(wpm) && !this.isRFGainAdjusting && wpm >= 0 && wpm <= 50) {
                    this.rfGainLevel = (wpm / 50) * 100;
                    this.updateRFGainLevel();
                    this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                    document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                }
            } else if (response.startsWith('TX')) {
                this.transmitting = true;
                this.updateTXStatus();
            } else if (response.startsWith('RX')) {
                this.transmitting = false;
                this.updateTXStatus();
            } else if (response.startsWith('RT')) {
                const ritStatus = response.substring(2);
                if (ritStatus === '0' || ritStatus === '1') {
                    this.ritEnabled = (ritStatus === '1');
                    this.updateRITUI();
                    if (!this.isRITAdjusting) {
                        this.logCAT(`RIT status: ${this.ritEnabled ? 'ON' : 'OFF'}`, 'rx');
                    }
                }
            } else if (response.startsWith('RD') || response.startsWith('RU')) {
                const offsetStr = response.substring(2);
                const offsetValue = parseInt(offsetStr);
                if (!isNaN(offsetValue) && !this.isRITAdjusting) {
                    this.ritOffset = response.startsWith('RD') ? -offsetValue : offsetValue;
                    this.updateRITUI();
                }
            }
        } // This is the single, correct closing brace for the function

//----------------------------------------------------------


updateSMeterLabel(percentage) {
    // Convert percentage to S-units (S1-S9, then +10, +20, etc.)
    let label;
    if (percentage <= 50) {
        // S1 through S9
        const sUnits = Math.floor((percentage / 50) * 9) + 1;
        label = `S${sUnits}`;
    } else {
        // S9+ readings
        const overS9 = Math.floor((percentage - 50) / 10) * 10;
        label = `S9+${overS9}`;
    }
    
    // Update label if element exists
    const sMeterText = document.getElementById('sMeterText');
    if (sMeterText) {
        sMeterText.textContent = label;
    }
}










//______________________________________________________________________
        
 /*      // Modify the initFrequencyKeyboard method to include this at the end:
initFrequencyKeyboard() {
    // ... existing code ...
    
    // NEW: Initialize permanent frequency input
    this.initPermanentFreqInput();
    
    // NEW: Add mode toggle listener
    document.getElementById('freqInputMode').addEventListener('change', (e) => {
        this.setFreqInputMode(e.target.value);
    });
}*/

// NEW: Add these methods
initPermanentFreqInput() {
    this.freqInputModePerm = 'mhz';
    this.freqInputValuePerm = '';
    
    // Format buttons for permanent panel
    document.querySelectorAll('[data-target="permanent"].freq-format-btn').forEach(btn => {
        btn.addEventListener('click', () => this.setFreqInputFormatPerm(btn.dataset.format));
    });
    
    // Keypad buttons for permanent panel
    document.querySelectorAll('[data-target="permanent"].freq-key').forEach(key => {
        key.addEventListener('click', () => this.handleFreqKeyInputPerm(key.dataset.key));
    });
    
    // Action buttons for permanent panel
    document.getElementById('freqSetBtnPerm').addEventListener('click', () => this.setFrequencyFromInputPerm());
    document.getElementById('freqClearBtnPerm').addEventListener('click', () => this.clearFreqInputPerm());
    
    // Input field events for permanent panel
    const freqInputPerm = document.getElementById('freqDisplayInputPerm');
    freqInputPerm.addEventListener('input', (e) => this.handleFreqInputChangePerm(e));
    freqInputPerm.addEventListener('keydown', (e) => this.handleFreqInputKeyboardPerm(e));
}

setFreqInputMode(mode) {
    const permanentPanel = document.getElementById('freqInputPermanentPanel');
    const lcdPanel = document.getElementById('lcdPanel');
    
    if (mode === 'permanent') {
        permanentPanel.style.display = 'block';
        // Update the input with current frequency
        this.freqInputValuePerm = this.formatFrequencyForInput(this.frequency, this.freqInputModePerm);
        document.getElementById('freqDisplayInputPerm').value = this.freqInputValuePerm;
        // Disable LCD click for popup
        lcdPanel.style.pointerEvents = 'none';
        lcdPanel.style.opacity = '0.8';
        lcdPanel.style.cursor = 'not-allowed';
        this.logCAT('Frequency input: Permanent mode enabled', 'info');
    } else {
        // Popup mode
        permanentPanel.style.display = 'none';
        // Re-enable LCD click for popup
        lcdPanel.style.pointerEvents = 'auto';
        lcdPanel.style.opacity = '1';
        lcdPanel.style.cursor = 'pointer';
        this.logCAT('Frequency input: Popup mode enabled', 'info');
    }
    
    // Update the dropdown to reflect the current mode
    const modeSelect = document.getElementById('freqInputMode');
    if (modeSelect.value !== mode) {
        modeSelect.value = mode;
    }
}
setFreqInputFormatPerm(format) {
    this.freqInputModePerm = format;
    
    // Update active button
    document.querySelectorAll('[data-target="permanent"].freq-format-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.format === format) {
            btn.classList.add('active');
        }
    });
    
    // Update the input field with current frequency in new format
    this.freqInputValuePerm = this.formatFrequencyForInput(this.frequency, format);
    document.getElementById('freqDisplayInputPerm').value = this.freqInputValuePerm;
    this.clearFreqErrorPerm();
}

handleFreqKeyInputPerm(key) {
    const freqInput = document.getElementById('freqDisplayInputPerm');
    
    if (key === 'backspace') {
        this.freqInputValuePerm = this.freqInputValuePerm.slice(0, -1);
    } else {
        if (this.freqInputValuePerm.length >= 15) return;
        
        if (key === '.') {
            if (this.freqInputValuePerm.includes('.')) return;
            if (this.freqInputValuePerm.length === 0) return;
        }
        
        this.freqInputValuePerm += key;
    }
    
    freqInput.value = this.freqInputValuePerm;
    this.validateFreqInputPerm();
    freqInput.focus();
}

handleFreqInputChangePerm(e) {
    let value = e.target.value.replace(/[^0-9.]/g, '');
    
    const parts = value.split('.');
    if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
    }
    
    this.freqInputValuePerm = value;
    e.target.value = value;
    this.validateFreqInputPerm();
}

handleFreqInputKeyboardPerm(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        this.setFrequencyFromInputPerm();
    }
}

clearFreqInputPerm() {
    this.freqInputValuePerm = '';
    document.getElementById('freqDisplayInputPerm').value = '';
    this.clearFreqErrorPerm();
    document.getElementById('freqDisplayInputPerm').focus();
}

validateFreqInputPerm() {
    const errorEl = document.getElementById('freqErrorPerm');
    errorEl.textContent = '';
    
    if (!this.freqInputValuePerm) return true;
    
    const freq = this.parseFrequencyInput(this.freqInputValuePerm, this.freqInputModePerm);
    
    if (freq === null) {
        errorEl.textContent = 'Invalid format';
        return false;
    }
    
    if (freq < 100000 || freq > 999999999) {
        errorEl.textContent = 'Out of range';
        return false;
    }
    
    return true;
}

clearFreqErrorPerm() {
    document.getElementById('freqErrorPerm').textContent = '';
}

setFrequencyFromInputPerm() {
    if (!this.validateFreqInputPerm()) return;
    
    const freq = this.parseFrequencyInput(this.freqInputValuePerm, this.freqInputModePerm);
    if (freq === null) return;
    
    // Set the new frequency (reuse existing logic)
    this.frequency = freq;
    this.updateDisplay();
    this.updateBandFromFrequency();
    this.updateBandButtons();
    this.saveLastFrequency();
    
    if (this.connected) {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
            setTimeout(() => {
                this.sendCommand(this.getVFOCommand());
            }, 100);
        }).catch(e => {
            this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
        });
    }
    
    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
    
    const displayStr = this.frequency.toString().padStart(9, '0');
    const mhz = displayStr.substring(0, 3);
    const khz = displayStr.substring(3, 6);
    const hz = displayStr.substring(6, 9);
    this.logCAT(`Direct frequency entry: ${mhz}.${khz}.${hz} Hz`, 'info');
    
    // Update the permanent input to show the set frequency
    this.freqInputValuePerm = this.formatFrequencyForInput(this.frequency, this.freqInputModePerm);
    document.getElementById('freqDisplayInputPerm').value = this.freqInputValuePerm;
}    
              
   // Add these methods to the QMXInterface class

initRITControl() {
    try {
        console.log('Initializing RIT control...');
        
        // Check if RIT elements exist
        const ritToggleBtn = document.getElementById('ritToggleBtn');
        const ritClearBtn = document.getElementById('ritClearBtn');
        const ritKnob = document.getElementById('ritKnob');
        
        if (!ritToggleBtn) {
            console.error('RIT Toggle button not found! Make sure HTML is added.');
            return;
        }
        
        console.log('RIT elements found, setting up event listeners...');
        
        // Initialize RIT state
        this.ritEnabled = false;
        this.ritOffset = 0;
        this.updateRITUI();
        
        // RIT Toggle button - WITH DEBUGGING
        ritToggleBtn.addEventListener('click', (e) => {
            console.log('RIT Toggle button clicked!');
            this.toggleRIT();
        });
        
        // RIT Clear button
        if (ritClearBtn) {
            ritClearBtn.addEventListener('click', (e) => {
                console.log('RIT Clear button clicked!');
                this.clearRIT();
            });
        }
        
        // RIT adjustment buttons
        document.querySelectorAll('.rit-adjust').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const offset = parseInt(btn.dataset.offset);
                console.log(`RIT adjust button clicked: ${offset} Hz`);
                this.adjustRIT(offset);
            });
        });
        
        // RIT Fine control knob
        if (ritKnob) {
            ritKnob.addEventListener('mousedown', this.startRITAdjust.bind(this));
            ritKnob.addEventListener('touchstart', this.startRITAdjust.bind(this), { passive: false });
            ritKnob.addEventListener('wheel', this.handleRITWheel.bind(this));
            ritKnob.addEventListener('keydown', this.handleRITKeyboard.bind(this));
        }
        
        console.log('RIT control initialized successfully');
        this.logCAT('RIT control system ready', 'info');
        
    } catch (error) {
        console.error('Error initializing RIT control:', error);
        this.logCAT(`RIT init error: ${error.message}`, 'error');
    }
}

toggleRIT() {
    try {
        this.ritEnabled = !this.ritEnabled;

        if (this.connected) {
            if (this.ritEnabled) {
                // --- Turning RIT ON ---
                // If the offset is currently zero, set it to a tiny value (+1 Hz).
                // This forces the radio to engage RIT mode.
                if (this.ritOffset === 0) {
                    this.ritOffset = 1;
                }
                // Now, send the command to set the current offset value.
                this.sendRITCommand();
                this.logCAT(`RIT ENABLED (offset: ${this.ritOffset} Hz)`, 'info');
            } else {
                // --- Turning RIT OFF ---
                // The 'RIT Clear' (RC) command is the most reliable way to turn RIT off.
                this.sendCommand('RC');
                this.ritOffset = 0; // Also reset our internal state to match.
                this.logCAT(`RIT DISABLED`, 'info');
            }
        } else {
            // This handles toggling when not connected to the radio.
            if (!this.ritEnabled) {
                this.ritOffset = 0;
            }
            this.logCAT(`RIT toggled (offline)`, 'info');
        }

        // Finally, update the UI to reflect the new state.
        this.updateRITUI();

    } catch (error) {
        this.logCAT(`RIT toggle error: ${error.message}`, 'error');
    }
}
clearRIT() {
    try {
        console.log('Clearing RIT offset');
        
        this.ritOffset = 0;
        this.ritKnobRotation = 0;
        this.updateRITUI();
        
        if (this.connected) {
            this.sendCommand('RC').then(() => {
                this.logCAT('RIT offset cleared', 'info');
                console.log('RIT clear command sent successfully');
            }).catch(e => {
                console.error('RIT clear command failed:', e);
                this.logCAT(`RIT clear error: ${e.message}`, 'error');
            });
        } else {
            this.logCAT('RIT offset cleared (radio not connected)', 'info');
            console.log('RIT cleared locally');
        }
        
    } catch (error) {
        console.error('Error in clearRIT:', error);
        this.logCAT(`RIT clear error: ${error.message}`, 'error');
    }
}

adjustRIT(offsetHz) {
    try {
        console.log(`Adjusting RIT by ${offsetHz} Hz (current: ${this.ritOffset} Hz)`);
        
        if (!this.ritEnabled) {
            this.logCAT('Enable RIT first before adjusting', 'error');
            console.log('RIT adjustment blocked - RIT not enabled');
            return;
        }
        
        const newOffset = this.ritOffset + offsetHz;
        
        // Limit RIT range to Â±9999 Hz
        if (newOffset < -9999 || newOffset > 9999) {
            this.logCAT(`RIT offset limited to Â±9999 Hz`, 'error');
            console.log(`RIT adjustment blocked - would exceed range: ${newOffset}`);
            return;
        }
        
        this.ritOffset = newOffset;
        console.log(`RIT offset set to: ${this.ritOffset} Hz`);
        
        this.updateRITUI();
        this.sendRITCommand();
        
    } catch (error) {
        console.error('Error in adjustRIT:', error);
        this.logCAT(`RIT adjust error: ${error.message}`, 'error');
    }
}

updateRITUI() {
    try {
        //console.log(`Updating RIT UI - Enabled: ${this.ritEnabled}, Offset: ${this.ritOffset}`);
        
        // Get elements
        const statusDisplay = document.getElementById('ritStatusDisplay');
        const statusText = document.getElementById('ritStatus');
        const offsetValue = document.getElementById('ritOffsetValue');
        const ritPanel = document.getElementById('ritPanel');
        const ritKnob = document.getElementById('ritKnob');
        const toggleBtn = document.getElementById('ritToggleBtn');
        
        // Check if elements exist
        if (!statusDisplay || !statusText || !offsetValue) {
            console.error('RIT UI elements not found! Check HTML structure.');
            return;
        }
        
        // Update status
        if (this.ritEnabled) {
            statusDisplay.classList.add('active');
            statusText.textContent = 'ON';
            statusText.classList.add('active');
            if (ritPanel) ritPanel.classList.add('rit-active');
            if (ritKnob) ritKnob.classList.add('rit-active');
            if (toggleBtn) {
                toggleBtn.classList.remove('btn-secondary');
                toggleBtn.classList.add('btn-primary');
            }
        } else {
            statusDisplay.classList.remove('active');
            statusText.textContent = 'OFF';
            statusText.classList.remove('active');
            if (ritPanel) ritPanel.classList.remove('rit-active');
            if (ritKnob) ritKnob.classList.remove('rit-active');
            if (toggleBtn) {
                toggleBtn.classList.remove('btn-primary');
                toggleBtn.classList.add('btn-secondary');
            }
        }
        
        // Update offset display
        const sign = this.ritOffset >= 0 ? '+' : '';
        offsetValue.textContent = `${sign}${this.ritOffset} Hz`;
        
        // Update offset display color
        offsetValue.classList.remove('positive', 'negative');
        if (this.ritOffset > 0) {
            offsetValue.classList.add('positive');
        } else if (this.ritOffset < 0) {
            offsetValue.classList.add('negative');
        }
        
        // Update knob position
        if (ritKnob) {
            const knobOffset = Math.max(-1000, Math.min(1000, this.ritOffset));
            const normalizedPosition = (knobOffset + 1000) / 2000;
            this.ritKnobRotation = this.minRotation + (normalizedPosition * this.totalRotationRange);
            ritKnob.style.transform = `rotate(${this.ritKnobRotation}deg)`;
            ritKnob.setAttribute('aria-valuenow', this.ritOffset);
        }
        
        // Update knob level display
        const ritKnobLevel = document.getElementById('ritKnobLevel');
        if (ritKnobLevel) {
            ritKnobLevel.textContent = `${sign}${this.ritOffset} Hz`;
        }
        
       // console.log('RIT UI updated successfully');
        
    } catch (error) {
        console.error('Error updating RIT UI:', error);
        this.logCAT(`RIT UI update error: ${error.message}`, 'error');
    }
}

sendRITCommand() {
    if (!this.connected) {
        console.log('RIT command not sent - radio not connected');
        return;
    }
    
    try {
        if (this.ritTimeout) {
            clearTimeout(this.ritTimeout);
        }
        
        this.ritTimeout = setTimeout(() => {
            console.log(`Sending RIT command for offset: ${this.ritOffset} Hz`);
            
            let command;
            if (this.ritOffset === 0) {
                command = 'RC';
            } else if (this.ritOffset > 0) {
                command = `RU${Math.abs(this.ritOffset).toString().padStart(4, '0')}`;
            } else {
                command = `RD${Math.abs(this.ritOffset).toString().padStart(4, '0')}`;
            }
            
            console.log(`Sending command: ${command}`);
            
            this.sendCommand(command).then(() => {
                console.log(`RIT command sent successfully: ${command}`);
                this.logCAT(`RIT offset set: ${this.ritOffset} Hz`, 'info');
            }).catch(e => {
                console.error("RIT command error:", e);
                this.logCAT(`RIT command error: ${e.message}`, 'error');
            });
            
            this.ritTimeout = null;
        }, 100);
        
    } catch (error) {
        console.error('Error in sendRITCommand:', error);
        this.logCAT(`RIT send error: ${error.message}`, 'error');
    }
}  

    

//-----------------------------------------------------
// Add this temporary test function to check if RIT is working
// You can call this from the browser console to test

testRIT() {
    console.log('=== RIT TEST START ===');
    console.log('Current RIT state:', {
        enabled: this.ritEnabled,
        offset: this.ritOffset
    });
    
    // Test the toggle function directly
    console.log('Testing toggle function...');
    this.toggleRIT();
    
    console.log('RIT state after toggle:', {
        enabled: this.ritEnabled,
        offset: this.ritOffset
    });
    
    // Test adjustment
    console.log('Testing 50Hz adjustment...');
    this.adjustRIT(50);
    
    console.log('Final RIT state:', {
        enabled: this.ritEnabled,
        offset: this.ritOffset
    });
    console.log('=== RIT TEST END ===');
}

// Also add this method to help debug
checkRITElements() {
    const elements = {
        ritPanel: document.getElementById('ritPanel'),
        ritToggleBtn: document.getElementById('ritToggleBtn'),
        ritStatus: document.getElementById('ritStatus'),
        ritOffsetValue: document.getElementById('ritOffsetValue'),
        ritKnob: document.getElementById('ritKnob')
    };
    
    console.log('RIT Elements Check:', elements);
    
    Object.keys(elements).forEach(key => {
        if (!elements[key]) {
            console.error(`âŒ Missing element: ${key}`);
        } else {
            console.log(`âœ… Found element: ${key}`);
        }
    });
    
    return elements;
}

//--------------------------

async initAudioStreaming() {
    try {
        console.log('Initializing audio streaming...');
        this.setupAudioEventListeners();
        
        // Automatically enumerate devices on startup
        await this.enumerateAudioDevices();
        
        this.logCAT('Audio streaming ready', 'info');
        
        // Set default gain boost
        this.audioGain = 2.0;
        const gainSlider = document.getElementById('audioGainSlider');
        if (gainSlider) {
            gainSlider.value = this.audioGain * 100;
        }
        this.updateGainDisplay();
        
    } catch (error) {
        console.error('Audio init error:', error);
        this.logCAT(`Audio init error: ${error.message}`, 'error');
        
        // If automatic enumeration fails, set up a fallback
        this.setupDeviceEnumerationFallback();
    }
}
setupDeviceEnumerationFallback() {
    // Show a helpful message in the dropdowns
    const inputSelect = document.getElementById('audioInputDevice');
    const outputSelect = document.getElementById('audioOutputDevice');
    
    if (inputSelect && outputSelect) {
        inputSelect.innerHTML = '<option value="">Click "Refresh" to load devices</option>';
        outputSelect.innerHTML = '<option value="">Click "Refresh" to load devices</option>';
    }
    
    this.logCAT('Click "Refresh" to load audio devices', 'info');
}

setupAudioEventListeners() {
    const inputSelect = document.getElementById('audioInputDevice');
    const outputSelect = document.getElementById('audioOutputDevice');
    
    if (!inputSelect || !outputSelect) {
        console.error('Audio select elements not found!');
        return;
    }
    
    // Input device selection with debugging
    inputSelect.addEventListener('change', (e) => {
        this.selectedInputDevice = e.target.value;
        const selectedName = e.target.options[e.target.selectedIndex].text;
        console.log('Input device changed to:', this.selectedInputDevice, '-', selectedName);
        this.logCAT(`Input selected: ${selectedName}`, 'info');
        
        if (this.isAudioStreaming) {
            this.stopAudioStream();
        }
    });
    
    // Output device selection with debugging
    outputSelect.addEventListener('change', (e) => {
        this.selectedOutputDevice = e.target.value;
        const selectedName = e.target.options[e.target.selectedIndex].text;
        console.log('Output device changed to:', this.selectedOutputDevice, '-', selectedName);
        this.logCAT(`Output selected: ${selectedName}`, 'info');
        
        if (this.isAudioStreaming && this.audioContext && this.audioContext.setSinkId) {
            this.audioContext.setSinkId(this.selectedOutputDevice).catch(console.error);
        }
    });
    
    // Button listeners
    document.getElementById('startStreamBtn').addEventListener('click', () => {
        console.log('START BUTTON CLICKED - selectedInputDevice:', this.selectedInputDevice);
        this.startAudioStream();
    });
    // Add this to your setupAudioEventListeners() method
document.getElementById('refreshDevicesBtn').addEventListener('click', async () => {
    this.logCAT('Refreshing audio devices...', 'info');
    console.log('Manual device refresh requested');
    await this.enumerateAudioDevices();
	});
	
	const gainSlider = document.getElementById('audioGainSlider');
if (gainSlider) {
    gainSlider.addEventListener('input', (e) => {
        const gainValue = parseInt(e.target.value) / 100; // Convert to multiplier
        this.audioGain = gainValue;
        this.updateAudioGain();
        this.updateGainDisplay();
    });
}


	
    document.getElementById('stopStreamBtn').addEventListener('click', () => this.stopAudioStream());
    document.getElementById('muteInputBtn').addEventListener('click', () => this.toggleInputMute());
    document.getElementById('muteOutputBtn').addEventListener('click', () => this.toggleOutputMute());
}

async enumerateAudioDevices() {
    try {
        console.log('=== STARTING DEVICE ENUMERATION ===');
        
        // Request permission with more explicit constraints
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false
            }
        });
        
        // Stop the temporary stream
        stream.getTracks().forEach(track => track.stop());
        console.log('Microphone permission granted and test stream closed');
        
        // Small delay to ensure devices are properly enumerated
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        console.log('All devices found:', devices.length);
        
        const inputSelect = document.getElementById('audioInputDevice');
        const outputSelect = document.getElementById('audioOutputDevice');
        
        if (!inputSelect || !outputSelect) {
            console.error('Audio select elements not found!');
            return;
        }
        
        // Clear existing options
        inputSelect.innerHTML = '<option value="">Select Input Device...</option>';
        outputSelect.innerHTML = '<option value="">Select Output Device...</option>';
        
        // Reset arrays
        this.audioDevices = { input: [], output: [] };
        
        devices.forEach((device, index) => {
            const deviceName = device.label || `Device ${index + 1}`;
            const deviceId = device.deviceId || `device-${index}-${device.kind}`;
            
            console.log(`Device ${index}: ${device.kind} - ${deviceName}`);
            console.log(`  ID: "${deviceId}"`);
            console.log(`  GroupID: "${device.groupId}"`);
            
            if (device.kind === 'audioinput') {
                const option = document.createElement('option');
                option.value = deviceId;
                option.textContent = deviceName;
                inputSelect.appendChild(option);
                this.audioDevices.input.push({
                    ...device,
                    deviceId: deviceId // Ensure we have a valid ID
                });
            }
            
            else if (device.kind === 'audiooutput') {
                const option = document.createElement('option');
                option.value = deviceId;
                option.textContent = deviceName;
                outputSelect.appendChild(option);
                this.audioDevices.output.push({
                    ...device,
                    deviceId: deviceId // Ensure we have a valid ID
                });
            }
        });
        
        // Enhanced selection logic with validation
        if (this.audioDevices.input.length > 0) {
            const firstInput = this.audioDevices.input[0];
            this.selectedInputDevice = firstInput.deviceId;
            inputSelect.selectedIndex = 1; // Select first real option
            
            console.log('âœ… SELECTED INPUT DEVICE:', firstInput.label || 'Device 1');
            console.log('âœ… INPUT DEVICE ID:', this.selectedInputDevice);
            this.logCAT(`Selected input: ${firstInput.label || 'Device 1'}`, 'info');
        } else {
            console.log('âŒ NO INPUT DEVICES FOUND');
            this.selectedInputDevice = null;
        }
        
        if (this.audioDevices.output.length > 0) {
            const firstOutput = this.audioDevices.output[0];
            this.selectedOutputDevice = firstOutput.deviceId;
            outputSelect.selectedIndex = 1; // Select first real option
            
            console.log('âœ… SELECTED OUTPUT DEVICE:', firstOutput.label || 'Device 2');
            console.log('âœ… OUTPUT DEVICE ID:', this.selectedOutputDevice);
            this.logCAT(`Selected output: ${firstOutput.label || 'Device 2'}`, 'info');
        } else {
            console.log('âŒ NO OUTPUT DEVICES FOUND');
            this.selectedOutputDevice = null;
        }
        
        console.log('=== DEVICE ENUMERATION COMPLETE ===');
        console.log('ðŸŽ¯ FINAL Selected Input Device ID:', this.selectedInputDevice);
        console.log('ðŸŽ¯ FINAL Selected Output Device ID:', this.selectedOutputDevice);
        
        // Validate that we have valid selections
        if (!this.selectedInputDevice) {
            console.warn('âš ï¸ No valid input device selected - using default');
            this.selectedInputDevice = 'default';
        }
        if (!this.selectedOutputDevice) {
            console.warn('âš ï¸ No valid output device selected - using default');
            this.selectedOutputDevice = 'default';
        }
        
        this.logCAT(`Ready: ${this.audioDevices.input.length} input, ${this.audioDevices.output.length} output devices`, 'info');
        
    } catch (error) {
        console.error('Device enumeration error:', error);
        this.logCAT(`Device enumeration error: ${error.message}`, 'error');
        
        // Fallback to default devices
        this.selectedInputDevice = 'default';
        this.selectedOutputDevice = 'default';
        console.log('Using fallback default devices');
    }
}
async startAudioStream() {
    try {
        console.log('ðŸŽ¯ START BUTTON CLICKED');
        console.log('ðŸ“ selectedInputDevice:', this.selectedInputDevice);
        
        if (!this.selectedInputDevice) {
            console.log('âŒ No input device - setting to default');
            this.selectedInputDevice = 'default';
        }
        
        this.logCAT('Starting audio stream...', 'info');
        
        // Create audio context
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 48000
        });
        
        console.log('Audio context created, state:', this.audioContext.state);
        
        if (this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
            console.log('Audio context resumed');
        }
        
        // Prepare audio constraints
        let audioConstraints = {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
        };
        
        // Only specify deviceId if it's not 'default' and not empty
        if (this.selectedInputDevice && this.selectedInputDevice !== 'default' && this.selectedInputDevice.trim() !== '') {
            audioConstraints.deviceId = { exact: this.selectedInputDevice };
            console.log('Using specific device ID:', this.selectedInputDevice);
        } else {
            console.log('Using default device (no specific ID)');
        }
        
        console.log('Requesting microphone with constraints:', audioConstraints);
        
        // Get microphone access
        this.inputStream = await navigator.mediaDevices.getUserMedia({
            audio: audioConstraints
        });
        
        console.log('âœ… Got input stream:', this.inputStream);
        console.log('Stream tracks:', this.inputStream.getTracks());
        
        // Create audio nodes
        this.inputSource = this.audioContext.createMediaStreamSource(this.inputStream);
      
        
		
		// In your startAudioStream() method, after creating gainNode:
this.gainNode = this.audioContext.createGain();
this.gainNode.gain.value = this.audioGain; // Use current gain setting instead of 1.0

// Initialize gain display
this.updateGainDisplay();
        
        this.inputAnalyser = this.audioContext.createAnalyser();
        this.inputAnalyser.fftSize = 256;
        
        // Connect audio graph: Input â†’ Gain â†’ Analyser â†’ Speakers
        this.inputSource.connect(this.gainNode);
        this.gainNode.connect(this.inputAnalyser);
        this.gainNode.connect(this.audioContext.destination);
         this.startSpectrum(); // Add this line
        console.log('âœ… Audio nodes connected');
        
        // Set output device if available and not default
        if (this.selectedOutputDevice && 
            this.selectedOutputDevice !== 'default' && 
            this.selectedOutputDevice.trim() !== '' && 
            this.audioContext.setSinkId) {
            
            try {
                await this.audioContext.setSinkId(this.selectedOutputDevice);
                console.log('âœ… Output device set:', this.selectedOutputDevice);
            } catch (outputError) {
                console.warn('âš ï¸ Could not set output device:', outputError.message);
            }
        }
        
        // Start monitoring
        this.startLevelMonitoring();
        
        // Update state
        this.isAudioStreaming = true;
        this.updateStreamingButtons();
        
        document.getElementById('audioStatusText').textContent = 'Streaming active';
        document.getElementById('audioStatusDot').classList.add('active');
        
        console.log('ðŸŽ‰ Audio streaming started successfully!');
        this.logCAT('âœ… Audio streaming: QMX â†’ PC Speakers', 'info');
        
    } catch (error) {
        console.error('âŒ Stream start error:', error);
        this.logCAT(`Stream start error: ${error.message}`, 'error');
        
        // More specific error messages
        if (error.name === 'NotAllowedError') {
            alert('Microphone permission denied. Please allow microphone access and try again.');
        } else if (error.name === 'NotFoundError') {
            alert('No microphone found. Please connect a microphone and refresh the page.');
        } else if (error.name === 'OverconstrainedError') {
            alert('The selected audio device is not available. Trying with default device...');
            // Retry with default device
            this.selectedInputDevice = 'default';
            setTimeout(() => this.startAudioStream(), 1000);
            return;
        } else {
            alert(`Audio start failed: ${error.message}`);
        }
        
        // Reset state on error
        this.isAudioStreaming = false;
        this.updateStreamingButtons();
    }
}


startLevelMonitoring() {
    if (!this.inputAnalyser) return;
    
    const bufferLength = this.inputAnalyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    const updateLevel = () => {
        if (!this.isAudioStreaming) return;
        
        this.inputAnalyser.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i] * dataArray[i];
        }
        const rms = Math.sqrt(sum / bufferLength);
        const level = (rms / 255) * 100;
        
        const meter = document.getElementById('inputLevelMeter');
        const text = document.getElementById('inputLevelText');
        
        if (meter && text) {
            meter.style.width = `${level}%`;
            const db = level > 0 ? (20 * Math.log10(level / 100)) : -Infinity;
            text.textContent = isFinite(db) ? `${db.toFixed(1)} dB` : '-âˆž dB';
        }
        
        requestAnimationFrame(updateLevel);
    };
    
    updateLevel();
}



async stopAudioStream() {
    try {
        if (this.inputStream) {
            this.inputStream.getTracks().forEach(track => track.stop());
            this.inputStream = null;
        }
        
        this.isAudioStreaming = false;
        this.updateStreamingButtons();
        
        document.getElementById('audioStatusText').textContent = 'Ready to stream';
        document.getElementById('audioStatusDot').classList.remove('active');
        
        this.logCAT('Audio streaming stopped', 'info');
    } catch (error) {
        this.logCAT(`Stop error: ${error.message}`, 'error');
    }
}

updateStreamingButtons() {
    const startBtn = document.getElementById('startStreamBtn');
    const stopBtn = document.getElementById('stopStreamBtn');
    
    if (this.isAudioStreaming) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        stopBtn.classList.add('btn-danger');
    } else {
        startBtn.disabled = false;
        stopBtn.disabled = true;
        stopBtn.classList.remove('btn-danger');
    }
}

toggleInputMute() {
    // Implementation for input mute
    this.logCAT('Input mute toggled', 'info');
}

toggleOutputMute() {
    // Implementation for output mute
    this.logCAT('Output mute toggled', 'info');
}



// Update audio gain in real-time
updateAudioGain() {
    if (this.gainNode) {
        this.gainNode.gain.value = this.audioGain;
        console.log('Audio gain set to:', this.audioGain, '(' + (20 * Math.log10(this.audioGain)).toFixed(1) + ' dB)');
    }
}

// Update gain display
updateGainDisplay() {
    const gainLevelElement = document.getElementById('audioGainLevel');
    if (gainLevelElement) {
        const gainMultiplier = this.audioGain.toFixed(1);
        const gainDB = this.audioGain > 0 ? (20 * Math.log10(this.audioGain)).toFixed(1) : '-âˆž';
        gainLevelElement.textContent = `${gainMultiplier}x (${gainDB} dB)`;
        
        // Color coding based on gain level
        if (this.audioGain >= 3.0) {
            gainLevelElement.style.color = '#ff4757'; // High gain - red
        } else if (this.audioGain >= 2.0) {
            gainLevelElement.style.color = '#ff9500'; // Medium-high gain - orange  
        } else if (this.audioGain >= 1.5) {
            gainLevelElement.style.color = '#ffff00'; // Medium gain - yellow
        } else {
            gainLevelElement.style.color = '#00ff88'; // Normal gain - green
        }
    }
}
	

         // Add this method to test SWR during transmission
async testSWRDuringTX() {
    if (!this.connected) {
        this.logCAT('Connect radio first', 'error');
        return;
    }
    
    this.logCAT('Testing SWR during transmission...', 'info');
    
    try {
        // Switch to TX mode
        await this.sendCommand('TX');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Request SWR reading
        await this.sendCommand('SW');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Switch back to RX mode
        await this.sendCommand('RX');
        
        this.logCAT('SWR test completed', 'info');
    } catch (error) {
        this.logCAT(`SWR test error: ${error.message}`, 'error');
    }
} 
 

async setFrequencyAndRestoreGain(freqHz) {
                if (!this.connected || !this.writer) return;
 this.lastManualFreqSet = Date.now(); // Record when we sent the command
                try {
                    // 1. Send the command to change the frequency
                    const freqStr = freqHz.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    await this.sendCommand(`${vfoCommand}${freqStr}`);

                    // 2. Immediately send a command to set the AF gain back to the UI's level
                    // A tiny delay ensures the radio processes the frequency change first.
                    setTimeout(() => {
                        if (this.connected) {
                            const scaledVolume = this.volumeToCAT(this.volumeLevel);
                            const gainCommand = `AG${scaledVolume.toString().padStart(3, '0')}`;
                            this.sendCommand(gainCommand);
                        }
                    }, 50); // 50ms delay
                } catch (e) {
                    this.logCAT(`Frequency/Gain Restore Error: ${e.message}`, 'error');
                }
            } 

           
initSpectrumDisplay() {
    this.spectrumCanvas = document.getElementById('spectrumCanvas');
    this.spectrumCtx = this.spectrumCanvas.getContext('2d');

    this.resizeSpectrumCanvas = () => {
        if (this.spectrumCanvas.width !== this.spectrumCanvas.clientWidth ||
            this.spectrumCanvas.height !== this.spectrumCanvas.clientHeight) {
            this.spectrumCanvas.width = this.spectrumCanvas.clientWidth;
            this.spectrumCanvas.height = this.spectrumCanvas.clientHeight;
        }
    };

    const targetPitchSelect = document.getElementById('targetPitch');
    targetPitchSelect.addEventListener('change', (e) => {
        this.targetPitch = parseInt(e.target.value, 10);
        this.logCAT(`Target CW pitch set to ${this.targetPitch} Hz`, 'info');
    });

    this.spectrumCanvas.addEventListener('click', (e) => {
        if (!this.spectrumEnabled || !this.connected) return;

        const rect = this.spectrumCanvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;

        // --- NEW PEAK-DETECTION LOGIC ---
        
        // Define a search window (e.g., +/- 15 pixels) around the click
        const searchRadiusPx = 15;
       const displayBandwidth = this.spectrumBandwidth;
        const audioSampleRate = this.audioContext.sampleRate || 48000;
        const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (displayBandwidth / (audioSampleRate / 2)));
        
        // Convert pixel coordinates to frequency bin indices
        const startBin = Math.floor(((clickX - searchRadiusPx) / this.spectrumCanvas.width) * relevantBins);
        const endBin = Math.floor(((clickX + searchRadiusPx) / this.spectrumCanvas.width) * relevantBins);

        let peakSignal = -1;
        let peakBin = -1;

        // Find the strongest signal peak within the search window
        for (let i = Math.max(0, startBin); i < Math.min(relevantBins, endBin); i++) {
            if (this.frequencyData[i] > peakSignal) {
                peakSignal = this.frequencyData[i];
                peakBin = i;
            }
        }
        
        // If no signal is found in the area, do nothing
        if (peakBin === -1) {
            this.logCAT('No signal peak found near click.', 'error');
            return;
        }

        // Use the frequency of the actual peak for the calculation
        const peakFreq = (peakBin / relevantBins) * displayBandwidth;
        // --- END OF NEW LOGIC ---

        const targetFreq = this.mode === 'CW' ? this.targetPitch : 1500;
        const offset = peakFreq - targetFreq;

        this.logCAT(`Peak found at ${peakFreq.toFixed(0)} Hz. Tuning by ${offset.toFixed(0)} Hz`, 'info');

        const currentFreq = Number(this.frequency);
        const newFrequency = currentFreq + offset;
        this.frequency = Math.round(newFrequency);
        this.updateDisplay();
        this.setFrequencyAndRestoreGain(this.frequency);
    });
}

         startSpectrum() {
    if (!this.audioContext || !this.inputAnalyser) return;

    // This correctly resizes the canvas right before drawing starts.
    this.resizeSpectrumCanvas(); 

    this.spectrumEnabled = true;

    // These lines were missing: they set up the analyzer's resolution 
    // and create the data array needed for drawing.
    this.inputAnalyser.fftSize = 2048; 
    this.frequencyData = new Uint8Array(this.inputAnalyser.frequencyBinCount);

    // This crucial call starts the drawing loop.
    this.drawSpectrum();

    this.logCAT('Spectrum analyzer started', 'info');
}
            drawSpectrum() {
                if (!this.spectrumEnabled) {
                    cancelAnimationFrame(this.spectrumAnimationFrame);
                    return;
                }

                this.spectrumAnimationFrame = requestAnimationFrame(() => this.drawSpectrum());

                this.inputAnalyser.getByteFrequencyData(this.frequencyData);

                this.spectrumCtx.fillStyle = '#10151a'; // Background color
                this.spectrumCtx.fillRect(0, 0, this.spectrumCanvas.width, this.spectrumCanvas.height);

                const barWidth = (this.spectrumCanvas.width / this.inputAnalyser.frequencyBinCount) * 2.5;
                let barHeight;
                let x = 0;

                // Only draw the first part of the spectrum (up to ~3.5 kHz) for relevance
               const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (this.spectrumBandwidth / (this.audioContext.sampleRate / 2)));

               //...
//...
for (let i = 0; i < relevantBins; i++) {
    barHeight = this.frequencyData[i] / 2;
    
    // This new color logic makes weak signals more visible (brighter green).
    const green = Math.min(255, 100 + barHeight * 2);
    this.spectrumCtx.fillStyle = `rgb(0, ${green}, 80)`;
    this.spectrumCtx.fillRect(x, this.spectrumCanvas.height - barHeight, barWidth, barHeight);
    x += barWidth + 1;
}
//...
//...
            }
		   
		   
		 initAutotune() {
                const autotuneBtn = document.getElementById('autotuneBtn');
                const manualScanBtn = document.getElementById('manualScanBtn'); // Get the new button

                autotuneBtn.addEventListener('click', () => {
                    this.autotuneEnabled = !this.autotuneEnabled;
                    if (this.autotuneEnabled) {
                        autotuneBtn.classList.add('autotune-active');
                        autotuneBtn.textContent = 'AUTOTUNE ON';
                        this.logCAT('Autotune ENABLED.', 'info');
                    } else {
                        autotuneBtn.classList.remove('autotune-active');
                        autotuneBtn.textContent = 'AUTOTUNE OFF';
                        this.logCAT('Autotune DISABLED.', 'info');
                    }
                });

             // Add this event listener for the new button
manualScanBtn.addEventListener('click', async (event) => { // Add 'event' to the function
    const button = event.currentTarget; // Get the button that was clicked

    // --- Add the flash effect ---
    button.classList.add('btn-flash');
    setTimeout(() => {
        button.classList.remove('btn-flash');
    }, 300); // The flash will last for 300 milliseconds
    // --- End of flash effect code ---

    // Check if the audio stream is already active
    if (this.isAudioStreaming) {
        // If it is, just perform the scan immediately
        this.performAutotuneScan();
    } else {
        // If not, try to start the stream first
        this.logCAT('Audio stream not active. Starting it for manual scan...', 'info');
        await this.startAudioStream(); // Await the stream start

        // After attempting to start, check if it was successful before scanning
        if (this.isAudioStreaming) {
            // A brief delay ensures the spectrum analyzer has data before the scan runs
            setTimeout(() => {
                this.performAutotuneScan();
            }, 250); // 250ms delay
        } else {
            this.logCAT('Failed to start audio stream. Cannot perform scan.', 'error');
        }
    }
});
            }

            triggerAutotuneScan() {
                // If the feature is disabled or the audio stream isn't running, do nothing.
                if (!this.autotuneEnabled || !this.spectrumEnabled) return;

                // Reset the timer every time the user moves the knob.
                if (this.autotuneScanTimeout) {
                    clearTimeout(this.autotuneScanTimeout);
                }

                // After the user stops tuning for autotuneDebounceTime, start the scan.
                this.autotuneScanTimeout = setTimeout(() => {
                    this.performAutotuneScan();
                }, this.autotuneDebounceTime);
            }

   performAutotuneScan() {
            if (!this.autotuneEnabled && !this.spectrumEnabled && !this.connected) return;

            const isSSB = (this.mode === 'USB' || this.mode === 'LSB');
            const isCW = (this.mode === 'CW');

            if (!isSSB && !isCW) {
                this.logCAT('Autotune: Only available for CW and SSB modes.', 'info');
                return;
            }

            this.logCAT(`Autotune: Scanning for ${this.mode} signal...`, 'info');

            const scanDuration = 1000;
            const sampleInterval = 50;
            const samplesToTake = scanDuration / sampleInterval;
            
            let samplesTaken = 0;
            const averageSpectrum = new Float32Array(this.inputAnalyser.frequencyBinCount).fill(0);

            const scanner = setInterval(() => {
                if (!this.autotuneEnabled && samplesTaken > 0) {
                    clearInterval(scanner);
                    return;
                }

                this.inputAnalyser.getByteFrequencyData(this.frequencyData);
                for (let i = 0; i < this.frequencyData.length; i++) {
                    averageSpectrum[i] += this.frequencyData[i];
                }
                
                samplesTaken++;

                if (samplesTaken >= samplesToTake) {
                    clearInterval(scanner);

                    for (let i = 0; i < averageSpectrum.length; i++) {
                        averageSpectrum[i] /= samplesToTake;
                    }

                    const audioSampleRate = this.audioContext.sampleRate || 48000;
                    const analysisBandwidth = 3500;
                    const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (analysisBandwidth / (audioSampleRate / 2)));
                    let peakFreq = 0;

                    if (isCW) {
                        const cwSignalToNoiseRatio = 15;
                        let noiseSum = 0;
                        for (let i = 0; i < relevantBins; i++) noiseSum += averageSpectrum[i];
                        const dynamicThreshold = (noiseSum / relevantBins) + cwSignalToNoiseRatio;
                        
                        let peakBin = -1, peakSignal = 0;
                        for (let i = 0; i < relevantBins; i++) {
                            if (averageSpectrum[i] > peakSignal) {
                                peakSignal = averageSpectrum[i];
                                peakBin = i;
                            }
                        }
                        if (peakBin !== -1 && peakSignal > dynamicThreshold) {
                            peakFreq = (peakBin / relevantBins) * analysisBandwidth;
                        }
                    } else if (isSSB) {
                        let totalPower = 0;
                        for (let i = 0; i < relevantBins; i++) totalPower += averageSpectrum[i];
                        const averagePower = totalPower / relevantBins;
                        const signalThreshold = (averagePower * 1.5) + 5;

                        let lowEdgeBin = -1, highEdgeBin = -1;
                        for (let i = 0; i < relevantBins; i++) {
                            if (averageSpectrum[i] > signalThreshold) {
                                if (lowEdgeBin === -1) lowEdgeBin = i;
                                highEdgeBin = i;
                            }
                        }

                        if (lowEdgeBin !== -1 && (highEdgeBin - lowEdgeBin) > 10) {
                            const lowEdgeFreq = (lowEdgeBin / relevantBins) * analysisBandwidth;
                            const highEdgeFreq = (highEdgeBin / relevantBins) * analysisBandwidth;
                            peakFreq = (lowEdgeFreq + highEdgeFreq) / 2;
                        }
                    }

                    if (peakFreq > 0) {
                        const targetCenterFreq = isCW ? this.targetPitch : 1500;
                        const floatingOffset = peakFreq - targetCenterFreq;
                        const offset = Math.round(floatingOffset);

                        if (Math.abs(offset) > 25) {
                            this.logCAT(`Autotune (${this.mode}): Found signal at ${peakFreq.toFixed(0)} Hz. Tuning by ${offset} Hz.`, 'info');
                            const currentFreq = Number(this.frequency);
                            
                            let newFrequency;
                            if (this.mode === 'LSB') {
                                newFrequency = currentFreq - offset;
                            } else { 
                                newFrequency = currentFreq + offset;
                            }
                            
                            this.frequency = newFrequency;
                            this.updateDisplay();
                            this.setFrequencyAndRestoreGain(this.frequency);
                        } else {
                            this.logCAT(`Autotune (${this.mode}): Signal already tuned.`, 'info');
                        }
                    } else {
                        this.logCAT(`Autotune (${this.mode}): No stable signal found.`, 'info');
                    }
                }
            }, sampleInterval);
        }
	//------------------------------------------------		
			
            cleanup() {
                if (this.timeSyncInterval) clearInterval(this.timeSyncInterval);
                if (this.clockUpdateInterval) clearInterval(this.clockUpdateInterval);
                if (this.timeCommandTimeout) clearTimeout(this.timeCommandTimeout);
                
                if (this.boundHandleTuningHoverKeys) {
                    document.removeEventListener('keydown', this.boundHandleTuningHoverKeys);
                }
            }
        }
		
		

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new QMXInterface();
            } catch (error) {
                console.error('Failed to initialize QMX Interface:', error);
            }
        });


   </script>

<div class="modal-overlay" id="modalOverlay"></div>

<!-- Frequency Input Modal -->
<div class="freq-input-modal" id="freqInputModal">
    <div class="freq-modal-content">
        <h3>Direct Frequency Entry</h3>
        
        <!-- Format buttons -->
        <div class="freq-format-buttons">
            <button class="freq-format-btn active" data-format="mhz">MHz</button>
            <button class="freq-format-btn" data-format="khz">kHz</button>
            <button class="freq-format-btn" data-format="hz">Hz</button>
        </div>
        
        <!-- Input field -->
        <input type="text" id="freqDisplayInput" class="freq-display-input" placeholder="Enter frequency...">
        <div id="freqError" class="freq-error"></div>
        
        <!-- Keypad -->
        <div class="freq-keypad">
            <button class="freq-key" data-key="1">1</button>
            <button class="freq-key" data-key="2">2</button>
            <button class="freq-key" data-key="3">3</button>
            <button class="freq-key" data-key="4">4</button>
            <button class="freq-key" data-key="5">5</button>
            <button class="freq-key" data-key="6">6</button>
            <button class="freq-key" data-key="7">7</button>
            <button class="freq-key" data-key="8">8</button>
            <button class="freq-key" data-key="9">9</button>
            <button class="freq-key" data-key="0">0</button>
            <button class="freq-key" data-key=".">.</button>
            <button class="freq-key" data-key="backspace">âŒ«</button>
        </div>
        
        <!-- Action buttons -->
        <div class="freq-modal-buttons">
            <button class="btn btn-primary" id="freqSetBtn">Set</button>
            <button class="btn btn-secondary" id="freqClearBtn">Clear</button>
            <button class="btn btn-secondary" id="freqCancelBtn">Cancel</button>
        </div>
    </div>
</div>

<!-- Permanent Frequency Input Panel -->
<div id="freqInputPermanentPanel" class="panel" style="display: none;">
    <h3>Direct Frequency Entry</h3>
    
    <!-- Mode selector -->
    <div class="control-group" style="margin-bottom: 15px;">
        <label>Input Mode</label>
        <select id="freqInputMode">
            <option value="popup">Click LCD (Popup)</option>
            <option value="permanent">Always Visible</option>
        </select>
    </div>
    
    <!-- Format buttons -->
    <div class="freq-format-buttons">
        <button class="freq-format-btn active" data-target="permanent" data-format="mhz">MHz</button>
        <button class="freq-format-btn" data-target="permanent" data-format="khz">kHz</button>
        <button class="freq-format-btn" data-target="permanent" data-format="hz">Hz</button>
    </div>
    
    <!-- Input field -->
    <input type="text" id="freqDisplayInputPerm" class="freq-display-input" placeholder="Enter frequency...">
    <div id="freqErrorPerm" class="freq-error"></div>
    
    <!-- Keypad -->
    <div class="freq-keypad">
        <button class="freq-key" data-target="permanent" data-key="1">1</button>
        <button class="freq-key" data-target="permanent" data-key="2">2</button>
        <button class="freq-key" data-target="permanent" data-key="3">3</button>
        <button class="freq-key" data-target="permanent" data-key="4">4</button>
        <button class="freq-key" data-target="permanent" data-key="5">5</button>
        <button class="freq-key" data-target="permanent" data-key="6">6</button>
        <button class="freq-key" data-target="permanent" data-key="7">7</button>
        <button class="freq-key" data-target="permanent" data-key="8">8</button>
        <button class="freq-key" data-target="permanent" data-key="9">9</button>
        <button class="freq-key" data-target="permanent" data-key="0">0</button>
        <button class="freq-key" data-target="permanent" data-key=".">.</button>
        <button class="freq-key" data-target="permanent" data-key="backspace">âŒ«</button>
    </div>
    
    <!-- Action buttons -->
    <div class="freq-modal-buttons">
        <button class="btn btn-primary" id="freqSetBtnPerm">Set</button>
        <button class="btn btn-secondary" id="freqClearBtnPerm">Clear</button>
    </div>
</div>

</body>
</html>