<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta property="og:title" content="QMX Transceiver Interface">
<meta property="og:description" content="Advanced web-based control interface for QMX QRP transceivers">
<meta property="og:image" content="https://Sparks72.github.io/QMX-new-GUI/screenshot1.png">
<meta property="og:url" content="https://Sparks72.github.io/QMX-new-GUI/">
<meta name="twitter:card" content="summary_large_image">
    <title>QMX Transceiver Interface</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        :root {
            --transceiver-bg: #2c3e50;
            --panel-bg: rgba(0, 0, 0, 0.2);
            --display-bg: #1a252f;
            --display-text: #00ff88;
            --accent-color: #00ff88;
            --knob-color: #bdc3c7;
            --knob-highlight: #ecf0f1;
            --button-bg: #34495e;
            --button-hover: #4a627a;
            --button-active: #00ff88;
            --font-color: #ecf0f1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1f2937;
            color: var(--font-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            user-select: none;
        }

        .transceiver-container {
            width: 1400px;
            height: 750px;
            background: linear-gradient(145deg, #3a4b60, #233140);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.5), inset 0 2px 2px rgba(255,255,255,0.1);
            border: 2px solid #1d2a38;
            padding: 20px;
            display: flex;
            gap: 20px;
            overflow: hidden;
        }

        /* Sections */
        .left-panel, .center-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
        }
        .left-panel { flex: 1; }
        .center-panel { flex: 1.5; }
        .right-panel { flex: 1.2; }

        /* Custom Scrollbar */
        .left-panel::-webkit-scrollbar, .center-panel::-webkit-scrollbar, .right-panel::-webkit-scrollbar { width: 8px; }
        .left-panel::-webkit-scrollbar-track, .center-panel::-webkit-scrollbar-track, .right-panel::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        .left-panel::-webkit-scrollbar-thumb, .center-panel::-webkit-scrollbar-thumb, .right-panel::-webkit-scrollbar-thumb { background: var(--button-bg); border-radius: 4px; }
        .left-panel::-webkit-scrollbar-thumb:hover, .center-panel::-webkit-scrollbar-thumb:hover, .right-panel::-webkit-scrollbar-thumb:hover { background: var(--button-hover); }

        .panel {
            background: var(--panel-bg);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel h3 {
            margin-top: 0; margin-bottom: 15px; font-size: 1em; color: var(--accent-color);
            text-shadow: 0 0 5px rgba(0,255,136,0.5); cursor: grab; padding-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .panel h3:active { cursor: grabbing; }

        .sortable-ghost { opacity: 0.4; background: var(--accent-color); }
        .sortable-drag { opacity: 0.9; transform: rotate(1deg); }
        .panels-locked .panel h3 { cursor: not-allowed !important; opacity: 0.8; position: relative; }
        .panels-locked .panel h3::after { content: " 🔒"; font-size: 0.8em; opacity: 0.6; margin-left: 5px; }

        .frequency-display.lcd-panel {
            background: var(--display-bg); border-radius: 10px; padding: 15px 20px; text-align: left;
            border: 2px solid var(--accent-color); box-shadow: 0 0 20px rgba(0, 255, 136, 0.3), inset 0 0 10px rgba(0,0,0,0.5);
            min-height: 100px; display: flex; flex-direction: column; justify-content: center; cursor: pointer; transition: all 0.3s ease;
        }
        .lcd-row { font-family: 'Courier New', monospace; color: var(--display-text); text-shadow: 0 0 8px var(--accent-color); }
        #lcdRow1 { font-size: 2.2em; font-weight: bold; }
        #lcdRow2 { font-size: 1.3em; opacity: 0.8; }

        .tuning-knob-container { width: 220px; height: 220px; position: relative; margin: 10px auto; cursor: grab; }
        .tuning-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 2px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.15) 0deg, rgba(0, 0, 0, 0.1) 5deg, rgba(255, 255, 255, 0.15) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 2%, #c0c0c0 4%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 30% 30%, 100% 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

/* Add a small triangle tip */
.tuning-knob::before {
    content: "";
    position: absolute;
    width: 0;
    height: 0;
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    border-bottom: 8px solid #333;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 4;
}

     /* Option C: Very thin line with small triangle tip */
.tuning-knob::after {
    content: "";
    position: absolute;
    width: 5px !important;
    height: 80px;
    background: linear-gradient(to top, #333 0%, #333 85%, transparent 85%, transparent 100%) !important;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;
    transition: background-color 0.2s ease;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}
        .tuning-knob-center {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob:hover::after {
            background-color: #00ff88 !important;
        }
        
        /* Styles for frequency markings, required by the script */
        .frequency-markings { position: absolute; width: 280px; height: 280px; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 0; }
        .frequency-mark { position: absolute; background: rgba(255, 255, 255, 0.6); transform-origin: center; }
        .frequency-mark.major { width: 3px; height: 20px; background: rgba(0, 255, 136, 0.8); }
        .frequency-mark.minor { width: 1px; height: 10px; background: rgba(255, 255, 255, 0.4); }

        .btn { padding: 10px 15px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; font-size: 0.9em; font-weight: bold; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; background: var(--button-bg); color: var(--font-color); }
        .btn:hover { background: var(--button-hover); transform: translateY(-1px); }
        .btn-primary { background: var(--button-active); color: #000; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
        .btn-secondary { background: var(--button-bg); }
        .btn-danger { background: linear-gradient(45deg, #ff4757, #ff3838); color: #fff; }
/* --- START: Scan Button Flash Style --- */
.btn-flash {
    background: var(--accent-color) !important;
    color: #000 !important;
    box-shadow: 0 0 15px var(--accent-color) !important;
    transition: background-color 0.05s ease, color 0.05s ease;
}
/* --- END: Scan Button Flash Style --- */
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .mode-buttons, .band-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .band-buttons { grid-template-columns: repeat(3, 1fr); }
        .mode-btn { padding: 10px; border: 2px solid rgba(255, 255, 255, 0.3); background: rgba(255, 255, 255, 0.1); color: #fff; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-weight: bold; text-align:center;}
        .mode-btn.active { background: linear-gradient(45deg, #00ff88, #00ccff); color: #000; border-color: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.5); }
        
        select { width: 100%; padding: 8px; background: rgba(0,0,0,0.3); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; }
        select option { background: #1a1a2e; }

        .meter { height: 25px; background: #111; border-radius: 5px; padding: 5px; border: 1px solid rgba(255,255,255,0.3); position: relative; overflow: hidden; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5); }
        .meter-bar { height: 100%; background: #222; border-radius: 5px; }
        .meter-indicator { position: absolute; top: 0; left: 0; height: 100%; width: 0; border-radius: 5px; transition: width 0.3s ease; }
        #sMeter { background: linear-gradient(90deg, #00ff88 0%, #ffff00 70%, #ff4757 100%); }
        #swrMeter { background: linear-gradient(90deg, #00ff88 0%, #ffff00 50%, #ff4757 100%); }

        .knobs-row {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    margin-top: 10px;
    align-items: end; /* Add this line */
}
        .knob-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .knob-group label { font-size: 0.8em; opacity: 0.8; text-transform: uppercase; }
        .volume-knob-container { width: 70px; height: 70px; cursor: grab; }
        .volume-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 1px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.1) 0deg, rgba(0, 0, 0, 0.07) 5deg, rgba(255, 255, 255, 0.1) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 1%, #c0c0c0 2%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 20% 20%, 100% 100%;
        }

        .volume-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 10%, rgba(0, 0, 0, 0.03) 10.5%, transparent 11%);
            z-index: 1;
        }

  /* Volume knob pointer - 5px clock style to match tuning knob */
.volume-knob::after {
    content: "";
    position: absolute;
    width: 5px !important;
    height: 30px;  /* Shorter than tuning knob since volume knobs are smaller */
    background-color: #333 !important;
    border-radius: 2px 2px 0 0;  /* Clock-hand style with rounded base */
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;
    transition: background-color 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
	
	
}

        .volume-knob-center {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
        }

        .volume-knob:hover::after {
            background-color: #00ff88 !important;
        }

        .knob-level { font-family: "Courier New", monospace; font-size: 0.9rem; }
        
        .memory-buttons { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 10px; }
        .memory-btn { padding: 8px 4px; border: 1px solid rgba(255,255,255,0.3); background: var(--button-bg); color: #fff; border-radius: 4px; font-size: 0.8em; min-height: 45px; text-align: center; }
        .memory-btn.memory-occupied { background: rgba(0,255,136,0.2); border-color: rgba(0,255,136,0.5); color: #00ff88; }
        .memory-btn.memory-selected { background: var(--button-active); color: #000; }
        .memory-label { font-size: 0.7em; display: block; margin-top: 2px; color: var(--accent-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .cat-log { background: #000; border-radius: 8px; padding: 10px; height: 120px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.8em; }
        .cat-log-entry.tx { color: #00ff88; }
        .cat-log-entry.rx { color: #00ccff; }
        .cat-log-entry.error { color: #ff4757; }
        
        .qso-inputs-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .qso-inputs-grid input, .qso-info-bar, .log-management input { width: 100%; padding: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; background: rgba(0,0,0,0.2); color: #fff; box-sizing: border-box; }
        .qth-group, .comments-group { grid-column: 1 / -1; }
        .qso-log-table { background: #000; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; display: flex; flex-direction: column; flex-grow: 1; min-height: 150px; }
        .log-header, .log-row { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 8px 10px; }
        .log-header { background: rgba(0,255,136,0.2); font-weight: bold; font-size: 0.8em;}
        .log-body { overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.9em; flex-grow: 1; }
        .log-row { border-bottom: 1px solid rgba(255,255,255,0.1); }

        .audio-meter-bar { height: 10px; background: #222; border-radius: 5px; position: relative; overflow: hidden; border: 1px solid rgba(255,255,255,0.3); }
        .audio-meter-indicator { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--accent-color); transition: width 0.1s ease; }
        .audio-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .audio-device-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
        
        .rit-status-display { background: #000; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; padding: 10px; margin-bottom: 15px; display: flex; justify-content: space-between; }
        .rit-status-display.active { border-color: var(--accent-color); }
        .rit-status.active { color: var(--accent-color); }
        .rit-offset-value.positive { color: #00ff88; }
        .rit-offset-value.negative { color: #ff9500; }
        
        .panel-lock-controls { text-align: center; margin-bottom: -10px; position: relative; z-index: 10;}
        #panelLockToggle { padding: 6px 12px; font-size: 0.8em; border-radius: 15px; }
        
        .status-bar { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--panel-bg); border-radius: 10px; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; background: #ff4757; }
        .status-dot.connected { background: var(--accent-color); }

        /* Add missing styles for step size dropdown */
        .step-panel { margin-bottom: 15px; }
        .step-panel select { width: 100%; }
    
	/* Frequency Input Modal Styles */
.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
}

.modal-overlay.active {
    display: flex;
    justify-content: center;
    align-items: center;
}

.freq-input-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--transceiver-bg);
    border: 2px solid var(--accent-color);
    border-radius: 15px;
    padding: 20px;
    z-index: 1001;
    min-width: 300px;
    max-width: 90vw; /* Prevent overflow on small screens */
    max-height: 90vh; /* Prevent overflow vertically */
    overflow-y: auto; /* Add scroll if needed */
}


.freq-input-modal.active {
    display: block;
}

.freq-modal-content h3 {
    text-align: center;
    margin-bottom: 15px;
    color: var(--accent-color);
}

.freq-format-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
}

.freq-format-btn {
    padding: 8px 16px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: var(--button-bg);
    color: var(--font-color);
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.freq-format-btn.active {
    background: var(--accent-color);
    color: #000;
}

.freq-display-input {
    width: 100%;
    padding: 12px;
    font-size: 1.2em;
    text-align: center;
    background: var(--display-bg);
    color: var(--display-text);
    border: 2px solid var(--accent-color);
    border-radius: 8px;
    margin-bottom: 10px;
    font-family: 'Courier New', monospace;
}

.freq-error {
    color: #ff4757;
    font-size: 0.9em;
    text-align: center;
    margin-bottom: 10px;
    min-height: 20px;
}

.freq-keypad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 15px;
}

.freq-key {
    padding: 12px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: var(--button-bg);
    color: var(--font-color);
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.1em;
    transition: all 0.3s ease;
}

.freq-key:hover {
    background: var(--button-hover);
}

.freq-modal-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
}

.freq-modal-buttons .btn {
    flex: 1;
}
/* Add these modal styles to your CSS */
.memory-edit-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--transceiver-bg);
    border: 2px solid var(--accent-color);
    border-radius: 15px;
    padding: 20px;
    z-index: 1001;
    min-width: 300px;
}

.memory-edit-modal.active {
    display: block;
}

.modal-content h3 {
    text-align: center;
    margin-bottom: 15px;
    color: var(--accent-color);
}

.modal-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    margin-top: 15px;
}

.modal-buttons .btn {
    flex: 1;
}


/* Keyer Mode Toggle Styles */
.keyer-mode-toggle {
    margin-bottom: 8px;
    display: flex;
    justify-content: center;
}

.toggle-switch {
    position: relative;
    width: 96px;
    height: 24px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
}

.toggle-switch:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.4);
}

.toggle-slider {
   position: absolute;
    top: 2px;
    left: 2px;
    width: 36px; /* Increased length */
    height: 18px;
    background: linear-gradient(45deg, #ff4757, #ff6b7a);
    border-radius: 9px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 2;
}

.toggle-switch.bug .toggle-slider {
    left: 52px; /* Adjusted for new width */
    background: linear-gradient(45deg, #00ff88, #00ccff);
}

.toggle-label {
    position: absolute;
    font-size: 0.7em;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.6);
    transition: all 0.3s ease;
    z-index: 1;
    pointer-events: none;
}

.toggle-label.left {
    left: 8px;
}

.toggle-label.right {
    right: 8px;
}

.toggle-switch:not(.bug) .toggle-label.left {
    color: #fff;
    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
}

.toggle-switch.bug .toggle-label.right {
    color: #fff;
    text-shadow: 0 0 3px rgba(0, 255, 136, 0.8);
}

/* Make the keyer knob less prominent when in STRAIGHT mode */
.keyer-straight .volume-knob {
    opacity: 0.5;
    pointer-events: none;
}

.keyer-straight .knob-level {
    opacity: 0.6;
}
	
	
.rit-status-display.active {
    border-color: #00ff88;
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
}

.rit-indicator {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

.rit-label {
    font-size: 0.8em;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.rit-status {
    font-size: 1.1em;
    font-weight: bold;
    color: #ff4757;
    text-transform: uppercase;
}

.rit-status.active {
    color: #00ff88;
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
}

.rit-offset-display {
    text-align: right;
}

.rit-offset-value {
    font-family: 'Courier New', monospace;
    font-size: 1.2em;
    font-weight: bold;
    color: #fff;
}

.rit-offset-value.positive {
    color: #00ff88;
}

.rit-offset-value.negative {
    color: #ff9500;
}

.rit-controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.rit-adjust-buttons {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}

.rit-adjust-buttons .btn {
    padding: 8px 4px;
    font-size: 0.8em;
    min-height: 35px;
}

.rit-fine-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.rit-fine-control label {
    font-size: 0.8em;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.rit-knob-container {
    width: 60px;
    height: 60px;
    cursor: grab;
    user-select: none;
}

.rit-knob-container:active {
    cursor: grabbing;
}

.rit-knob-container .volume-knob {
    border: 1px solid #666;
}

.rit-knob-container .volume-knob:hover::after {
    background-color: #00ff88 !important;
}

#ritKnob.rit-active::after {
    background-color: #00ff88 !important;
}

/* RIT Active State */
.panel#ritPanel.rit-active {
    border-color: #00ff88;
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
}

.panel#ritPanel.rit-active h3 {
    color: #00ff88;
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
}

/* Responsive RIT */
@media (max-width: 599px) {
    .rit-adjust-buttons {
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
    }
    
    .rit-adjust-buttons .btn {
        font-size: 0.7em;
        padding: 6px 2px;
        min-height: 32px;
    }
    
    .rit-knob-container {
        width: 50px;
        height: 50px;
    }
}	

/* Adds more pronounced radial lines to the smaller control knobs */
.volume-knob::before {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    box-shadow: inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3);
    /* Darker and thicker lines for better visibility */
   background: repeating-conic-gradient(
        from 0deg,
        rgba(0, 0, 0, 0.4) 0deg 0.7deg,   /* Darker, thicker line */
        transparent 0.7deg 10deg         /* Gap between lines */
    );
    z-index: -1;
}

/* --- START: Spectrum Display Styles --- */
#spectrumPanel {
    background: #000; /* Dark background for better contrast */
}

.spectrum-container {
    width: 100%;
    height: 120px;
    background-color: #10151a;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 5px;
    margin-bottom: 10px;
    cursor: crosshair;
}

#spectrumCanvas {
    width: 100%;
    height: 100%;
    display: block;
}

.spectrum-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    font-size: 0.9em;
}

.spectrum-controls select {
    width: 100px;
}

/* CW DSP Filter Styles */
.cw-dsp-panel {
    background: rgba(0,255,136,0.1);
    border: 1px solid rgba(0,255,136,0.3);
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 10px;
}

.cw-dsp-header {
    text-align: center;
    margin-bottom: 6px;
    color: var(--accent-color);
    font-weight: bold;
    font-size: 0.9em;
}

.cw-dsp-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.cw-dsp-status {
    text-align: center;
    font-size: 0.8em;
    color: #888;
}

.cw-dsp-status.active {
    color: var(--accent-color);
}

/* --- END: Spectrum Display Styles --- */
/* --- START: Autotune Button Style --- */
.btn.autotune-active {
    background: var(--button-active);
    color: #000;
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
    font-weight: bold;
}
/* --- END: Autotune Button Style --- */
/* 1. ANIMATED LCD SCANLINES - Add to CSS */
.frequency-display.lcd-panel::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 255, 136, 0.03) 2px,
        rgba(0, 255, 136, 0.03) 4px
    );
    pointer-events: none;
    animation: scanlines 2s linear infinite;
}

@keyframes scanlines {
    0% { transform: translateY(0); }
    100% { transform: translateY(4px); }
}

/* 2. PULSING POWER INDICATOR */
.status-dot.connected {
    animation: pulse-power 2s ease-in-out infinite;
    box-shadow: 0 0 10px var(--accent-color);
}

@keyframes pulse-power {
    0%, 100% { 
        opacity: 1; 
        transform: scale(1);
        box-shadow: 0 0 10px var(--accent-color);
    }
    50% { 
        opacity: 0.7; 
        transform: scale(1.1);
        box-shadow: 0 0 20px var(--accent-color);
    }
}

/* 3. GLOWING TRANSMISSION INDICATOR */
.btn-danger {
    position: relative;
    overflow: visible;
}

.btn-danger::before {
    content: "";
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, #ff4757, #ff3838, #ff4757);
    border-radius: 8px;
    z-index: -1;
    animation: tx-glow 0.5s ease-in-out infinite alternate;
    opacity: 0;
}

.btn-danger.active::before {
    opacity: 1;
}

@keyframes tx-glow {
    from { 
        box-shadow: 0 0 5px #ff4757;
        transform: scale(1);
    }
    to { 
        box-shadow: 0 0 25px #ff4757, 0 0 35px #ff4757;
        transform: scale(1.02);
    }
}

/* 4. RAINBOW SPECTRUM BORDER FOR ACTIVE BAND */
.band-btn.active {
    position: relative;
    overflow: hidden;
}

.band-btn.active::before {
    content: "";
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, 
        #ff0000, #ff8000, #ffff00, #80ff00, 
        #00ff00, #00ff80, #00ffff, #0080ff,
        #0000ff, #8000ff, #ff00ff, #ff0080, #ff0000
    );
    background-size: 400% 400%;
    border-radius: 8px;
    z-index: -1;
    animation: rainbow-border 3s ease infinite;
}

@keyframes rainbow-border {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

/* 5. PARTICLE EFFECTS FOR FREQUENCY CHANGES */
.frequency-particle {
    position: absolute;
    width: 3px;
    height: 3px;
    background: var(--accent-color);
    border-radius: 50%;
    pointer-events: none;
    animation: frequency-particle 1s ease-out forwards;
}

@keyframes frequency-particle {
    0% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    100% {
        opacity: 0;
        transform: scale(0) translateY(-50px);
    }
}

/* 6. ANIMATED METER BARS WITH BETTER GRADIENTS */
.meter-indicator {
    position: relative;
    overflow: hidden;
}

.meter-indicator::after {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.4),
        transparent
    );
    animation: meter-shine 2s infinite;
}

@keyframes meter-shine {
    0% { left: -100%; }
    100% { left: 100%; }
}

/* 7. GLOWING KNOB INDICATORS WHEN ACTIVE */
.tuning-knob.adjusting {
    box-shadow: 
        0 12px 24px rgba(0, 0, 0, 0.4),
        inset 0 4px 6px rgba(255, 255, 255, 0.8),
        inset 0 -4px 6px rgba(0, 0, 0, 0.3),
        0 0 30px var(--accent-color),
        0 0 60px var(--accent-color);
    animation: knob-active 0.3s ease-out;
}

@keyframes knob-active {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(0deg) scale(1.05); }
    100% { transform: rotate(0deg) scale(1); }
}

/* 9. MATRIX-STYLE DIGITAL RAIN FOR BACKGROUND (SUBTLE) */
.transceiver-container::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
        radial-gradient(circle at 20% 20%, rgba(0, 255, 136, 0.02) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(0, 255, 136, 0.02) 0%, transparent 50%),
        radial-gradient(circle at 40% 70%, rgba(0, 255, 136, 0.01) 0%, transparent 50%);
    animation: matrix-bg 10s linear infinite;
    pointer-events: none;
    z-index: 0;
}

@keyframes matrix-bg {
    0%, 100% { opacity: 0.3; transform: translateY(0); }
    50% { opacity: 0.1; transform: translateY(-5px); }
}

/* 10. ENHANCED BUTTON PRESS EFFECTS */
.btn:active {
    transform: translateY(1px) scale(0.98);
    box-shadow: 
        0 2px 4px rgba(0,0,0,0.3),
        inset 0 2px 4px rgba(0,0,0,0.2);
    transition: all 0.1s ease;
}

/* SIMPLER HOLOGRAPHIC PANEL BORDERS */
.panel {
    position: relative;
    border: 1px solid rgba(0, 255, 136, 0.3);
    box-shadow: 
        0 0 10px rgba(0, 255, 136, 0.1),
        inset 0 0 10px rgba(0, 255, 136, 0.05);
}

.panel::before {
    content: "";
    position: absolute;
    top: -1px;
    left: -1px;
    right: -1px;
    bottom: -1px;
    background: linear-gradient(45deg, 
        rgba(0, 255, 136, 0.4), 
        transparent 30%,
        rgba(0, 255, 136, 0.2) 50%,
        transparent 70%,
        rgba(0, 255, 136, 0.4)
    );
    background-size: 200% 200%;
    border-radius: 10px;
    z-index: -1;
    animation: holo-border 3s ease-in-out infinite;
    pointer-events: none;
}

@keyframes holo-border {
    0%, 100% { 
        background-position: 0% 0%; 
        opacity: 0.6;
    }
    50% { 
        background-position: 100% 100%; 
        opacity: 0.9;
    }
}

@keyframes flyFrequency {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
        left: calc(50vw);
        top: calc(50vh - 100px);
    }
    100% {
        opacity: 0.8;
        transform: translate(-50%, -50%) scale(0.9);
        left: var(--end-x);
        top: var(--end-y);
    }
}

@keyframes vfoSwapPulse {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    50% {
        transform: scale(1.05);
        box-shadow: 0 0 25px rgba(0, 255, 136, 0.8);
    }
}

@keyframes slideInFromRight {
    from {
        right: -300px;
        opacity: 0;
    }
    to {
        right: 20px;
        opacity: 1;
    }
}

@keyframes memoryTeleport {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    30% {
        opacity: 0.3;
        transform: translate(-50%, -50%) scale(0.1);
    }
    70% {
        opacity: 0.3;
        transform: translate(-50%, -50%) scale(0.1);
        left: var(--target-x);
        top: var(--target-y);
    }
    100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        left: var(--target-x);
        top: var(--target-y);
    }
}

@keyframes copyFrequency {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        filter: brightness(1);
    }
    25% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.3);
        filter: brightness(1.5);
    }
    75% {
        opacity: 0.9;
        transform: translate(-50%, -50%) scale(1.1);
        left: var(--target-x);
        top: var(--target-y);
        filter: brightness(1.2);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
        left: var(--target-x);
        top: var(--target-y);
        filter: brightness(0.8);
    }
}

@keyframes vfoCopySource {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    25% {
        transform: scale(1.1);
        box-shadow: 0 0 25px rgba(0, 255, 136, 0.8);
    }
    50% {
        transform: scale(0.95);
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
    }
}

@keyframes vfoCopyTarget {
    0% {
        transform: scale(1);
        box-shadow: 0 0 5px rgba(0, 200, 255, 0.2);
    }
    60% {
        transform: scale(1);
        box-shadow: 0 0 5px rgba(0, 200, 255, 0.2);
    }
    80% {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 200, 255, 0.6);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 15px rgba(0, 200, 255, 0.4);
    }
}

@keyframes tuningIndicator {
    0% {
        opacity: 1;
        transform: translateY(-50%) scale(1);
    }
    50% {
        opacity: 1;
        transform: translateY(-50%) scale(1.3);
    }
    100% {
        opacity: 0;
        transform: translateY(-80%) scale(0.8);
    }
}

.lcd-row {
    transition: text-shadow 0.1s ease, transform 0.1s ease;
}

@keyframes stepIndicator {
    0% {
        opacity: 1;
        transform: translateY(-50%) scale(1);
    }
    70% {
        opacity: 1;
        transform: translateY(-50%) scale(1.1);
    }
    100% {
        opacity: 0;
        transform: translateY(-50%) scale(0.9);
    }
}

@keyframes freqChange {
    0% {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px) scale(0.8);
    }
}

#powerMeter {
    background: linear-gradient(90deg, #00ff88 0%, #ffff00 70%, #ff4757 100%);
}

/* Optional: Different color scheme for power meter */
#powerMeter.alt-colors {
    background: linear-gradient(90deg, #00ccff 0%, #00ff88 50%, #ffff00 80%, #ff4757 100%);
}

/* Voice Keyer specific styles */
.voice-msg-btn {
    padding: 8px 4px;
    font-size: 0.75em;
    min-height: 40px;
    border: 1px solid rgba(255,255,255,0.3);
    background: var(--button-bg);
    color: #fff;
    border-radius: 4px;
    text-align: center;
    transition: all 0.3s ease;
}

.voice-msg-btn.voice-msg-occupied {
    background: rgba(0,255,136,0.2);
    border-color: rgba(0,255,136,0.5);
    color: #00ff88;
}

.voice-msg-btn.voice-msg-active {
    background: var(--button-active);
    color: #000;
    border-color: #00ff88;
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
}

.voice-msg-btn:hover {
    background: var(--button-hover);
    transform: translateY(-1px);
}

/* Recording state animation */
.voice-keyer-recording #voiceKeyerRecord {
    animation: recordPulse 1s ease-in-out infinite;
}

@keyframes recordPulse {
    0%, 100% { 
        background: #ff4757; 
        box-shadow: 0 0 5px #ff4757;
    }
    50% { 
        background: #ff6b7a; 
        box-shadow: 0 0 20px #ff4757;
    }
}

/* Playing state */
.voice-keyer-playing #voiceKeyerPlay {
    background: var(--accent-color);
    color: #000;
    animation: playPulse 0.5s ease-in-out infinite alternate;
}

@keyframes playPulse {
    from { opacity: 1; }
    to { opacity: 0.7; }
}


/* Add this to your CSS */
.transceiver-container {
    transform-origin: top left;
    transition: transform 0.3s ease;
}

.zoom-controls {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 10000;
    background: rgba(0,0,0,0.8);
    padding: 10px;
    border-radius: 8px;
    display: flex;
    gap: 8px;
    align-items: center;
}

.zoom-btn {
    background: var(--button-bg);
    color: var(--font-color);
    border: 1px solid rgba(255,255,255,0.3);
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
}

.zoom-btn:hover {
    background: var(--button-hover);
}

.zoom-level {
    color: var(--accent-color);
    font-size: 0.9em;
    min-width: 60px;
    text-align: center;
}

/* CW Keyer Memory styles */
.cw-msg-btn {
    padding: 8px 4px;
    border: 1px solid rgba(255,255,255,0.3);
    background: var(--button-bg);
    color: #fff;
    border-radius: 4px;
    font-size: 0.8em;
    min-height: 45px;
    text-align: center;
    transition: all 0.3s ease;
}

.cw-msg-btn.cw-msg-occupied {
    background: rgba(0,255,136,0.2);
    border-color: rgba(0,255,136,0.5);
    color: #00ff88;
}

.cw-msg-btn.cw-msg-active {
    background: var(--button-active);
    color: #000;
    border-color: #00ff88;
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
}

.cw-msg-btn:hover {
    background: var(--button-hover);
    transform: translateY(-1px);
}

/* CW sending animation */
.cw-sending #cwSend {
    animation: cwSendPulse 0.5s ease-in-out infinite alternate;
}

@keyframes cwSendPulse {
    from { 
        background: var(--accent-color); 
        box-shadow: 0 0 5px var(--accent-color);
    }
    to { 
        background: #00ccff; 
        box-shadow: 0 0 20px var(--accent-color);
    }
}

.cw-msg-label {
    font-size: 0.7em;
    display: block;
    margin-top: 2px;
    color: var(--accent-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

	</style>
</head>
<body>
    <div class="transceiver-container">
        
        <div class="left-panel">
            <div class="panel" id="serialPanel">
                <h3>Serial</h3>
                <div class="control-group">
                    <label>Baud Rate</label>
                    <select id="baudRate"><option value="115200" selected>115200</option></select>
                </div>
                <button id="connectBtn" class="btn btn-primary" style="margin-top:10px;">Connect</button>
            
						
			
			</div>
     <div class="zoom-controls">
    <button class="zoom-btn" id="zoomOut">-</button>
    <span class="zoom-level" id="zoomLevel">100%</span>
    <button class="zoom-btn" id="zoomIn">+</button>
    <button class="zoom-btn" id="zoomReset">Reset</button>
    <button class="zoom-btn" id="zoomFit">Fit</button>
    <button class="zoom-btn" id="fullscreenToggle">⛶</button>
</div>
			

			
			<div class="panel step-panel" id="stepPanel">
    <h3>Tuning Step</h3>
    <div class="control-group">
        <label>Step Size</label>
        <select id="stepSize">
            <option value="1" selected>1 Hz</option>
            <option value="10">10 Hz</option>
            <option value="100">100 Hz</option>
            <option value="250">250 Hz</option>
            <option value="500">500 Hz</option>
			<option value="1000">1 kHz</option>
            <option value="10000">10 kHz</option>
        </select>
	 </div>	
	  <div class="controls-grid" style="margin-top: 10px;">
        <button class="btn btn-secondary" id="autotuneBtn">
            AUTOTUNE OFF
        </button>
        <button class="btn btn-secondary" id="manualScanBtn">
            AUTOTUNE CW/SSB NOW
        </button>
    </div>

    
</div>
            
            
            <div class="panel" id="modePanel">
                <h3>Mode</h3>
                <div class="mode-buttons">
                    <div class="mode-btn active" data-mode="USB" data-catmode="2">USB</div>
                    <div class="mode-btn" data-mode="LSB" data-catmode="1">LSB</div>
                    <div class="mode-btn" data-mode="CW" data-catmode="3">CW</div>
                    <div class="mode-btn" data-mode="DIGI" data-catmode="6">DIGI</div>
                </div>
            </div>
            <div class="panel" id="bandPanel">
                <h3>Band</h3>
                <div class="band-buttons">
                    <div class="btn band-btn" data-band="160">160m</div><div class="btn band-btn" data-band="80">80m</div><div class="btn band-btn" data-band="60">60m</div>
                    <div class="btn band-btn" data-band="40">40m</div><div class="btn band-btn" data-band="30">30m</div><div class="btn band-btn active" data-band="20">20m</div>
                    <div class="btn band-btn" data-band="17">17m</div><div class="btn band-btn" data-band="15">15m</div><div class="btn band-btn" data-band="12">12m</div>
                    <div class="btn band-btn" data-band="10">10m</div><div class="btn band-btn" data-band="6">6m</div>
                </div>
            </div>
            <div class="panel" id="audioStreamPanel">
                <h3>Audio Stream</h3>
             
    <div class="audio-status-bar" style="margin-bottom: 10px;">
        <div class="status-indicator">
            <div class="status-dot" id="audioStatusDot"></div>
            <span class="status-text" id="audioStatusText">Ready to stream</span>
        </div>
    </div>
    <!-- Add audio level meter -->
    <div class="audio-meter-container" style="margin-bottom: 10px;">
        <label style="font-size: 0.8em;">Input Level</label>
        <div class="audio-meter-bar">
            <div class="audio-meter-indicator" id="inputLevelMeter"></div>
        </div>
        <div id="inputLevelText" style="font-size: 0.8em; text-align: center;">-∞ dB</div>
    </div>
    <!-- Add audio gain control -->
    <div class="control-group" style="margin-bottom: 10px;">
        <label>Audio Gain</label>
        <input type="range" id="audioGainSlider" min="10" max="500" value="200" style="width: 100%;">
        <div id="audioGainLevel" class="knob-level" style="text-align: center;">2.0x (+6.0 dB)</div>
    </div>

			   <div class="audio-device-grid">
                     <div class="control-group"><label>Input</label><select id="audioInputDevice"><option value="">Select...</option></select></div>
                     <div class="control-group"><label>Output</label><select id="audioOutputDevice"><option value="">Select...</option></select></div>
                </div>
                <div class="audio-controls">
                    <button class="btn btn-primary" id="startStreamBtn">Start</button>
                    <button class="btn btn-secondary" id="stopStreamBtn" disabled>Stop</button>
                </div>
                 <button class="btn btn-secondary" id="refreshDevicesBtn" style="width:100%; margin-top: 8px;">Refresh</button>
            </div>
            <div class="panel" id="catPanel">
                <h3>CAT Log</h3>
                <div class="cat-log" id="catLog"></div>
            </div>
	  </div>

        <div class="center-panel">
            <div class="panel-lock-controls">
                <button class="btn" id="panelLockToggle"><span id="lockIcon">🔓</span> <span id="lockText">Panels Unlocked</span></button>
            </div>
            <div class="panel frequency-display lcd-panel" id="lcdPanel">
                <div id="lcdRow1" class="lcd-row">QMX Interface</div>
                <div id="lcdRow2" class="lcd-row">Connect Radio</div>
            </div>
            <div class="panel" id="tuningPanel">
                 <h3 style="text-align: center;">Main Tuning</h3>
                 <div class="tuning-knob-container" id="tuningKnobContainer">
                    <div class="frequency-markings" id="frequencyMarkings"></div>
                    <div class="tuning-knob" id="tuningKnob" tabindex="0"><div class="tuning-knob-center"></div></div>
				 </div>
            </div>
			
			<div class="panel" id="spectrumPanel">
    <h3>Spectrum & DSP</h3>
    <div class="spectrum-container">
        <canvas id="spectrumCanvas"></canvas>
    </div>
<div class="spectrum-controls-new" style="margin-top: 10px;">
    <!-- CW DSP Bandwidth Control -->
    <div style="background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 8px; padding: 8px; margin-bottom: 10px;">
        <div style="text-align: center; margin-bottom: 6px;">
            <span style="font-size: 0.9em; color: var(--accent-color); font-weight: bold;">CW DSP Filter</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <span style="font-size: 0.8em; width: 60px;">Bandwidth:</span>
            <select id="cwBandwidth" style="flex: 1; margin: 0 8px; font-size: 0.8em;">
                <option value="300" selected>300 Hz (Native)</option>
                <option value="250">250 Hz</option>
                <option value="200">200 Hz</option>
                <option value="150">150 Hz</option>
                <option value="100">100 Hz</option>
                <option value="75">75 Hz</option>
                <option value="50">50 Hz</option>
            </select>
            <label style="font-size: 0.8em;">
                <input type="checkbox" id="enableCwDsp"> ON
            </label>
        </div>
        <div style="text-align: center;">
            <span id="cwDspStatus" style="font-size: 0.8em; color: #888;">DSP Filter: OFF</span>
        </div>
    </div>

    <!-- Target Pitch - centered -->
    <div style="text-align: center; margin-bottom: 8px;">
        <span style="font-size: 0.9em;">Target CW Pitch:</span>
        <select id="targetPitch" style="margin-left: 8px;">
            <option value="600">600 Hz</option>
            <option value="700" selected>700 Hz</option>
            <option value="800">800 Hz</option>
        </select>
    </div>
    
    <!-- Threshold slider - full width -->
    <div style="display: block; margin-bottom: 6px;">
        <div style="display: flex; align-items: center;">
            <span style="font-size: 0.8em; width: 60px;">Threshold:</span>
            <input type="range" id="signalThreshold" min="5" max="50" value="15" style="flex: 1; margin: 0 8px;">
            <span id="thresholdValue" style="font-size: 0.8em; width: 20px;">15</span>
        </div>
    </div>
    
    <!-- Method and checkbox - two columns -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
        <div>
            <span style="font-size: 0.8em;">Method:</span>
            <select id="noiseMethod" style="margin-left: 4px; width: 60px; font-size: 0.8em;">
                <option value="percentile" selected>Auto</option>
                <option value="statistical">Avg</option>
                <option value="adaptive">Adapt</option>
            </select>
        </div>
        <label style="font-size: 0.8em;">
            <input type="checkbox" id="showNoiseFloor"> Floor
        </label>
    </div>
    
    <!-- Calibrate button - centered -->
    <div style="text-align: center;">
        <button class="btn btn-secondary" id="calibrateNoiseBtn" style="padding: 3px 8px; font-size: 0.8em;">
            Calibrate Noisefloor
        </button>
    </div>
</div>
</div>
             <div class="panel" id="vfoPanel">
                <h3>VFO & Transmit</h3>
                <div class="controls-grid">
                    <button class="btn btn-primary" id="vfoA">VFO A</button> 
                    <button class="btn btn-secondary" id="vfoB">VFO B</button>
                    <button class="btn btn-secondary" id="txBtn">TX</button> 
                    <button class="btn btn-primary" id="rxBtn">RX</button>
                </div>
                <div class="controls-grid" style="margin-top: 10px;">
                    <button class="btn btn-secondary" id="vfoSwap">A↔B</button>
                    <button class="btn btn-secondary" id="vfoCopy">A→B</button>
                </div>
            </div>
             <div class="status-bar">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span class="status-text disconnected" id="statusText">DISCONNECTED</span>
                </div>
                <div id="currentTime"></div>
            </div>
        </div>

        <div class="right-panel">
		<div class="panel" id="voiceKeyerPanel">
    <h3>Voice Keyer</h3>
    
    <!-- Current slot indicator -->
    <div id="voiceCurrentSlot" style="text-align: center; margin-bottom: 10px; font-weight: bold; color: var(--accent-color);">
        MSG 1 (EMPTY)
    </div>
    
    <!-- Control buttons -->
    <div class="controls-grid" style="margin-bottom: 15px;">
        <button class="btn btn-secondary" id="voiceKeyerRecord">RECORD</button>
        <button class="btn btn-secondary" id="voiceKeyerPlay" disabled>PLAY</button>
        <button class="btn btn-secondary" id="voiceKeyerStop">STOP</button>
        <button class="btn btn-danger" id="voiceKeyerClear">CLEAR</button>
    </div>
    
    <!-- Auto-transmit option -->
    <div style="text-align: center; margin-bottom: 15px;">
        <label style="font-size: 0.9em;">
            <input type="checkbox" id="voiceAutoTx" checked>
            Auto TX/RX
        </label>
		
		<div class="controls-grid" style="margin-bottom: 15px;">
    <button class="btn btn-secondary" id="voiceExportBtn">EXPORT</button>
    <button class="btn btn-secondary" id="voiceImportBtn">IMPORT</button>
    <button class="btn btn-danger" id="voiceClearAllBtn">CLEAR ALL</button>
    <input type="file" id="voiceImportFile" accept=".json" style="display: none;">
</div>
		
    </div>
    
    <!-- Message slots -->
    <div class="voice-message-slots" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
        <button class="btn voice-msg-btn voice-msg-active" data-slot="1">MSG 1</button>
        <button class="btn voice-msg-btn" data-slot="2">MSG 2</button>
        <button class="btn voice-msg-btn" data-slot="3">MSG 3</button>
        <button class="btn voice-msg-btn" data-slot="4">MSG 4</button>
        <button class="btn voice-msg-btn" data-slot="5">MSG 5</button>
        <button class="btn voice-msg-btn" data-slot="6">MSG 6</button>
        <button class="btn voice-msg-btn" data-slot="7">MSG 7</button>
        <button class="btn voice-msg-btn" data-slot="8">MSG 8</button>
    </div>
    
    <!-- Instructions -->
    <div style="margin-top: 15px; font-size: 0.8em; color: #ccc; text-align: center;">
        <p>1. Select message slot<br>
        2. Click RECORD and speak<br>
        3. Click STOP when done<br>
        4. Click PLAY to transmit</p>
    </div>



<div class="panel" id="cwKeyerPanel">
    <h3>CW Keyer Memory</h3>
	 <!-- ADD THIS NEW SECTION -->
    <div style="text-align: center; margin-bottom: 15px; padding: 10px; background: rgba(0,255,136,0.1); border-radius: 8px;">
        <div class="keyer-mode-toggle">
            <div class="toggle-switch" id="keyerModeToggle2">
                <div class="toggle-slider"></div>
                <span class="toggle-label left">STRAIGHT</span>
                <span class="toggle-label right">BUG</span>
            </div>
        </div>
        <label style="font-size: 0.8em; margin-top: 8px; display: block;">CW Speed</label>
        <div class="volume-knob-container" style="margin: 10px auto;">
            <div class="volume-knob" id="cwSpeedKnob" tabindex="0"></div>
        </div>
        <div class="knob-level" id="cwSpeedLevel">22 WPM</div>
    </div>
    <!-- END NEW SECTION -->
    
    <!-- Current message indicator -->
    <div id="cwCurrentMessage" style="text-align: center; margin-bottom: 10px; font-weight: bold; color: var(--accent-color);">
        CW MSG 1 (EMPTY)
    </div>
    
    <!-- Message input -->
    <div class="control-group" style="margin-bottom: 10px;">
        <label>Message Text:</label>
        <input type="text" id="cwMessageInput" placeholder="Enter CW message..." maxlength="80" style="width: 100%; text-transform: uppercase;">
        <div style="font-size: 0.8em; color: #888; text-align: right;">
            <span id="cwCharCount">0</span>/80 chars
        </div>
    </div>
    
    <!-- Control buttons -->
    <div class="controls-grid" style="margin-bottom: 15px;">
        <button class="btn btn-secondary" id="cwStore">STORE</button>
        <button class="btn btn-primary" id="cwSend">SEND</button>
        <button class="btn btn-secondary" id="cwEdit">EDIT</button>
        <button class="btn btn-danger" id="cwClear">CLEAR</button>
    </div>
    
    <!-- Keyer status -->
    <div id="cwKeyerStatus" style="text-align: center; margin-bottom: 10px; font-size: 0.9em; color: #888;">
        Ready
    </div>
    
    <!-- Message memory slots -->
    <div class="cw-memory-buttons" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
        <button class="btn cw-msg-btn cw-msg-active" data-slot="1">CW1</button>
        <button class="btn cw-msg-btn" data-slot="2">CW2</button>
        <button class="btn cw-msg-btn" data-slot="3">CW3</button>
        <button class="btn cw-msg-btn" data-slot="4">CW4</button>
        <button class="btn cw-msg-btn" data-slot="5">CW5</button>
        <button class="btn cw-msg-btn" data-slot="6">CW6</button>
        <button class="btn cw-msg-btn" data-slot="7">CW7</button>
        <button class="btn cw-msg-btn" data-slot="8">CW8</button>
    </div>
    
    <!-- Management buttons -->
    <div class="controls-grid" style="margin-top: 10px;">
        <button class="btn btn-secondary" id="cwExportBtn">EXPORT</button>
        <button class="btn btn-secondary" id="cwImportBtn">IMPORT</button>
        <button class="btn btn-danger" id="cwClearAllBtn">CLEAR ALL</button>
        <input type="file" id="cwImportFile" accept=".json" style="display: none;">
    </div>
    
    <!-- Instructions -->
    <div style="margin-top: 10px; font-size: 0.8em; color: #ccc; text-align: center;">
        <p>Enter message, select slot, STORE.<br>
        Select slot and SEND to transmit.<br>
		or F1 to F8 or Mouse click to transmit.<br>
        Max 80 characters per message.</p>
    </div>
</div>

















</div>

		
            <div class="panel" id="qsoLoggerPanel">
                <h3>QSO Logger (<span id="qsoCount">0</span>)</h3>
                 <div class="qso-inputs-grid">
                    <input type="text" id="qsoCallsign" placeholder="Callsign"> <input type="text" id="qsoRstSent" value="599">
                    <input type="text" id="qsoRstRcvd" value="599"> <input type="text" id="qsoName" placeholder="Name">
                    <div class="control-group qth-group">
                        <input type="text" id="qsoQth" placeholder="QTH">
                    </div>
                    <div class="control-group comments-group">
                        <input type="text" id="qsoComments" placeholder="Comments">
                    </div>
                </div>
                <div id="qsoInfoBar" class="qso-info-bar" style="margin-top:10px;"></div>
                <div class="controls-grid" style="margin-top:10px;">
                    <button class="btn btn-primary" id="logQsoBtn">Log QSO</button>
                    <button class="btn btn-secondary" id="clearQsoInputsBtn">Clear</button>
                </div>
                <div class="log-management" style="margin-top:10px;">
                    <input type="text" id="qsoSearch" placeholder="Search Callsign...">
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="exportAdifBtn">Export</button>
                        <button class="btn btn-secondary" id="importAdifBtn">Import</button>
                        <input type="file" id="importAdifFile" accept=".adi,.adif" style="display: none;">
                        <button class="btn btn-danger" id="clearLogBtn" style="grid-column: 1 / -1;">Clear Log</button>
                    </div>
                </div>
                 <div class="qso-log-table" style="margin-top:10px;">
                    <div class="log-header">
                        <div>TIME</div><div>CALL</div><div>FREQ</div><div>MODE</div><div>RST</div>
                    </div>
                    <div class="log-body" id="qsoLogBody"></div>
                </div>
            </div>
             <div class="panel" id="memoryPanel">
                <h3>Memory</h3>
                <div class="controls-grid">
                    <button class="btn btn-secondary" id="storeBtn">Store</button> 
                    <button class="btn btn-secondary" id="recallBtn">Recall</button>
                    <button class="btn btn-secondary" id="editBtn">Edit</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear</button>
                </div>
                
				  <div class="controls-grid" style="margin-top: 10px;">
        <button class="btn btn-secondary" id="exportBtn">Export</button>
        <button class="btn btn-secondary" id="importBtn">Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;">
        <button class="btn btn-danger" id="clearAllBtn" style="grid-column: 1 / -1;">Clear All</button>
    </div>
				
				<div class="memory-buttons">
                    <div class="memory-btn" data-channel="1">M1</div> <div class="memory-btn" data-channel="2">M2</div>
                    <div class="memory-btn" data-channel="3">M3</div> <div class="memory-btn" data-channel="4">M4</div>
                    <div class="memory-btn" data-channel="5">M5</div> <div class="memory-btn" data-channel="6">M6</div>
                    <div class="memory-btn" data-channel="7">M7</div> <div class="memory-btn" data-channel="8">M8</div>
                    <div class="memory-btn" data-channel="9">M9</div><div class="memory-btn" data-channel="10">M10</div>
                </div>
             </div>
			 
			 <!-- Add the memory edit modal -->
<div class="memory-edit-modal" id="memoryEditModal">
    <div class="modal-content">
        <h3>Edit Memory Channel M<span id="editChannelNumber">1</span></h3>
        
        <div class="control-group">
            <label>Frequency (MHz)</label>
            <input type="text" id="memoryFreqInput" placeholder="14.205">
        </div>
        
        <div class="control-group">
            <label>Mode</label>
            <select id="memoryModeSelect">
                <option value="USB">USB</option>
                <option value="LSB">LSB</option>
                <option value="CW">CW</option>
                <option value="DIGI">DIGI</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Band</label>
            <select id="memoryBandSelect">
                <option value="160">160m</option>
                <option value="80">80m</option>
                <option value="60">60m</option>
                <option value="40">40m</option>
                <option value="30">30m</option>
                <option value="20">20m</option>
                <option value="17">17m</option>
                <option value="15">15m</option>
                <option value="12">12m</option>
                <option value="10">10m</option>
                <option value="6">6m</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Label</label>
            <input type="text" id="memoryLabelInput" placeholder="Optional label">
        </div>
        
        <div class="modal-buttons">
            <button class="btn btn-primary" id="saveMemoryEdit">Save</button>
            <button class="btn btn-secondary" id="cancelMemoryEdit">Cancel</button>
        </div>
    </div>
</div>

<div class="memory-edit-modal" id="cwEditModal">
    <div class="modal-content">
        <h3>Edit CW Memory Message CW<span id="editCwChannelNumber">1</span></h3>
        
        <div class="control-group">
            <label>Label (Optional)</label>
            <input type="text" id="cwLabelModalInput" placeholder="e.g., CQ DX, My RST" maxlength="10">
        </div>

        <div class="control-group">
            <label>Message Text (Max 80 chars)</label>
            <textarea id="cwMessageModalInput" rows="3" style="width: 100%; background: #1a252f; color: #ecf0f1; border: 1px solid #4a627a; border-radius: 5px; font-family: 'Courier New', monospace; text-transform: uppercase;" maxlength="80"></textarea>
            <div style="font-size: 0.8em; color: #888; text-align: right;">
                <span id="cwModalCharCount">0</span>/80 chars
            </div>
        </div>
        
        <div class="modal-buttons">
            <button class="btn btn-primary" id="saveCwEdit">Save</button>
            <button class="btn btn-secondary" id="cancelCwEdit">Cancel</button>
        </div>
    </div>
</div>
			 
             <div class="panel" id="controlsPanel">
                <h3>Controls</h3>
           <div class="knobs-row">
    <div class="knob-group">
        <label>AF Gain</label>
        <div class="volume-knob-container">
            <div class="volume-knob" id="volumeKnob" tabindex="0"></div>
        </div>
        <div class="knob-level" id="volumeLevel">75db</div>
    </div>
	
    <div class="knob-group">
        <div class="keyer-mode-toggle">
            <div class="toggle-switch" id="keyerModeToggle">
                <div class="toggle-slider"></div>
                <span class="toggle-label left">STRAIGHT</span>
                <span class="toggle-label right">BUG</span>
            </div>
        </div>
        <label>CW Speed</label>
        <div class="volume-knob-container">
            <div class="volume-knob" id="rfGainKnob" tabindex="0"></div>
        </div>
        <div class="knob-level" id="rfGainLevel">22 WPM</div>
    </div>

  <!-- NEW: Power meter inside controls panel -->
        <div style="margin-top: 15px;">
            <label style="font-size: 0.8em; opacity: 0.8; text-transform: uppercase;">Power Out</label>
            <div class="meter" style="margin-top: 5px;">
                <div class="meter-bar">
                    <div class="meter-indicator" id="powerMeter"></div>
                </div>
            </div>
            <div id="powerText" style="text-align: center; font-family: 'Courier New', monospace; color: var(--accent-color); margin-top: 5px;">0.0W</div>
        </div>

</div>
            </div>
          <div class="panel" id="sMeterPanel">
    <h3>S-Meter</h3>
    <div class="meter">
        <div class="meter-bar">
            <div class="meter-indicator" id="sMeter"></div>
        </div>
    </div>
    <div id="sMeterText" style="text-align: center; font-family: 'Courier New', monospace; color: var(--accent-color); margin-top: 5px;">S0</div>
</div>

<div class="panel" id="swrPanel">
    <h3>SWR</h3>
    <div class="meter">
        <div class="meter-bar">
            <div class="meter-indicator" id="swrMeter"></div>
        </div>
    </div>
    <div id="swrText" style="text-align: center; font-family: 'Courier New', monospace; color: var(--accent-color); margin-top: 5px;">1.0:1</div>
</div>
          <div class="panel" id="ritPanel">
    <h3>RIT</h3>
    <div class="rit-status-display" id="ritStatusDisplay">
        <span class="rit-status" id="ritStatus">OFF</span>
        <span class="rit-offset-value" id="ritOffsetValue">+0 Hz</span>
    </div>
    <div class="controls-grid">
        <button class="btn btn-secondary" id="ritToggleBtn">RIT ON/OFF</button>
        <button class="btn btn-secondary" id="ritClearBtn">CLEAR</button>
    </div>
    <!-- Optional: Add RIT adjustment buttons -->
    <div class="rit-adjust-buttons">
        <button class="btn btn-secondary rit-adjust" data-offset="-100">-100</button>
        <button class="btn btn-secondary rit-adjust" data-offset="-10">-10</button>
        <button class="btn btn-secondary rit-adjust" data-offset="-1">-1</button>
        <button class="btn btn-secondary rit-adjust" data-offset="1">+1</button>
        <button class="btn btn-secondary rit-adjust" data-offset="10">+10</button>
        <button class="btn btn-secondary rit-adjust" data-offset="100">+100</button>
    </div>
</div>
        </div>
    </div>
    
   <div class="modal-overlay" id="modalOverlay"></div>

<!-- Frequency Input Modal -->
<div class="freq-input-modal" id="freqInputModal">
    <div class="freq-modal-content">
        <h3>Direct Frequency Entry</h3>
        
        <!-- Format buttons -->
        <div class="freq-format-buttons">
            <button class="freq-format-btn active" data-format="mhz">MHz</button>
            <button class="freq-format-btn" data-format="khz">kHz</button>
            <button class="freq-format-btn" data-format="hz">Hz</button>
        </div>
        
        <!-- Input field -->
        <input type="text" id="freqDisplayInput" class="freq-display-input" placeholder="Enter frequency...">
        <div id="freqError" class="freq-error"></div>
        
        <!-- Keypad -->
        <div class="freq-keypad">
            <button class="freq-key" data-key="1">1</button>
            <button class="freq-key" data-key="2">2</button>
            <button class="freq-key" data-key="3">3</button>
            <button class="freq-key" data-key="4">4</button>
            <button class="freq-key" data-key="5">5</button>
            <button class="freq-key" data-key="6">6</button>
            <button class="freq-key" data-key="7">7</button>
            <button class="freq-key" data-key="8">8</button>
            <button class="freq-key" data-key="9">9</button>
            <button class="freq-key" data-key="0">0</button>
            <button class="freq-key" data-key=".">.</button>
            <button class="freq-key" data-key="backspace">⌫</button>
        </div>
        
        <!-- Action buttons -->
        <div class="freq-modal-buttons">
            <button class="btn btn-primary" id="freqSetBtn">Set</button>
            <button class="btn btn-secondary" id="freqClearBtn">Clear</button>
            <button class="btn btn-secondary" id="freqCancelBtn">Cancel</button>
        </div>
    </div>
	
	
</div>

   <script>

        class QMXInterface {
            constructor() {
                this.frequency = 14205000;
                this.stepSize = 1;
                this.mode = 'USB';
                this.connected = false;
                this.band = '20';
                this.currentVFO = 'A';
                this.transmitting = false;
				this.pollingInterval = null;
                
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.commandQueue = [];
                this.isProcessingQueue = false;
                this.catTimeout = null;
                this.connectionCheckTimeout = null;
                this.lastCommandTime = 0;
                
                this.memoryChannels = new Array(10).fill(null);
                this.selectedMemoryChannel = null;
                this.memoryMode = 'recall';
                
                this.catLogElement = null;
                
                this.tuningKnobRotation = 0;
                this.tuningLastAngle = 0;
                this.isTuningAdjusting = false;
                this.tuningAnimationFrame = null;
                
                this.totalRotationRange = 270;
                this.minRotation = -135;
                this.maxRotation = 135;
                this.volumeKnobRotation = 0;
                this.volumeLevel = 75;
                this.volumeLastAngle = 0;
                this.isVolumeAdjusting = false;
                this.volumeAnimationFrame = null;
                this.volumeTimeout = null;
                this.volumeCommandPending = false;
                this.volumeFeedbackBlock = false;
                this.rfGainKnobRotation = 0;
                this.rfGainLevel = 22;
                this.rfGainLastAngle = 0;
                this.isRFGainAdjusting = false;
                this.rfGainAnimationFrame = null;
                this.rfGainTimeout = null;
                
                this.powerKnobRotation = 0;
                this.powerLevel = 50;
                this.powerLastAngle = 0;
                this.isPowerAdjusting = false;
                this.powerAnimationFrame = null;
                this.powerTimeout = null;
                this.powerLevelBeforeAdjust = 50;
				//...
            this.autotuneDebounceTime = 750; 
            this.lastManualFreqSet = 0; // <-- ADD THIS LINE
			   this.noiseFloorMethod = 'percentile'; // 'statistical', 'percentile', 'adaptive'
    this.signalThreshold = 10; // How much above noise floor to consider a signal
    this.showNoiseFloor = false; // Show yellow line indicating noise floor
    this.adaptiveNoiseHistory = [];
            try {
            //...
		// Add these after your existing properties

// Add these CW DSP properties:
this.cwDspEnabled = false;
this.cwBandwidth = 300; // Current CW bandwidth in Hz
this.cwDspFilters = []; // Array to hold filter nodes
this.cwFilterChain = null; // The complete filter chain
this.cwDspGainNode = null; // Gain compensation node

// Add these audio properties:
this.audioContext = null;
this.inputStream = null;
this.inputSource = null;
this.gainNode = null;
this.inputAnalyser = null;
this.isAudioStreaming = false;
this.audioDevices = { input: [], output: [] };
this.selectedInputDevice = null;
this.selectedOutputDevice = null;
				
				
  // NEW: Add these for hover keyboard control
    this.isHoveringTuningKnob = false;
    this.boundHandleTuningHoverKeys = null;
                this.qsoLog = [];
                this.qsoLogFilter = '';
                 // NEW: Variable speed tuning properties
    this.originalStepSize = 1;  // Store the user-selected step
    this.isVariableStepActive = false;  // Track if we're in fast mode
    this.lastTuningTime = 0;  // Track timing for speed detection
    this.tuningSpeedSamples = [];  // Store recent speed samples
    this.variableStepTimeout = null;  // Timeout to revert step size
    this.fastStepMultiplier = 10;
	
	this.audioGain = 1.0;
this.audioGainSlider = null;
	
	 this.keyerMode = 'straight';  // 'straight' or 'bug'
    this.bugWpmSetting = 22; 
                // NEW: Property to hold last-tuned frequencies per band - UPDATED with 60m
                this.lastFrequencies = {
                    '160': 1900000, '80': 3500000, '60': 5351500, '40': 7000000, '30': 10100000, '20': 14000000,
                    '17': 18068000, '15': 21000000, '12': 24890000, '10': 28000000, '6': 50000000
                };
                // NEW: Property for debouncing frequency saves
                this.saveFreqTimeout = null;
// ADD these RIT properties here:
    this.ritEnabled = false;
    this.ritOffset = 0;
    this.ritKnobRotation = 0;
    this.ritLastAngle = 0;
    this.isRITAdjusting = false;
    this.ritAnimationFrame = null;
    this.ritTimeout = null;
    this.ritStep = 10;
	this.isWaitingForRITConfirmation = false;
this.ritConfirmationTimeout = null;
	  this.panelsLocked = false;  // NEW: Track panel lock state
    this.sortableInstances = []; // NEW: Store Sortable instances
	// Add these for the Spectrum Display
this.spectrumEnabled = false;
this.spectrumAnimationFrame = null;
this.targetPitch = 700;
this.spectrumBandwidth = 2400;
this.stepSize = 1;
this.originalStepSize = 1;  // Store the user-selected step

// Load saved step size
this.loadStepSize();
// Add these for the Autotune feature
this.autotuneEnabled = false;
this.autotuneScanTimeout = null;
this.updatePowerMeter();
                    this.catLogElement = document.getElementById('catLog');
                    
                    this.loadLayout();
                    this.loadLastFrequencies();
                    this.loadStepSize();					// NEW: Call new method to load frequencies
                    this.frequency = this.lastFrequencies[this.band]; // NEW: Set initial frequency from saved state

                    this.initDraggablePanels();
                    this.initTuningKnob();
                    this.initEventListeners();
					this.initZoomControls();
                    this.initVolumeControl();
                    this.initRFGainControl();
                    this.initPowerControl();
					this.initRITControl();
                    this.initMemorySystem();
                    this.initQsoLogger();
					this.initFrequencyKeyboard();
                    this.updateDisplay();
                    this.updateTXStatus();
                    this.updateConnectionStatus();
					this.initAudioStreaming();
					  this.soundEnabled = true; 
                    this.initTimeSync();
					  this.createEffectsSettings();
					     this.initSoundEffects();
						 this.initCWKeyer();
						 this.currentZoom = 1.0;
this.minZoom = 0.5;
this.maxZoom = 2.0;
this.zoomStep = 0.1;
                    window.qmxInterface = this;  
					setTimeout(() => this.fixVolumeKnobPointers(), 100); 
                    window.addEventListener('blur', () => {
                        if (this.isPowerAdjusting) this.stopPowerAdjust();
                        if (this.isVolumeAdjusting) this.stopVolumeAdjust();
                        if (this.isRFGainAdjusting) this.stopRFGainAdjust();
                        if (this.isTuningAdjusting) this.stopTuningAdjust();
                    });
					
					if (this.isRITAdjusting) this.stopRITAdjust();
					// ...
    
    this.initSpectrumDisplay(); // Add this line
this.initAutotune(); 
this.initCwDsp(); // Add this line
this.updatePowerMeter('00');// Add this line
this.voiceKeyer = {
    isRecording: false,
    isPlaying: false,
    messages: new Array(8).fill(null),
    currentSlot: 1,
    mediaRecorder: null,
    recordedChunks: [],
    playbackNode: null,
    recordingStream: null,
    autoTransmit: true,
    volumeBeforeRecord: null,
    volumeBeforePlayback: null  // **ADD THIS LINE**
};
this.cwKeyer = {
    messages: new Array(8).fill(null), // 8 CW message slots
    currentSlot: 1,
    isSending: false,
    sendingMessage: '',
    bufferStatus: 'KY2', // KY0=<75%, KY1=>75%, KY2=empty
    isEditing: false // Flag to control editing mode
};
// Load saved CW messages
this.loadCWMessages();
// ...
this.loadVoiceMessages();
                } catch (error) {
                    console.error('Failed to initialize QMX Interface:', error);
                }
            }

 
// --- Frequency Input Keyboard ---
initFrequencyKeyboard() {
    try {
        this.freqInputFormat = 'mhz';
        this.freqInputValue = '';
        
        // Make frequency display clickable to open the popup
        document.getElementById('lcdPanel').addEventListener('click', () => this.openFrequencyKeyboard());

        // --- Listeners for the POPUP modal ---
        // Get the modal container to scope the selections
        const modal = document.getElementById('freqInputModal');
        
        // Format buttons for POPUP (scoped to modal)
        modal.querySelectorAll('.freq-format-btn').forEach(btn => {
            btn.addEventListener('click', () => this.setFreqInputFormat(btn.dataset.format));
        });
        
        // Keypad buttons for POPUP (scoped to modal)
        modal.querySelectorAll('.freq-key').forEach(key => {
            key.addEventListener('click', () => this.handleFreqKeyInput(key.dataset.key));
        });
        
        // Action buttons for POPUP
        document.getElementById('freqSetBtn').addEventListener('click', () => this.setFrequencyFromInput());
        document.getElementById('freqCancelBtn').addEventListener('click', () => this.closeFrequencyKeyboard());
        document.getElementById('freqClearBtn').addEventListener('click', () => this.clearFreqInput());
        
        // Input field events for POPUP
        const freqInput = document.getElementById('freqDisplayInput');
        freqInput.addEventListener('input', (e) => this.handleFreqInputChange(e));
        freqInput.addEventListener('keydown', (e) => this.handleFreqInputKeyboard(e));
        
        // Modal overlay listener
        document.getElementById('modalOverlay').addEventListener('click', () => {
            if (document.getElementById('freqInputModal').classList.contains('active')) {
                this.closeFrequencyKeyboard();
            }
        });
        
        console.log('Frequency input keyboard initialized');
    } catch (error) {
        console.error('Error initializing frequency keyboard:', error);
    }
}

openFrequencyKeyboard() {
    // Set current frequency in the input
    this.freqInputValue = this.formatFrequencyForInput(this.frequency, this.freqInputFormat);
    document.getElementById('freqDisplayInput').value = this.freqInputValue;
    
    // Show modal
    document.getElementById('modalOverlay').classList.add('active');
    document.getElementById('freqInputModal').classList.add('active');
    
    // Focus the input
    setTimeout(() => {
        document.getElementById('freqDisplayInput').focus();
        document.getElementById('freqDisplayInput').select();
    }, 100);
    
    this.clearFreqError();
    this.logCAT('Frequency keyboard opened', 'info');
}

closeFrequencyKeyboard() {
    document.getElementById('modalOverlay').classList.remove('active');
    document.getElementById('freqInputModal').classList.remove('active');
    this.clearFreqError();
}

setFreqInputFormat(format) {
    this.freqInputFormat = format;
    
    // Update active button
    document.querySelectorAll('.freq-format-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.format === format) {
            btn.classList.add('active');
        }
    });
    
    // Update the input field with current frequency in new format
    this.freqInputValue = this.formatFrequencyForInput(this.frequency, format);
    document.getElementById('freqDisplayInput').value = this.freqInputValue;
    this.clearFreqError();
    
    this.logCAT(`Frequency format changed to ${format.toUpperCase()}`, 'info');
}

handleFreqKeyInput(key) {
    const freqInput = document.getElementById('freqDisplayInput');
    
    if (key === 'backspace') {
        this.freqInputValue = this.freqInputValue.slice(0, -1);
    } else {
        // Limit input length
        if (this.freqInputValue.length >= 15) return;
        
        // Handle decimal point
        if (key === '.') {
            // Only allow one decimal point
            if (this.freqInputValue.includes('.')) return;
            // Don't allow decimal at start
            if (this.freqInputValue.length === 0) return;
        }
        
        this.freqInputValue += key;
    }
    
    freqInput.value = this.freqInputValue;
    this.validateFreqInput();
    
    // Keep focus on input
    freqInput.focus();
}

handleFreqInputChange(e) {
    // Allow only numbers and decimal point
    let value = e.target.value.replace(/[^0-9.]/g, '');
    
    // Ensure only one decimal point
    const parts = value.split('.');
    if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
    }
    
    this.freqInputValue = value;
    e.target.value = value;
    this.validateFreqInput();
}

handleFreqInputKeyboard(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        this.setFrequencyFromInput();
    } else if (e.key === 'Escape') {
        e.preventDefault();
        this.closeFrequencyKeyboard();
    }
}

clearFreqInput() {
    this.freqInputValue = '';
    document.getElementById('freqDisplayInput').value = '';
    this.clearFreqError();
    document.getElementById('freqDisplayInput').focus();
}

validateFreqInput() {
    const errorEl = document.getElementById('freqError');
    errorEl.textContent = '';
    
    if (!this.freqInputValue) return true;
    
    const freq = this.parseFrequencyInput(this.freqInputValue, this.freqInputFormat);
    
    if (freq === null) {
        errorEl.textContent = 'Invalid frequency format';
        return false;
    }
    
    if (freq < 100000 || freq > 999999999) {
        errorEl.textContent = 'Frequency out of range (0.1 - 999.999 MHz)';
        return false;
    }
    
    return true;
}

clearFreqError() {
    document.getElementById('freqError').textContent = '';
}

// Replace the existing setFrequencyFromInput() method with this fixed version:

setFrequencyFromInput() {
    if (!this.validateFreqInput()) return;
    
    const freq = this.parseFrequencyInput(this.freqInputValue, this.freqInputFormat);
    if (freq === null) return;
    
    // Set the new frequency
    this.frequency = freq;
    
    // Update all displays and band selection
    this.updateDisplay();
    this.updateBandFromFrequency(); // Ensure band is updated
    
    // Update the band buttons to show the correct band
    this.updateBandButtons();
    
    // Save the frequency for this band
    this.saveLastFrequency();
    
    // Send frequency to radio if connected
    if (this.connected) {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
            // Request frequency confirmation after a brief delay
            setTimeout(() => {
               this.setFrequencyAndRestoreGain(this.frequency);
            }, 100);
        }).catch(e => {
            this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
        });
    }
    
    // Update the tuning knob visual position (optional visual feedback)
    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
    
    // Log the frequency change
    const displayStr = this.frequency.toString().padStart(9, '0');
    const mhz = displayStr.substring(0, 3);
    const khz = displayStr.substring(3, 6);
    const hz = displayStr.substring(6, 9);
    this.logCAT(`Direct frequency entry: ${mhz}.${khz}.${hz} Hz`, 'info');
    
    // Close the frequency input modal
    this.closeFrequencyKeyboard();
}

formatFrequencyForInput(freqHz, format) {
    switch (format) {
        case 'mhz':
            return (freqHz / 1000000).toFixed(6).replace(/\.?0+$/, '');
        case 'khz':
            return (freqHz / 1000).toFixed(3).replace(/\.?0+$/, '');
        case 'hz':
            return freqHz.toString();
        default:
            return (freqHz / 1000000).toFixed(6).replace(/\.?0+$/, '');
    }
}

parseFrequencyInput(input, format) {
    if (!input) return null;
    
    const value = parseFloat(input);
    if (isNaN(value) || value <= 0) return null;
    
    let freqHz;
    switch (format) {
        case 'mhz':
            freqHz = Math.round(value * 1000000);
            break;
        case 'khz':
            freqHz = Math.round(value * 1000);
            break;
        case 'hz':
            freqHz = Math.round(value);
            break;
        default:
            freqHz = Math.round(value * 1000000);
    }
    
    return freqHz;
}

            initMemorySystem() {
                try {
                    const savedMemories = localStorage.getItem('qmxMemoryChannels');
                    if (savedMemories) {
                        this.memoryChannels = JSON.parse(savedMemories);
                    }
                    document.getElementById('storeBtn').addEventListener('click', () => this.setMemoryMode('store'));
                    document.getElementById('recallBtn').addEventListener('click', () => this.setMemoryMode('recall'));
                    document.getElementById('editBtn').addEventListener('click', () => this.setMemoryMode('edit'));
                    document.getElementById('clearBtn').addEventListener('click', () => this.setMemoryMode('clear'));
                    document.getElementById('exportBtn').addEventListener('click', () => this.exportMemories());
                    document.getElementById('importBtn').addEventListener('click', () => {
                        document.getElementById('importFile').click();
                    });
                    document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAllMemories());
                    document.getElementById('importFile').addEventListener('change', (e) => this.importMemories(e));
                    document.querySelectorAll('.memory-btn').forEach((btn) => {
                        const channel = parseInt(btn.dataset.channel);
                        let clickTimer = null;
                        btn.addEventListener('click', (e) => {
                            if (clickTimer) {
                                clearTimeout(clickTimer);
                                clickTimer = null;
                                if (this.memoryMode === 'recall') {
                                    this.storeMemoryChannel(channel);
                                    this.logCAT(`Quick-stored to M${channel}`, 'info');
                                }
                            } else {
                                clickTimer = setTimeout(() => {
                                    clickTimer = null;
                                    this.handleMemoryChannel(channel);
                                }, 250);
                            }
                        });
                        btn.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.editMemoryChannel(channel);
                        });
                    });
                    document.getElementById('saveMemoryEdit').addEventListener('click', () => this.saveMemoryEdit());
                    document.getElementById('cancelMemoryEdit').addEventListener('click', () => this.closeEditModal());
                    document.getElementById('modalOverlay').addEventListener('click', () => this.closeEditModal());
                    this.updateMemoryDisplay();
                    this.setMemoryMode('recall');
                    console.log('Memory system initialized');
                } catch (error) {
                    console.error('Error initializing memory system:', error);
                }
            }

            setMemoryMode(mode) {
                this.memoryMode = mode;
                const buttons = {
                    'store': document.getElementById('storeBtn'),
                    'recall': document.getElementById('recallBtn'),
                    'edit': document.getElementById('editBtn'),
                    'clear': document.getElementById('clearBtn')
                };
                Object.values(buttons).forEach(btn => {
                    btn.classList.remove('btn-primary', 'btn-danger');
                    btn.classList.add('btn-secondary');
                });
                if (buttons[mode]) {
                    buttons[mode].classList.remove('btn-secondary');
                    if (mode === 'clear') {
                        buttons[mode].classList.add('btn-danger');
                    } else {
                        buttons[mode].classList.add('btn-primary');
                    }
                }
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    btn.classList.remove('memory-store-warning');
                    btn.style.cursor = mode === 'recall' ? 'pointer' : 
                                      mode === 'store' ? 'copy' :
                                      mode === 'edit' ? 'text' :
                                      mode === 'clear' ? 'not-allowed' : 'pointer';
                    if (mode === 'store' && this.memoryChannels[index]) {
                        btn.classList.add('memory-store-warning');
                    }
                });
                this.logCAT(`Memory mode: ${mode.toUpperCase()} (${this.getMemoryModeHint(mode)})`, 'info');
            }

            getMemoryModeHint(mode) {
                switch(mode) {
                    case 'recall': return 'Click to recall, double-click to quick-store, right-click to edit';
                    case 'store': return 'Click any memory to store current settings';
                    case 'edit': return 'Click any memory to edit its settings';
                    case 'clear': return 'Click any memory to clear it';
                    default: return '';
                }
            }

            handleMemoryChannel(channel) {
                switch(this.memoryMode) {
                    case 'store': this.storeMemoryChannel(channel); break;
                    case 'recall': this.recallMemoryChannel(channel); break;
                    case 'edit': this.editMemoryChannel(channel); break;
                    case 'clear': this.clearMemoryChannel(channel); break;
                }
            }

            storeMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const existingLabel = this.memoryChannels[channelIndex]?.label || '';
                if (this.memoryChannels[channelIndex]) {
                    const existingMem = this.memoryChannels[channelIndex];
                    const freqMHz = (existingMem.frequency / 1000000).toFixed(3);
                    const label = existingMem.label ? `"${existingMem.label}"` : '';
                    if (!confirm(`Overwrite M${channel}?\n\nCurrent: ${freqMHz} MHz, ${existingMem.mode}${label}\n\nReplace with: ${(this.frequency / 1000000).toFixed(3)} MHz, ${this.mode}?`)) {
                        return;
                    }
                }
                const memoryData = {
                    frequency: this.frequency,
                    mode: this.mode,
                    band: this.band,
                    label: existingLabel,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = channel;
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Stored M${channel}: ${mhz}.${khz}.${hz} Hz, ${this.mode}${existingLabel ? ', "' + existingLabel + '"' : ''}`, 'info');
                setTimeout(() => {
                    this.setMemoryMode('recall');
                }, 1000);
            }

            recallMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                if (!memoryData) {
                    this.logCAT(`Memory M${channel} is empty`, 'error');
                    return;
                }
                this.frequency = memoryData.frequency;
                this.mode = memoryData.mode;
                this.band = memoryData.band;
                this.updateDisplay();
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === this.mode) {
                        btn.classList.add('active');
                    }
                });
               document.querySelectorAll('.band-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        // Only change band if user manually clicks (not auto-selection)
        if (btn.dataset.band !== this.band) {
            document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.band = btn.dataset.band;
            this.setBandFrequency(btn.dataset.band);
            this.logCAT(`Manually selected ${this.band}m band`, 'info');
        }
    });
});
              if (this.connected) {
    const freqStr = this.frequency.toString().padStart(11, '0');
    const vfoCommand = this.getVFOCommand();
    this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
        setTimeout(() => {
            this.sendCommand(this.getVFOCommand());
        }, 100);
    }).catch(e => {
        this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
    });
    
    const modeBtn = document.querySelector(`[data-mode="${this.mode}"]`);
    if (modeBtn) {
        const catMode = modeBtn.dataset.catmode;
        this.sendCommand(`MD${catMode}`).catch(e => {
            console.error("Mode command error:", e);
        });
    }
	
	}
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                const label = memoryData.label ? ` "${memoryData.label}"` : '';
                this.logCAT(`Recalled M${channel}${label}: ${mhz}.${khz}.${hz} Hz, ${this.mode}`, 'info');
                this.selectedMemoryChannel = channel;
                this.updateMemoryDisplay();
            }

            editMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                this.editingChannel = channel;
                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('memoryEditModal').classList.add('active');
                document.getElementById('editChannelNumber').textContent = channel;
                const freqInput = document.getElementById('memoryFreqInput');
                const modeSelect = document.getElementById('memoryModeSelect');
                const bandSelect = document.getElementById('memoryBandSelect');
                const labelInput = document.getElementById('memoryLabelInput');
                if (memoryData) {
                    freqInput.value = (memoryData.frequency / 1000000).toFixed(6);
                    modeSelect.value = memoryData.mode;
                    bandSelect.value = memoryData.band;
                    labelInput.value = memoryData.label || '';
                } else {
                    freqInput.value = (this.frequency / 1000000).toFixed(6);
                    modeSelect.value = this.mode;
                    bandSelect.value = this.band;
                    labelInput.value = '';
                }
                freqInput.addEventListener('input', () => {
                    const freqMHz = parseFloat(freqInput.value);
                    if (!isNaN(freqMHz)) {
                        const suggestedBand = this.getBandFromFrequency(freqMHz);
                        if (suggestedBand) {
                            bandSelect.value = suggestedBand;
                        }
                    }
                });
                freqInput.focus();
                freqInput.select();
                const handleEnter = (e) => {
                    if (e.key === 'Enter') {
                        this.saveMemoryEdit();
                    } else if (e.key === 'Escape') {
                        this.closeEditModal();
                    }
                };
                freqInput.onkeydown = handleEnter;
                labelInput.onkeydown = handleEnter;
            }

            saveMemoryEdit() {
                if (this.editingChannel === null) return;
                const channelIndex = this.editingChannel - 1;
                const freqInput = document.getElementById('memoryFreqInput').value.trim();
                const mode = document.getElementById('memoryModeSelect').value;
                const band = document.getElementById('memoryBandSelect').value;
                const label = document.getElementById('memoryLabelInput').value.trim();
                let frequency;
                if (freqInput) {
                    const cleanFreq = freqInput.replace(/[^0-9.]/g, '');
                    const freqMHz = parseFloat(cleanFreq);
                    if (isNaN(freqMHz) || freqMHz < 0.1 || freqMHz > 999.999999) {
                        alert('Please enter a valid frequency');
                        document.getElementById('memoryFreqInput').focus();
                        return;
                    }
                    frequency = Math.round(freqMHz * 1000000);
                } else {
                    alert('Please enter a frequency');
                    document.getElementById('memoryFreqInput').focus();
                    return;
                }
                const memoryData = {
                    frequency: frequency,
                    mode: mode,
                    band: band,
                    label: label,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = this.editingChannel;
                const freqStr = frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Updated M${this.editingChannel}: ${mhz}.${khz}.${hz} Hz, ${mode}, ${band}m${label ? ', "' + label + '"' : ''}`, 'info');
                this.closeEditModal();
            }

            closeEditModal() {
                document.getElementById('modalOverlay').classList.remove('active');
                document.getElementById('memoryEditModal').classList.remove('active');
                this.editingChannel = null;
            }

            clearMemoryChannel(channel) {
                const channelIndex = channel - 1;
                if (this.memoryChannels[channelIndex]) {
                    const memData = this.memoryChannels[channelIndex];
                    const freqMHz = (memData.frequency / 1000000).toFixed(3);
                    const label = memData.label || `M${channel}`;
                    if (confirm(`Clear memory channel M${channel}?\n\nFrequency: ${freqMHz} MHz\nMode: ${memData.mode}\nLabel: ${label}`)) {
                        this.memoryChannels[channelIndex] = null;
                        localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                        this.updateMemoryDisplay();
                        this.logCAT(`Cleared memory channel M${channel}`, 'info');
                        if (this.selectedMemoryChannel === channel) {
                            this.selectedMemoryChannel = null;
                        }
                    }
                } else {
                    this.logCAT(`Memory M${channel} is already empty`, 'error');
                }
            }

            clearAllMemories() {
                const usedMemories = this.memoryChannels.filter(m => m !== null).length;
                if (usedMemories === 0) {
                    this.logCAT('No memory channels to clear', 'info');
                    return;
                }
                if (confirm(`Clear ALL memory channels?\n\nThis will delete ${usedMemories} stored memories.\nThis action cannot be undone!`)) {
                    this.memoryChannels = new Array(10).fill(null);
                    localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                    this.selectedMemoryChannel = null;
                    this.updateMemoryDisplay();
                    this.logCAT(`Cleared all ${usedMemories} memory channels`, 'info');
                }
            }

            updateMemoryDisplay() {
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    const channel = index + 1;
                    const memoryData = this.memoryChannels[index];
                    btn.innerHTML = '';
                    btn.classList.remove('memory-occupied', 'memory-selected', 'memory-store-warning');
                    if (memoryData) {
                        btn.classList.add('memory-occupied');
                        if (this.memoryMode === 'store') {
                            btn.classList.add('memory-store-warning');
                        }
                        const channelSpan = document.createElement('span');
                        channelSpan.textContent = `M${channel}`;
                        btn.appendChild(channelSpan);
                        if (memoryData.label) {
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'memory-label';
                            labelSpan.textContent = memoryData.label;
                            btn.appendChild(labelSpan);
                        }
                        btn.title = `M${channel}: ${(memoryData.frequency / 1000000).toFixed(3)} MHz, ${memoryData.mode}${memoryData.label ? ' - ' + memoryData.label : ''}`;
                    } else {
                        btn.textContent = `M${channel}`;
                        btn.title = `M${channel}: Empty`;
                    }
                    if (this.selectedMemoryChannel === channel) {
                        btn.classList.add('memory-selected');
                    }
                });
            }

            exportMemories() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    memories: this.memoryChannels
                };
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qmx_memories_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('Memory channels exported successfully', 'info');
            }

            importMemories(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        if (importData.memories && Array.isArray(importData.memories)) {
                            if (confirm('This will replace all current memory channels. Continue?')) {
                                this.memoryChannels = importData.memories;
                                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                                this.updateMemoryDisplay();
                                this.logCAT('Memory channels imported successfully', 'info');
                            }
                        } else {
                            throw new Error('Invalid file format');
                        }
                    } catch (error) {
                        this.logCAT(`Import failed: ${error.message}`, 'error');
                        alert('Failed to import memory file.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            logCAT(message, type = 'info') {
                if (!this.catLogElement) {
                    this.catLogElement = document.getElementById('catLog');
                }
                if (!this.catLogElement) return;
                const entry = document.createElement('div');
                entry.className = `cat-log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `${timestamp} ${type.toUpperCase()}: ${message}`;
                this.catLogElement.appendChild(entry);
                this.catLogElement.scrollTop = this.catLogElement.scrollHeight;
                while (this.catLogElement.children.length > 200) {
                    this.catLogElement.removeChild(this.catLogElement.firstChild);
                }
            }

            async initializeRadio() {
                await this.sendCommand('IF');
                await this.sendCommand('LC');
                await this.sendCommand('FA');
                await this.sendCommand('MD');
                await this.sendCommand('AG0');
                await this.sendCommand('KS');
                await this.sendCommand('SM');
                await this.sendCommand('SW');
                await this.sendCommand('PC');
				await this.sendCommand('RT');   // Get RIT status
                await this.sendCommand('RC');   // Clear RIT initially
				this.sendTimeToQMX();
            }

            initEventListeners() {
 this.initPanelLockToggle();
 this.initVoiceKeyer();   
   // document.getElementById('connectBtn').addEventListener('click', async () => {               

			   document.getElementById('connectBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.disconnectSerial();
                    } else {
                        await this.connectSerial();
                    }
                });
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const previousMode = this.mode;
                        this.mode = btn.dataset.mode;
                        
                        // Handle CW DSP mode changes
                        if (this.isAudioStreaming) {
                            if (this.mode === 'CW' && previousMode !== 'CW') {
                                // Switched TO CW mode - update DSP status and spectrum
                                this.updateCwDspStatus();
                                this.updateSpectrumBandwidth();
                                if (this.cwDspEnabled) {
                                    this.enableCwDspProcessing();
                                }
                            } else if (this.mode !== 'CW' && previousMode === 'CW') {
                                // Switched FROM CW mode - disable DSP and restore direct routing
                                if (this.cwDspEnabled) {
                                    this.disableCwDspProcessing();
                                }
                                this.updateCwDspStatus();
                                this.updateSpectrumBandwidth();
                            }
                        } else {
                            // Just update status when not streaming
                            this.updateCwDspStatus();
                            this.updateSpectrumBandwidth();
                        }
                        
                        if (this.connected) {
                            const catMode = btn.dataset.catmode;
                            await this.sendCommand(`MD${catMode}`);
                            this.logCAT(`Mode changed to ${this.mode}`, 'info');
                        }
                    });
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.band = btn.dataset.band;
                        this.setBandFrequency(btn.dataset.band);
                    });
                });
				
				
				
               // MODIFY your existing stepSize change handler in initEventListeners:
// Replace the existing stepSize event listener with this:
document.getElementById('stepSize').addEventListener('change', (e) => {
    this.originalStepSize = parseInt(e.target.value);
    if (!this.isVariableStepActive) {
        this.stepSize = this.originalStepSize;
    }
    
    // Save to localStorage
    this.saveStepSize();
    
    this.logCAT(`Tuning step set to ${this.originalStepSize} Hz`, 'info');
});
                document.getElementById('vfoA').addEventListener('click', async () => {
    this.selectVFO('A');
    if (this.connected) {
        await this.sendCommand('FR0');  // Select VFO A for RX
        await this.sendCommand('FT0');  // Select VFO A for TX
        // Request frequency update for VFO A
        await this.sendCommand('FA');
    }
});

document.getElementById('vfoB').addEventListener('click', async () => {
    this.selectVFO('B');
    if (this.connected) {
        await this.sendCommand('FR1');  // Select VFO B for RX
        await this.sendCommand('FT1');  // Select VFO B for TX
        // Request frequency update for VFO B
        await this.sendCommand('FB');
    }
	
	 if (this.sortableInstances.length === 0) {
        this.initDraggablePanels();
    }
	
	
});
              // This is inside the initEventListeners function
			  
	if (this.sounds) this.sounds.connect();		  
			  
			  
			  
			  
			  
			  

document.getElementById('vfoB').addEventListener('click', async () => {
    this.selectVFO('B');
    if (this.connected) {
        await this.sendCommand('FR1');
        await this.sendCommand('FT1');
        // Add this line to ask for the new VFO's frequency
        await this.sendCommand('FB'); 
    }

                });
               
// Modify your VFO copy button click handler to include animation:
document.getElementById('vfoCopy').addEventListener('click', async () => {
    if (this.connected) {
        try {
            // Get the current VFO's frequency first
            const currentVFOCommand = this.currentVFO === 'A' ? 'FA' : 'FB';
            await this.sendCommand(currentVFOCommand);
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Use the frequency from the interface (should be current)
            const currentFreq = this.frequency;
            
            if (this.currentVFO === 'A') {
                // Copy A to B - START ANIMATION FIRST
                this.animateVFOCopy('A', 'B', currentFreq);
                
                // Small delay, then send copy command
                setTimeout(() => {
                    const currentFreqStr = currentFreq.toString().padStart(11, '0');
                    this.sendCommand(`FB${currentFreqStr}`);
                    this.logCAT(`A→B: ${(currentFreq/1000000).toFixed(3)} MHz copied`, 'info');
                }, 100);
            } else {
                // Copy B to A - START ANIMATION FIRST
                this.animateVFOCopy('B', 'A', currentFreq);
                
                // Small delay, then send copy command
                setTimeout(() => {
                    const currentFreqStr = currentFreq.toString().padStart(11, '0');
                    this.sendCommand(`FA${currentFreqStr}`);
                    this.logCAT(`B→A: ${(currentFreq/1000000).toFixed(3)} MHz copied`, 'info');
                }, 100);
            }
            
            // Update display
            setTimeout(async () => {
                await this.sendCommand('IF');
                await this.sendCommand('LC');
            }, 300);
            
        } catch (e) {
            this.logCAT(`VFO copy error: ${e.message}`, 'error');
        }
    } else {
        this.logCAT('Cannot copy - radio not connected', 'error');
    }
});	

// VFO SWAP with animation - replace your existing vfoSwap event listener with this:
document.getElementById('vfoSwap').addEventListener('click', async () => {
    if (this.connected) {
        try {
            this.logCAT('Swapping VFO A ↔ VFO B...', 'info');
            
            let vfoFreqA;
            let vfoFreqB;
            
            // Capture frequencies using temporary response handler
            const originalProcessResponse = this.processResponse.bind(this);
            let responseCount = 0;
            
            this.processResponse = (response) => {
                if (response.startsWith('FA')) {
                    vfoFreqA = parseInt(response.substring(2));
                    responseCount++;
                } else if (response.startsWith('FB')) {
                    vfoFreqB = parseInt(response.substring(2)); 
                    responseCount++;
                } else {
                    originalProcessResponse(response);
                }
            };
            
            // Get both VFO frequencies
            await this.sendCommand('FA');
            await this.sendCommand('FB');
            
            // Wait for both responses
            while (responseCount < 2) {
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            // Restore original response handler
            this.processResponse = originalProcessResponse;
            
            console.log('Captured VFO A:', vfoFreqA);
            console.log('Captured VFO B:', vfoFreqB);
            
            // START THE ANIMATION BEFORE SENDING SWAP COMMANDS
            if (this.animateVFOSwap) {
                this.animateVFOSwap(vfoFreqA, vfoFreqB);
            }
            
            // Small delay to let animation start, then send swap commands
            setTimeout(() => {
                this.sendCommand(`FB${vfoFreqA.toString().padStart(11, '0')}`);
                this.sendCommand(`FA${vfoFreqB.toString().padStart(11, '0')}`);
            }, 100);
            
        } catch (e) {
            this.logCAT(`VFO swap error: ${e.message}`, 'error');
        }
    } else {
        this.logCAT('Cannot swap - radio not connected', 'error');
    }
});

			   document.getElementById('txBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('TX');
                        this.transmitting = true;
                        this.updateTXStatus();
                        this.logCAT('Switched to TRANSMIT mode', 'info');
                    } else {
                        this.logCAT('Cannot transmit - radio not connected', 'error');
                    }
                });
                document.getElementById('rxBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('RX');
                        this.transmitting = false;
                        this.updateTXStatus();
                        this.logCAT('Switched to RECEIVE mode', 'info');
                    } else {
                        this.logCAT('Cannot switch to RX - radio not connected', 'error');
                    }
                });
		

// This block replaces the previous keydown listener to handle both CW and Voice keyer shortcuts

         // This is the corrected keydown listener for both CW and Voice keyers.

            document.addEventListener('keydown', (e) => {
                // Check if the key pressed is one of F1 to F8
                const match = e.key.match(/^F([1-8])$/);

                if (match) {
                    // Prevent the default browser action for F-keys
                    e.preventDefault();

                    const slotNumber = parseInt(match[1], 10);

                    // First, check if the Shift key is pressed for the Voice Keyer
                    if (e.shiftKey) {
                        // --- VOICE KEYER LOGIC (Shift + F-key) ---
                        this.logCAT(`Shift+F${slotNumber} detected, attempting to play voice message...`, 'info');
                        
                        // Select the appropriate voice message slot
                        this.selectVoiceMessage(slotNumber);
                        
                        // Immediately play the message from the now-selected slot
                        this.playVoiceMessage();
                        
                    } else {
                        // --- CW KEYER LOGIC (F-key alone) ---
                        this.logCAT(`F${slotNumber} detected, attempting to send CW message...`, 'info');

                        if (this.connected) {
                            // Select the appropriate CW message slot
                            this.selectCWSlot(slotNumber);
                            
                            // Immediately send the message from the now-selected slot
                            this.sendCWMessage();
                        } else {
                            this.logCAT(`Cannot send CW message: Radio not connected.`, 'error');
                        }
                    }
                }
            });





		}

           setBandFrequency(band) {
    if (this.lastFrequencies[band]) {
        this.frequency = this.lastFrequencies[band];
        this.updateDisplay();
        if (this.connected) {
           this.setFrequencyAndRestoreGain(this.frequency);
        }
    }
}

         getBandFromFrequency(freqMHz) {
    // More precise band edge definitions with 60m added
    if (freqMHz >= 1.800 && freqMHz <= 2.000) return '160';
    if (freqMHz >= 3.500 && freqMHz <= 4.000) return '80';
    if (freqMHz >= 5.330 && freqMHz <= 5.405) return '60'; // NEW: 60m band
    if (freqMHz >= 7.000 && freqMHz <= 7.300) return '40';
    if (freqMHz >= 10.100 && freqMHz <= 10.150) return '30';
    if (freqMHz >= 14.000 && freqMHz <= 14.350) return '20';
    if (freqMHz >= 18.068 && freqMHz <= 18.168) return '17';
    if (freqMHz >= 21.000 && freqMHz <= 21.450) return '15';
    if (freqMHz >= 24.890 && freqMHz <= 24.990) return '12';
    if (freqMHz >= 28.000 && freqMHz <= 29.700) return '10';
    if (freqMHz >= 50.000 && freqMHz <= 54.000) return '6';
    return null; 
	// Out of amateur bands
}
			
			selectVFO(vfo) {
    this.currentVFO = vfo;
    this.updateVFOButtons();
    this.logCAT(`VFO ${vfo} selected`, 'info');
}

            updateConnectionStatus() {
                const btn = document.getElementById('connectBtn');
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const baudDropdown = document.getElementById('baudRate');
                if (this.connected) {
                    btn.textContent = 'Disconnect';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    statusDot.classList.add('connected');
                    statusText.textContent = 'CONNECTED';
                    statusText.className = 'status-text connected';
                    baudDropdown.disabled = true;
                } else {
                    btn.textContent = 'Connect Serial';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'DISCONNECTED';
                    statusText.className = 'status-text disconnected';
                    baudDropdown.disabled = false;
                }
            }

            updateTXStatus() {
                const txBtn = document.getElementById('txBtn');
                const rxBtn = document.getElementById('rxBtn');
                if (this.transmitting) {
                    txBtn.classList.remove('btn-secondary');
                    txBtn.classList.add('btn-danger');
                    rxBtn.classList.remove('btn-primary');
                    rxBtn.classList.add('btn-secondary');
                } else {
                    txBtn.classList.remove('btn-danger');
                    txBtn.classList.add('btn-secondary');
                    rxBtn.classList.remove('btn-secondary');
                    rxBtn.classList.add('btn-primary');
                }
            }

            updateModeFromCAT(catMode) {
                const modeMap = {
                    '1': 'LSB', '2': 'USB', '3': 'CW',
                    '7': 'CW', '6': 'DIGI'
                };
                if (modeMap[catMode]) {
                    this.mode = modeMap[catMode];
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.mode === this.mode) {
                            btn.classList.add('active');
                        }
                    });
                } else {
                    this.logCAT(`Unknown mode code received: ${catMode}`, 'error');
                }
            }

           updateSMeter(percentage) {
    const meter = document.getElementById('sMeter');
    percentage = Math.max(0, Math.min(100, percentage));
    meter.style.width = percentage + '%';
    
    // Optional: Show actual S-meter reading
    const sMeterLabel = document.getElementById('sMeterLabel');
    if (sMeterLabel) {
        const sUnits = Math.floor((percentage / 100) * 9);
        sMeterLabel.textContent = `S${sUnits}`;
    }
}

updateSWRMeter(percentage) {
    const meter = document.getElementById('swrMeter');
    percentage = Math.max(0, Math.min(100, percentage));
    meter.style.width = percentage + '%';
    
    // Update SWR text display
    const swrText = document.getElementById('swrText');
    if (swrText) {
        if (percentage === 0) {
            swrText.textContent = 'RX Mode';
        } else {
            const swr = 1.0 + (percentage / 100) * 2.0;
            swrText.textContent = `${swr.toFixed(2)}:1`;
        }
    }
}

          updateLcdDisplay(row1, row2) {
    const lcdRow1El = document.getElementById('lcdRow1');
    const lcdRow2El = document.getElementById('lcdRow2');
    
    if (lcdRow1El) {
        lcdRow1El.textContent = row1;
    }
    if (lcdRow2El) {
        lcdRow2El.textContent = row2;
    }
    
    // Auto-detect VFO from LCD display
    // If the first character is 'B', we're on VFO B, otherwise VFO A
    const detectedVFO = (row1 && row1.charAt(0) === 'B') ? 'B' : 'A';
    
    if (detectedVFO !== this.currentVFO) {
        this.currentVFO = detectedVFO;
        this.updateVFOButtons();
        this.logCAT(`VFO switched to ${this.currentVFO} (auto-detected)`, 'info');
    }
}

        updateDisplay() {
    this.updateBandFromFrequency();
    this.updateLoggerInfoBar();
}

            updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('currentTime').textContent = timeString;
                setTimeout(() => this.updateClock(), 1000);
            }

            async initTimeSync() {
                try {
                    this.logCAT('Initializing time synchronization...', 'info');
                    
                    await this.syncTimeFromServer();
                    
                    this.clockUpdateInterval = setInterval(() => {
                        this.updateSyncedClock();
                        this.updateLoggerInfoBar();
                    }, 1000);
                    
                    this.timeSyncInterval = setInterval(() => {
                        this.syncTimeFromServer();
                    }, 10 * 60 * 1000);
                    
                    console.log('Time synchronization initialized');
                } catch (error) {
                    console.error('Error initializing time sync:', error);
                    this.logCAT(`Time sync init error: ${error.message}`, 'error');
                    this.updateLocalClock();
                }
            }

            async syncTimeFromServer() {
                try {
                    this.logCAT('Synchronizing with time server...', 'info');
                    
                    const timeAPIs = [
                        'https://worldtimeapi.org/api/timezone/Etc/UTC',
                        'https://timeapi.io/api/Time/current/zone?timeZone=UTC',
                        'http://worldclockapi.com/api/json/utc/now'
                    ];
                    
                    let syncSuccessful = false;
                    
                    for (const api of timeAPIs) {
                        try {
                            const response = await fetch(api, {
                                method: 'GET', cache: 'no-cache', headers: { 'Accept': 'application/json' }
                            });
                            
                            if (!response.ok) continue;
                            
                            const data = await response.json();
                            let serverTime;
                            
                            if (data.datetime) serverTime = new Date(data.datetime);
                            else if (data.dateTime) serverTime = new Date(data.dateTime);
                            else if (data.currentDateTime) serverTime = new Date(data.currentDateTime);
                            else continue;
                            
                            const localTime = new Date();
                            this.localTimeOffset = serverTime.getTime() - localTime.getTime();
                            this.lastSyncTime = localTime.getTime();
                            
                            this.logCAT(`Time synced successfully (offset: ${this.localTimeOffset}ms)`, 'info');
                            syncSuccessful = true;
                            
                            this.sendTimeToQMX();
                            break;
                            
                        } catch (apiError) {
                            console.warn(`Time API ${api} failed:`, apiError);
                            continue;
                        }
                    }
                    
                    if (!syncSuccessful) throw new Error('All time APIs failed');
                    
                } catch (error) {
                    console.error('Time sync failed:', error);
                    this.logCAT(`Time sync failed: ${error.message}`, 'error');
                    this.localTimeOffset = 0;
                }
            }

            getSyncedTime() {
                const now = new Date();
                return new Date(now.getTime() + (this.localTimeOffset || 0));
            }

            updateSyncedClock() {
                const syncedUTC = this.getSyncedTime();
                const localTime = new Date(syncedUTC.getTime() - (syncedUTC.getTimezoneOffset() * 60000));
                
                const timeString = localTime.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    const syncAge = this.lastSyncTime ? Date.now() - this.lastSyncTime : Infinity;
                    const syncIndicator = syncAge > 11 * 60 * 1000 ? ' (SYNC?)' : ' (SYNC)';
                    timeElement.textContent = timeString + (this.lastSyncTime ? syncIndicator : ' (LOCAL)');
                }
            }

          // 1. Function to update band selection based on frequency
updateBandFromFrequency() {
    const freqMHz = this.frequency / 1000000;
    const detectedBand = this.getBandFromFrequency(freqMHz);
    
    if (detectedBand && detectedBand !== this.band) {
        this.band = detectedBand;
        this.updateBandButtons();
        this.logCAT(`Auto-selected ${this.band}m band for ${freqMHz.toFixed(3)} MHz`, 'info');
    }
}

// 2. Function to update band button highlighting
updateBandButtons() {
    document.querySelectorAll('.band-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.band === this.band) {
            btn.classList.add('active');
        }
    });
} 

updateVFOButtons() {
    document.querySelectorAll('#vfoA, #vfoB').forEach(btn => {
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-secondary');
    });
    
    const activeButton = document.getElementById(`vfo${this.currentVFO}`);
    if (activeButton) {
        activeButton.classList.remove('btn-secondary');
        activeButton.classList.add('btn-primary');
    }
}

// 3. Helper function to get the correct VFO command
getVFOCommand() {
    return this.currentVFO === 'B' ? 'FB' : 'FA';
}

		   updateLocalClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    timeElement.textContent = timeString + ' (LOCAL)';
                }
                
                setTimeout(() => this.updateLocalClock(), 1000);
            }

            sendTimeToQMX() {
                if (this.timeCommandTimeout) clearTimeout(this.timeCommandTimeout);
                
                this.timeCommandTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const syncedUTC = this.getSyncedTime();
                        const localTime = new Date(syncedUTC.getTime() - (syncedUTC.getTimezoneOffset() * 60000));
                        
                        const hours = localTime.getHours().toString().padStart(2, '0');
                        const minutes = localTime.getMinutes().toString().padStart(2, '0');
                        const seconds = localTime.getSeconds().toString().padStart(2, '0');
                        const timeCommand = `TM${hours}${minutes}${seconds}`;
                        
                        this.sendCommand(timeCommand).then(() => {
                            this.logCAT(`Local time sent to QMX: ${hours}:${minutes}:${seconds}`, 'info');
                        }).catch(e => {
                            console.error("Time command error:", e);
                        });
                    }
                    this.timeCommandTimeout = null;
                }, 100);
            }

updateBandForOutOfBand() {
    const freqMHz = this.frequency / 1000000;
    const detectedBand = this.getBandFromFrequency(freqMHz);
    
    if (!detectedBand) {
        // Clear all band selections for out-of-band frequencies
        document.querySelectorAll('.band-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        this.band = null; // or keep the last valid band
        this.logCAT(`Frequency ${freqMHz.toFixed(3)} MHz is outside amateur bands`, 'info');
    }
}

// NEW: Enable keyboard control when hovering over tuning knob
enableTuningHoverKeys() {
    this.isHoveringTuningKnob = true;
    
    if (!this.boundHandleTuningHoverKeys) {
        this.boundHandleTuningHoverKeys = this.handleTuningHoverKeys.bind(this);
    }
    
    document.addEventListener('keydown', this.boundHandleTuningHoverKeys);
    
    // Visual feedback - make the knob glow when hover-keyboard-active
    const tuningKnob = document.getElementById('tuningKnob');
    tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 255, 136, 0.6)';
}

// NEW: Disable keyboard control when not hovering over tuning knob
disableTuningHoverKeys() {
    this.isHoveringTuningKnob = false;
    
    if (this.boundHandleTuningHoverKeys) {
        document.removeEventListener('keydown', this.boundHandleTuningHoverKeys);
    }
    
    // Remove visual feedback
    const tuningKnob = document.getElementById('tuningKnob');
    tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3)';
}

// NEW: Handle keyboard input when hovering over tuning knob
handleTuningHoverKeys(e) {
    if (!this.isHoveringTuningKnob) return;
    
    // Only handle arrow keys
    if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
    
    e.preventDefault();
    
    let direction = 0;
    if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        direction = -1;
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        direction = 1;
    }
    
    if (direction !== 0) {
        // Use the selected step size
        const freqDelta = direction * this.stepSize;
        this.updateFrequency(freqDelta);
        
        // Update knob rotation for visual feedback
        const rotationDelta = direction * 2;
        this.tuningKnobRotation += rotationDelta;
        document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
        
        // Send frequency update
        this.sendFrequencyDynamically();
        
        // Brief visual feedback
        this.provideTuningKeyFeedback();
    }
}

// NEW: Provide brief visual feedback for keyboard tuning
provideTuningKeyFeedback() {
    const tuningKnob = document.getElementById('tuningKnob');
    const originalBoxShadow = tuningKnob.style.boxShadow;
    
    // Brief bright glow
    tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 30px rgba(0, 255, 136, 1)';
    
    setTimeout(() => {
        if (this.isHoveringTuningKnob) {
            // Return to hover glow
            tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 255, 136, 0.6)';
        } else {
            // Return to normal
            tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3)';
        }
    }, 150);
}

// ADD these new methods to your QMXInterface class:

updateTuningSpeed(speed) {
    // Keep track of recent speed samples (last 500ms worth)
    const now = performance.now();
    this.tuningSpeedSamples.push({ speed: speed, time: now });
    
    // Remove old samples (older than 500ms)
    this.tuningSpeedSamples = this.tuningSpeedSamples.filter(sample => 
        now - sample.time < 500
    );
    
    // Calculate average speed
    if (this.tuningSpeedSamples.length > 0) {
        const avgSpeed = this.tuningSpeedSamples.reduce((sum, sample) => 
            sum + sample.speed, 0) / this.tuningSpeedSamples.length;
        
        // Threshold for "fast" tuning (adjust these values as needed)
        const fastThreshold = 2.0;  // radians/second for rotary, or scaled for wheel
        
        if (avgSpeed > fastThreshold && !this.isVariableStepActive) {
            this.activateVariableStep();
        }
    }
    
    // Reset the timeout to revert to normal speed
    this.resetVariableStepTimeout();
}

activateVariableStep() {
    if (!this.isVariableStepActive) {
        this.originalStepSize = this.stepSize;
        this.stepSize = this.originalStepSize * this.fastStepMultiplier;
        this.isVariableStepActive = true;
        
        // Visual feedback
        const stepDisplay = document.getElementById('stepSize');
        if (stepDisplay) {
            stepDisplay.style.background = 'rgba(255, 149, 0, 0.3)';
            stepDisplay.style.borderColor = '#ff9500';
        }
        
        this.logCAT(`Fast tuning activated: ${this.stepSize} Hz step`, 'info');
    }
}

deactivateVariableStep() {
    if (this.isVariableStepActive) {
        this.stepSize = this.originalStepSize;
        this.isVariableStepActive = false;
        
        // Remove visual feedback
        const stepDisplay = document.getElementById('stepSize');
        if (stepDisplay) {
            stepDisplay.style.background = '';
            stepDisplay.style.borderColor = '';
        }
        
        this.logCAT(`Normal tuning restored: ${this.stepSize} Hz step`, 'info');
    }
}

getCurrentStepSize() {
    return this.isVariableStepActive ? this.stepSize : this.originalStepSize;
}

resetVariableStepTimeout() {
    if (this.variableStepTimeout) {
        clearTimeout(this.variableStepTimeout);
    }
    
    // Revert to normal step after 1 second of slow/no tuning
    this.variableStepTimeout = setTimeout(() => {
        this.deactivateVariableStep();
        this.tuningSpeedSamples = []; // Clear speed history
    }, 1000);
}

// This is the updated code
initKeyerToggle() {
    try {
        const keyerToggle = document.getElementById('keyerModeToggle');
        const keyerKnobContainer = document.querySelector('.knob-group:has(#rfGainKnob)');
        
        // Set initial state to BUG mode
        this.setKeyerMode('bug'); // ✅ Changed from 'straight' to 'bug'
        
        // Add click event listener
        keyerToggle.addEventListener('click', () => {
            this.toggleKeyerMode();
        });
        
        console.log('Keyer mode toggle initialized');
    } catch (error) {
        console.error('Error initializing keyer toggle:', error);
    }
}

// ADD this method to toggle between modes:
toggleKeyerMode() {
    if (this.keyerMode === 'straight') {
        this.setKeyerMode('bug');
    } else {
        this.setKeyerMode('straight');
    }
}

setKeyerMode(mode) {
    const keyerToggle = document.getElementById('keyerModeToggle');
    const keyerToggle2 = document.getElementById('keyerModeToggle2');
    const keyerKnobContainer = document.querySelector('.knob-group:has(#rfGainKnob)');
    
    this.keyerMode = mode;
    
    if (mode === 'straight') {
        keyerToggle?.classList.remove('bug');
        keyerToggle2?.classList.remove('bug');
        if (keyerKnobContainer) {
            keyerKnobContainer.classList.add('keyer-straight');
        }
        
        this.rfGainLevel = 0;
        this.rfGainKnobRotation = this.minRotation;
       document.getElementById('cwSpeedKnob')?.setAttribute('style', `transform: rotate(${this.rfGainKnobRotation}deg)`);
document.getElementById('rfGainKnob')?.setAttribute('style', `transform: rotate(${this.rfGainKnobRotation}deg)`);
        this.updateRFGainLevel();
        
        this.logCAT('Keyer mode: STRAIGHT KEY', 'info');
        
    } else if (mode === 'bug') {
        keyerToggle?.classList.add('bug');
        keyerToggle2?.classList.add('bug');
        if (keyerKnobContainer) {
            keyerKnobContainer.classList.remove('keyer-straight');
        }
        
        this.rfGainLevel = (this.bugWpmSetting / 50) * 100;
        this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
       const rfGainKnob = document.getElementById('rfGainKnob');
if (rfGainKnob) {
    rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
}

const cwSpeedKnob = document.getElementById('cwSpeedKnob');
if (cwSpeedKnob) {
    cwSpeedKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
}
        this.updateRFGainLevel();
        
        this.logCAT(`Keyer mode: BUG (${this.bugWpmSetting} WPM)`, 'info');
    }
    
    this.sendRFGainCommand();
}
            // --- Frequency & Layout Management ---
            loadLastFrequencies() {
                const savedFrequencies = localStorage.getItem('qmxLastFrequencies');
                if (savedFrequencies) {
                    try {
                        const parsedFrequencies = JSON.parse(savedFrequencies);
                        // Merge saved frequencies with defaults to ensure all bands are covered
                        this.lastFrequencies = { ...this.lastFrequencies, ...parsedFrequencies };
                        console.log('Loaded last-used frequencies.');
                    } catch(e) {
                        console.error('Could not parse saved frequencies, using defaults.');
                    }
                }
            }
            
            saveLastFrequency() {
                if (this.saveFreqTimeout) {
                    clearTimeout(this.saveFreqTimeout);
                }
                this.saveFreqTimeout = setTimeout(() => {
                    this.lastFrequencies[this.band] = this.frequency;
                    localStorage.setItem('qmxLastFrequencies', JSON.stringify(this.lastFrequencies));
                }, 1000); // Save 1 second after tuning stops
            }

// REPLACE the existing initDraggablePanels method with this:
initDraggablePanels() {
    try {
        const leftPanel = document.querySelector('.left-panel');
        const centerPanel = document.querySelector('.center-panel');
        const rightPanel = document.querySelector('.right-panel');

        const options = {
            group: 'shared-panels',
            handle: 'h3',
            animation: 150,
            ghostClass: 'sortable-ghost',
            dragClass: 'sortable-drag',
            disabled: this.panelsLocked,
            onEnd: () => {
                this.saveLayout();
            }
        };

        this.sortableInstances = [
            Sortable.create(leftPanel, options),
            Sortable.create(centerPanel, options),
            Sortable.create(rightPanel, options)
        ];
        
        console.log('Draggable panels initialized');
    } catch(e) {
        console.warn("Could not initialize draggable panels. Is Sortable.js loaded?");
        this.sortableInstances = [];
    }
}

// ADD these new methods:
initPanelLockToggle() {
    try {
        console.log('Initializing panel lock toggle...');
        
        const toggleBtn = document.getElementById('panelLockToggle');
        if (!toggleBtn) {
            console.error('Panel lock toggle button not found! Check HTML structure.');
            return;
        }

        console.log('Panel lock toggle button found');
        this.updatePanelLockUI();

        toggleBtn.addEventListener('click', () => {
            console.log('Panel lock toggle clicked!');
            this.togglePanelLock();
        });

        console.log('Panel lock toggle initialized successfully');
    } catch (error) {
        console.error('Error initializing panel lock toggle:', error);
    }
}

togglePanelLock() {
    this.panelsLocked = !this.panelsLocked;
    
    if (this.sortableInstances && this.sortableInstances.length > 0) {
        this.sortableInstances.forEach(sortable => {
            if (sortable) {
                sortable.option('disabled', this.panelsLocked);
            }
        });
    }
    
    this.updatePanelLockUI();
    
    const status = this.panelsLocked ? 'LOCKED' : 'UNLOCKED';
    this.logCAT(`Panel positions ${status}`, 'info');
    console.log(`Panel dragging ${status}`);
}

updatePanelLockUI() {
    const toggleBtn = document.getElementById('panelLockToggle');
    const lockIcon = document.getElementById('lockIcon');
    const lockText = document.getElementById('lockText');
    
    if (!toggleBtn || !lockIcon || !lockText) {
        console.error('Panel lock UI elements missing');
        return;
    }
    
    toggleBtn.classList.remove('locked', 'unlocked');
    document.body.classList.remove('panels-locked');
    
    if (this.panelsLocked) {
        toggleBtn.classList.add('locked');
        lockIcon.textContent = '🔒';
        lockText.textContent = 'Panels Locked';
        toggleBtn.title = 'Click to unlock panel dragging';
        document.body.classList.add('panels-locked');
    } else {
        toggleBtn.classList.add('unlocked');
        lockIcon.textContent = '🔓';
        lockText.textContent = 'Panels Unlocked';
        toggleBtn.title = 'Click to lock panels in place';
    }
}

		   saveLayout() {
                const layout = {
                    left: [...document.querySelectorAll('.left-panel .panel')].map(p => p.id),
                    center: [...document.querySelectorAll('.center-panel .panel')].map(p => p.id),
                    right: [...document.querySelectorAll('.right-panel .panel')].map(p => p.id)
                };
                localStorage.setItem('qmxPanelLayout', JSON.stringify(layout));
                this.logCAT('Panel layout saved.', 'info');
            }

            loadLayout() {
                const savedLayout = localStorage.getItem('qmxPanelLayout');
                if (savedLayout) {
                    try {
                        const layout = JSON.parse(savedLayout);
                        const columns = {
                            left: document.querySelector('.left-panel'),
                            center: document.querySelector('.center-panel'),
                            right: document.querySelector('.right-panel')
                        };

                        Object.keys(layout).forEach(columnKey => {
                            layout[columnKey].forEach(panelId => {
                                const panelElement = document.getElementById(panelId);
                                if (panelElement && columns[columnKey]) {
                                    columns[columnKey].appendChild(panelElement);
                                }
                            });
                        });
                        console.log('Custom panel layout loaded.');
                    } catch (e) {
                        console.error("Failed to load custom layout, using default.", e);
                        localStorage.removeItem('qmxPanelLayout');
                    }
                }
            }

            // --- QSO Logger ---
            initQsoLogger() {
                try {
                    document.getElementById('logQsoBtn').addEventListener('click', () => this.logQso());
                    document.getElementById('clearQsoInputsBtn').addEventListener('click', () => this.clearQsoInputs());
                    document.getElementById('exportAdifBtn').addEventListener('click', () => this.exportAdif());
                    document.getElementById('importAdifBtn').addEventListener('click', () => document.getElementById('importAdifFile').click());
                    document.getElementById('importAdifFile').addEventListener('change', (e) => this.importAdif(e));
                    document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLog());
                    document.getElementById('qsoSearch').addEventListener('input', (e) => {
                        this.qsoLogFilter = e.target.value;
                        this.renderQsoLog();
                    });
                    document.getElementById('qsoCallsign').addEventListener('keyup', (e) => {
                         e.target.value = e.target.value.toUpperCase();
                         if (e.key === 'Enter') {
                             this.logQso();
                         }
                    });

                    this.loadQsoLog();
                    console.log('QSO Logger initialized');
                } catch (error) {
                    console.error('Failed to initialize QSO Logger:', error);
                }
            }

            updateLoggerInfoBar() {
                try {
                    const infoBar = document.getElementById('qsoInfoBar');
                    if (!infoBar) return;
                    
                    const freqMHz = (this.frequency / 1000000).toFixed(3);
                    const mode = this.mode;
                    const band = this.band + 'm';
                    
                    const syncedUTC = this.getSyncedTime();
                    const dateStr = syncedUTC.toISOString().slice(0, 10);
                    const timeStr = syncedUTC.toISOString().slice(11, 19);

                    infoBar.innerHTML = `
                        <span>${freqMHz} MHz</span> &bull; 
                        <span>${mode}</span> &bull; 
                        <span>${band}</span>
                        <span style="float: right;">${dateStr} ${timeStr} UTC</span>
                    `;
                } catch (error) {
                    // Fail silently if elements are not ready
                }
            }

            loadQsoLog() {
                const savedLog = localStorage.getItem('qmxQsoLog');
                if (savedLog) {
                    this.qsoLog = JSON.parse(savedLog);
                }
                this.renderQsoLog();
            }

            saveQsoLog() {
                localStorage.setItem('qmxQsoLog', JSON.stringify(this.qsoLog));
            }

            logQso() {
                const callsign = document.getElementById('qsoCallsign').value.trim().toUpperCase();
                if (!callsign) {
                    alert('Callsign is required.');
                    document.getElementById('qsoCallsign').focus();
                    return;
                }

                const qso = {
                    id: Date.now(),
                    call: callsign,
                    rstSent: document.getElementById('qsoRstSent').value.trim(),
                    rstRcvd: document.getElementById('qsoRstRcvd').value.trim(),
                    name: document.getElementById('qsoName').value.trim(),
                    qth: document.getElementById('qsoQth').value.trim(),
                    comments: document.getElementById('qsoComments').value.trim(),
                    freq: (this.frequency / 1000000).toFixed(6),
                    mode: this.mode,
                    band: this.band + 'm',
                    time: this.getSyncedTime().toISOString()
                };
                
                this.qsoLog.unshift(qso);
                this.saveQsoLog();
                this.renderQsoLog();
                this.clearQsoInputs(false);
            }

            clearQsoInputs(clearAll = true) {
                document.getElementById('qsoCallsign').value = '';
                document.getElementById('qsoName').value = '';
                document.getElementById('qsoQth').value = '';
                document.getElementById('qsoComments').value = '';
                if(clearAll) {
                   document.getElementById('qsoRstSent').value = '599';
                   document.getElementById('qsoRstRcvd').value = '599';
                }
                document.getElementById('qsoCallsign').focus();
            }

            clearLog() {
                if (confirm(`Are you sure you want to delete all ${this.qsoLog.length} logged QSOs? This cannot be undone.`)) {
                    this.qsoLog = [];
                    this.saveQsoLog();
                    this.renderQsoLog();
                    this.logCAT('QSO Log cleared.', 'info');
                }
            }

            renderQsoLog() {
                const logBody = document.getElementById('qsoLogBody');
                const qsoCount = document.getElementById('qsoCount');
                
                logBody.innerHTML = '';
                
                const filteredLog = this.qsoLog.filter(qso => 
                    qso.call.toUpperCase().includes(this.qsoLogFilter.toUpperCase())
                );

                if (filteredLog.length === 0) {
                    logBody.innerHTML = `<div class="log-empty-msg">${this.qsoLog.length > 0 ? 'No matching QSOs' : 'No QSOs logged yet'}</div>`;
                } else {
                    filteredLog.forEach(qso => {
                        const row = document.createElement('div');
                        row.className = 'log-row';
                        
                        const time = new Date(qso.time);
                        const timeStr = `${time.getUTCHours().toString().padStart(2, '0')}:${time.getUTCMinutes().toString().padStart(2, '0')}`;
                        const freqStr = parseFloat(qso.freq).toFixed(3);

                        row.innerHTML = `
                            <div>${timeStr}</div>
                            <div>${qso.call}</div>
                            <div>${freqStr}</div>
                            <div>${qso.mode}</div>
                            <div>${qso.rstRcvd}</div>
                        `;
                        row.title = `Date: ${time.toISOString().slice(0,10)}\nName: ${qso.name}\nQTH: ${qso.qth}\nComments: ${qso.comments}`;
                        logBody.appendChild(row);
                    });
                }
                
                qsoCount.textContent = this.qsoLog.length;
            }

            exportAdif() {
                if (this.qsoLog.length === 0) {
                    alert('Log is empty. Nothing to export.');
                    return;
                }

                let adifContent = "Generated by QMX+ Professional QRP Communications Interface\n<EOH>\n\n";

                this.qsoLog.slice().reverse().forEach(qso => {
                    const time = new Date(qso.time);
                    const qsoDate = time.toISOString().slice(0, 10).replace(/-/g, '');
                    const timeOn = time.toISOString().slice(11, 19).replace(/:/g, '');

                    let record = '';
                    const addField = (name, value) => {
                        if (value) {
                            const val = String(value);
                            record += `<${name}:${val.length}>${val} `;
                        }
                    };

                    addField('CALL', qso.call);
                    addField('QSO_DATE', qsoDate);
                    addField('TIME_ON', timeOn);
                    addField('BAND', qso.band.toUpperCase());
                    addField('FREQ', qso.freq);
                    addField('MODE', qso.mode);
                    addField('RST_SENT', qso.rstSent);
                    addField('RST_RCVD', qso.rstRcvd);
                    addField('NAME', qso.name);
                    addField('QTH', qso.qth);
                    addField('COMMENT', qso.comments);
                    
                    adifContent += record.trim() + '<EOR>\n';
                });

                const blob = new Blob([adifContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qmx_log_${new Date().toISOString().slice(0, 10)}.adi`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('QSO log exported to ADIF.', 'info');
            }

            importAdif(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        const newQsos = this.parseAdif(content);
                        if (newQsos.length === 0) {
                            alert('No valid QSO records found in the file.');
                            return;
                        }

                        if (confirm(`Found ${newQsos.length} QSOs. Do you want to add them to your log?`)) {
                            const existingKeys = new Set(this.qsoLog.map(q => `${q.call}-${q.time.slice(0,16)}`));
                            const addedQsos = [];
                            newQsos.reverse().forEach(qso => {
                                const key = `${qso.call}-${qso.time.slice(0,16)}`;
                                if (!existingKeys.has(key)) {
                                    this.qsoLog.unshift(qso);
                                    addedQsos.push(qso);
                                }
                            });
                            
                            this.qsoLog.sort((a, b) => new Date(b.time) - new Date(a.time));
                            this.saveQsoLog();
                            this.renderQsoLog();
                            alert(`Successfully imported ${addedQsos.length} new QSOs.`);
                            this.logCAT(`Imported ${addedQsos.length} QSOs from ADIF file.`, 'info');
                        }
                    } catch (error) {
                        alert('Failed to parse ADIF file. Error: ' + error.message);
                        console.error('ADIF Parse Error:', error);
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file);
            }

            parseAdif(adifContent) {
                const qsos = [];
                const records = adifContent.toUpperCase().split(/<EOR>/i);

                for (const record of records) {
                    if (!record.includes('<CALL')) continue;

                    let qso = { id: Date.now() + Math.random() };
                    const fields = record.match(/<[A-Z0-9_]+:\d+>[\s\S]*?(?=\s*<|$)/g) || [];

                    for (const field of fields) {
                        const match = field.match(/<([A-Z0-9_]+):\d+>([\s\S]*)/);
                        if (match) {
                            const [, key, value] = match;
                            qso[key] = value.trim();
                        }
                    }
                    
                    if (qso.CALL && qso.QSO_DATE && qso.TIME_ON) {
                        const date = `${qso.QSO_DATE.slice(0,4)}-${qso.QSO_DATE.slice(4,6)}-${qso.QSO_DATE.slice(6,8)}`;
                        const time = `${qso.TIME_ON.slice(0,2)}:${qso.TIME_ON.slice(2,4)}:${qso.TIME_ON.slice(4,6)}`;
                        const fullIsoTime = new Date(`${date}T${time}Z`).toISOString();

                        qsos.push({
                            id: qso.id,
                            call: qso.CALL || '',
                            rstSent: qso.RST_SENT || '',
                            rstRcvd: qso.RST_RCVD || '',
                            name: qso.NAME || '',
                            qth: qso.QTH || '',
                            comments: qso.COMMENT || '',
                            freq: qso.FREQ || '',
                            mode: qso.MODE || '',
                            band: qso.BAND ? (qso.BAND.endsWith('M') ? qso.BAND : qso.BAND + 'M') : '',
                            time: fullIsoTime,
                        });
                    }
                }
                return qsos;
            }

// ============ CW DSP FILTERING SYSTEM ============

initCwDsp() {
    try {
        console.log('Initializing CW DSP filtering system...');
        
        // Set up event listeners for DSP controls
        const cwBandwidthSelect = document.getElementById('cwBandwidth');
        const enableCwDspCheckbox = document.getElementById('enableCwDsp');
        const cwDspStatus = document.getElementById('cwDspStatus');
        
        if (!cwBandwidthSelect || !enableCwDspCheckbox || !cwDspStatus) {
            console.error('CW DSP UI elements not found!');
            return;
        }
        
        // Bandwidth selector
        cwBandwidthSelect.addEventListener('change', (e) => {
            this.cwBandwidth = parseInt(e.target.value);
            if (this.cwDspEnabled && this.isAudioStreaming) {
                this.updateCwDspFilters();
                this.updateSpectrumBandwidth();
            }
            this.updateCwDspStatus();
            this.logCAT(`CW DSP bandwidth: ${this.cwBandwidth} Hz`, 'info');
        });
        
        // Enable/disable checkbox
        enableCwDspCheckbox.addEventListener('change', (e) => {
            this.cwDspEnabled = e.target.checked;
            if (this.isAudioStreaming) {
                if (this.cwDspEnabled) {
                    this.enableCwDspProcessing();
                } else {
                    this.disableCwDspProcessing();
                }
            }
            this.updateCwDspStatus();
            this.updateSpectrumBandwidth();
        });
        
        // Initialize UI state
        this.updateCwDspStatus();
        
        this.logCAT('CW DSP filtering system ready', 'info');
        
    } catch (error) {
        console.error('Error initializing CW DSP:', error);
        this.logCAT(`CW DSP init error: ${error.message}`, 'error');
    }
}

createCwDspFilterChain() {
    if (!this.audioContext) {
        console.error('Audio context not available for DSP filters');
        return null;
    }
    
    try {
        // Clear existing filters
        this.cwDspFilters = [];
        
        // Calculate filter parameters
        const centerFreq = this.targetPitch;
        const bandwidth = this.cwBandwidth;
        const lowCutoff = centerFreq - (bandwidth / 2);
        const highCutoff = centerFreq + (bandwidth / 2);
        
        // Ensure reasonable frequency bounds
        const finalLowCutoff = Math.max(50, lowCutoff);
        const finalHighCutoff = Math.min(this.audioContext.sampleRate / 2 - 100, highCutoff);
        
        console.log(`Creating CW DSP filters: ${finalLowCutoff.toFixed(1)} - ${finalHighCutoff.toFixed(1)} Hz`);
        
        // Create multiple filter stages for steep rolloff without ringing
        const filterStages = this.calculateFilterStages(bandwidth);
        
        // Stage 1: High-pass filter (removes low frequency noise)
        const highpass1 = this.audioContext.createBiquadFilter();
        highpass1.type = 'highpass';
        highpass1.frequency.value = finalLowCutoff;
        highpass1.Q.value = 0.7071; // Butterworth response (minimal ringing)
        this.cwDspFilters.push(highpass1);
        
        // Stage 2: Low-pass filter (removes high frequency noise)
        const lowpass1 = this.audioContext.createBiquadFilter();
        lowpass1.type = 'lowpass';
        lowpass1.frequency.value = finalHighCutoff;
        lowpass1.Q.value = 0.7071; // Butterworth response
        this.cwDspFilters.push(lowpass1);
        
        // For very narrow bandwidths, add additional filter stages
        if (bandwidth <= 100) {
            // Stage 3: Additional high-pass for steeper rolloff
            const highpass2 = this.audioContext.createBiquadFilter();
            highpass2.type = 'highpass';
            highpass2.frequency.value = finalLowCutoff + 5;
            highpass2.Q.value = 0.5; // Even gentler for narrow bandwidth
            this.cwDspFilters.push(highpass2);
            
            // Stage 4: Additional low-pass for steeper rolloff
            const lowpass2 = this.audioContext.createBiquadFilter();
            lowpass2.type = 'lowpass';
            lowpass2.frequency.value = finalHighCutoff - 5;
            lowpass2.Q.value = 0.5;
            this.cwDspFilters.push(lowpass2);
        }
        
        if (bandwidth <= 75) {
            // Stage 5: Bandpass filter for very narrow filtering
            const bandpass = this.audioContext.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = centerFreq;
            bandpass.Q.value = centerFreq / bandwidth * 0.8; // Conservative Q to avoid ringing
            this.cwDspFilters.push(bandpass);
        }
        
        // Gain compensation (narrow filters reduce signal level)
        this.cwDspGainNode = this.audioContext.createGain();
        const gainCompensation = this.calculateGainCompensation(bandwidth);
        this.cwDspGainNode.gain.value = gainCompensation;
        
        console.log(`Created ${this.cwDspFilters.length} DSP filter stages with ${gainCompensation.toFixed(2)}x gain compensation`);
        
        return true;
        
    } catch (error) {
        console.error('Error creating CW DSP filter chain:', error);
        return false;
    }
}

calculateFilterStages(bandwidth) {
    // Determine number of filter stages based on bandwidth
    if (bandwidth >= 200) return 2;      // Basic filtering
    if (bandwidth >= 100) return 4;      // Moderate filtering  
    if (bandwidth >= 75) return 5;       // Aggressive filtering
    return 6;                            // Maximum filtering for 50Hz
}

calculateGainCompensation(bandwidth) {
    // Compensate for signal loss due to narrow filtering
    // More narrow = more gain needed
    if (bandwidth >= 200) return 1.0;
    if (bandwidth >= 150) return 1.1;
    if (bandwidth >= 100) return 1.3;
    if (bandwidth >= 75) return 1.5;
    return 1.8; // 50Hz needs significant compensation
}

connectCwDspFilterChain(inputNode, outputNode) {
    if (!this.cwDspFilters.length || !this.cwDspGainNode) {
        console.error('DSP filter chain not created');
        return false;
    }
    
    try {
        let currentNode = inputNode;
        
        // Connect all filter stages in series
        for (let i = 0; i < this.cwDspFilters.length; i++) {
            currentNode.connect(this.cwDspFilters[i]);
            currentNode = this.cwDspFilters[i];
        }
        
        // Connect gain compensation
        currentNode.connect(this.cwDspGainNode);
        
        // Connect to final output (speakers)
        this.cwDspGainNode.connect(outputNode);
        
        console.log('CW DSP filter chain connected successfully');
        return true;
        
    } catch (error) {
        console.error('Error connecting CW DSP filter chain:', error);
        return false;
    }
}

disconnectCwDspFilterChain() {
    try {
        // Disconnect all filter nodes
        this.cwDspFilters.forEach(filter => {
            filter.disconnect();
        });
        
        if (this.cwDspGainNode) {
            this.cwDspGainNode.disconnect();
        }
        
        console.log('CW DSP filter chain disconnected');
        
    } catch (error) {
        console.error('Error disconnecting CW DSP filters:', error);
    }
}

enableCwDspProcessing() {
    if (!this.isAudioStreaming || !this.audioContext) {
        console.log('Cannot enable CW DSP - audio not streaming');
        return;
    }
    
    // Only enable for CW mode
    if (this.mode !== 'CW') {
        this.logCAT('CW DSP: Only available in CW mode', 'error');
        document.getElementById('enableCwDsp').checked = false;
        this.cwDspEnabled = false;
        this.updateCwDspStatus();
        return;
    }
    
    try {
        // Disconnect existing audio routing
        this.disconnectAudioRouting();
        
        // Create new DSP filter chain
        if (!this.createCwDspFilterChain()) {
            throw new Error('Failed to create DSP filter chain');
        }
        
        // Reconnect with DSP filters in the chain
        this.connectAudioRoutingWithDsp();
        
        this.logCAT(`CW DSP enabled: ${this.cwBandwidth} Hz bandwidth`, 'info');
        
    } catch (error) {
        console.error('Error enabling CW DSP:', error);
        this.logCAT(`CW DSP enable error: ${error.message}`, 'error');
        this.cwDspEnabled = false;
        document.getElementById('enableCwDsp').checked = false;
        this.updateCwDspStatus();
    }
}

disableCwDspProcessing() {
    try {
        // Disconnect DSP filter chain
        this.disconnectCwDspFilterChain();
        
        // Reconnect direct audio routing
        this.connectDirectAudioRouting();
        
        this.logCAT('CW DSP disabled - direct audio routing restored', 'info');
        
    } catch (error) {
        console.error('Error disabling CW DSP:', error);
        this.logCAT(`CW DSP disable error: ${error.message}`, 'error');
    }
}

updateCwDspFilters() {
    if (!this.cwDspEnabled || !this.isAudioStreaming) return;
    
    try {
        // Smoothly update filter parameters to avoid audio artifacts
        const centerFreq = this.targetPitch;
        const bandwidth = this.cwBandwidth;
        const lowCutoff = Math.max(50, centerFreq - (bandwidth / 2));
        const highCutoff = Math.min(this.audioContext.sampleRate / 2 - 100, centerFreq + (bandwidth / 2));
        
        // Update filter frequencies with smooth transitions (100ms ramp)
        const rampTime = this.audioContext.currentTime + 0.1;
        
        this.cwDspFilters.forEach((filter, index) => {
            if (filter.type === 'highpass') {
                const freq = index === 0 ? lowCutoff : lowCutoff + 5;
                filter.frequency.linearRampToValueAtTime(freq, rampTime);
            } else if (filter.type === 'lowpass') {
                const freq = index === 1 ? highCutoff : highCutoff - 5;
                filter.frequency.linearRampToValueAtTime(freq, rampTime);
            } else if (filter.type === 'bandpass') {
                filter.frequency.linearRampToValueAtTime(centerFreq, rampTime);
                filter.Q.value = centerFreq / bandwidth * 0.8;
            }
        });
        
        // Update gain compensation
        if (this.cwDspGainNode) {
            const newGain = this.calculateGainCompensation(bandwidth);
            this.cwDspGainNode.gain.linearRampToValueAtTime(newGain, rampTime);
        }
        
        console.log(`CW DSP filters updated: ${lowCutoff.toFixed(1)} - ${highCutoff.toFixed(1)} Hz`);
        
    } catch (error) {
        console.error('Error updating CW DSP filters:', error);
    }
}

disconnectAudioRouting() {
    try {
        if (this.inputSource) this.inputSource.disconnect();
        if (this.gainNode) this.gainNode.disconnect();
        if (this.inputAnalyser) this.inputAnalyser.disconnect();
    } catch (error) {
        console.error('Error disconnecting audio routing:', error);
    }
}

connectAudioRoutingWithDsp() {
    try {
        // Disconnect any existing connections first
        this.disconnectAudioRouting();
        
        // Route: Input -> Main Gain -> DSP Filters -> Speakers
        //                          \-> Analyser (unfiltered for spectrum)
        
        // Connect input to main gain
        this.inputSource.connect(this.gainNode);
        
        // Connect main gain to spectrum analyser (unfiltered view)
        this.gainNode.connect(this.inputAnalyser);
        
        // Connect DSP chain: gainNode -> filters -> speakers
        this.connectCwDspFilterChain(this.gainNode, this.audioContext.destination);
        
        console.log('Audio routing connected with CW DSP processing');
        console.log('Spectrum shows unfiltered signal, speakers get filtered audio');
        
    } catch (error) {
        console.error('Error connecting audio routing with DSP:', error);
        throw error;
    }
}

connectDirectAudioRouting() {
    try {
        // Route: Input -> Main Gain -> Analyser -> Output (no DSP)
        this.inputSource.connect(this.gainNode);
        this.gainNode.connect(this.inputAnalyser);
        this.gainNode.connect(this.audioContext.destination);
        
        console.log('Direct audio routing connected (no DSP)');
        
    } catch (error) {
        console.error('Error connecting direct audio routing:', error);
        throw error;
    }
}

updateCwDspStatus() {
    const statusElement = document.getElementById('cwDspStatus');
    if (!statusElement) return;
    
    if (this.cwDspEnabled && this.mode === 'CW') {
        statusElement.textContent = `DSP Filter: ${this.cwBandwidth} Hz`;
        statusElement.style.color = 'var(--accent-color)';
    } else if (this.mode !== 'CW') {
        statusElement.textContent = 'DSP Filter: CW Mode Only';
        statusElement.style.color = '#ff9500';
    } else {
        statusElement.textContent = 'DSP Filter: OFF';
        statusElement.style.color = '#888';
    }
}

updateSpectrumBandwidth() {
    // Update spectrum display bandwidth based on DSP state
    if (this.cwDspEnabled && this.mode === 'CW') {
        // Show narrower spectrum view when DSP is active
        this.spectrumBandwidth = Math.max(this.cwBandwidth * 3, 500); // At least 3x filter bandwidth
    } else if (this.mode === 'CW') {
        this.spectrumBandwidth = 1200; // Standard CW spectrum view
    } else {
        this.spectrumBandwidth = 2400; // Standard SSB spectrum view
    }
    
    console.log(`Spectrum bandwidth updated: ${this.spectrumBandwidth} Hz`);
}

            initVolumeControl() {
                try {
                    const volumeKnob = document.getElementById('volumeKnob');
                    volumeKnob.setAttribute('tabindex', '0');                   
				   this.updateVolumeUI();
                    volumeKnob.addEventListener('mousedown', this.startVolumeAdjust.bind(this));
                    volumeKnob.addEventListener('touchstart', this.startVolumeAdjust.bind(this), { passive: false });
                    volumeKnob.addEventListener('wheel', this.handleVolumeWheel.bind(this));
                    volumeKnob.addEventListener('keydown', this.handleVolumeKeyboard.bind(this));
                    console.log('Volume control initialized');
                } catch (error) {
                    console.error('Error initializing volume control:', error);
                }
            }

            startVolumeAdjust(e) {
                e.preventDefault();
                this.isVolumeAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueVolumeAdjust = this.continueVolumeAdjust.bind(this);
                this.boundStopVolumeAdjust = this.stopVolumeAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.volumeLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.addEventListener('mouseup', this.boundStopVolumeAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.volumeLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueVolumeAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopVolumeAdjust);
                }
            }

            continueVolumeAdjust(e) {
                if (!this.isVolumeAdjusting) return;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    const volumeKnob = document.getElementById('volumeKnob');
                    const rect = volumeKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.volumeLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 1.2;
                    deltaAngle *= sensitivity;
                    const newRotation = this.volumeKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.volumeKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    volumeKnob.style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                    const newVolumeLevel = Math.round(((this.volumeKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newVolumeLevel !== this.volumeLevel) {
                        this.volumeLevel = newVolumeLevel;
                        this.updateVolumeUI();
                        this.sendVolumeDynamically();
                    }
                    this.volumeLastAngle = currentAngle;
                    this.volumeAnimationFrame = null;
                });
            }

            stopVolumeAdjust() {
                this.isVolumeAdjusting = false;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                    this.volumeAnimationFrame = null;
                }
                if (this.boundContinueVolumeAdjust && this.boundStopVolumeAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('mouseup', this.boundStopVolumeAdjust);
                    document.removeEventListener('touchmove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('touchend', this.boundStopVolumeAdjust);
                    this.boundContinueVolumeAdjust = null;
                    this.boundStopVolumeAdjust = null;
                }
                this.sendVolumeCommand();
            }

            handleVolumeKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustVolume(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustVolume(5);
                }
            }

            handleVolumeWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const volumeDelta = steps * 5;
                this.adjustVolume(volumeDelta);
            }

            adjustVolume(delta) {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel + delta));
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    this.updateVolumeUI();
                    this.sendVolumeCommand();
                    this.volumeAnimationFrame = null;
                });
            }
			
            updateVolumeUI() {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel));
                this.volumeKnobRotation = this.minRotation + (this.volumeLevel / 100) * this.totalRotationRange;
                document.getElementById('volumeKnob').style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                document.getElementById('volumeLevel').textContent = `${this.volumeLevel}db`;
                document.getElementById('volumeKnob').setAttribute('aria-valuenow', this.volumeLevel);
            }

        // Replace the existing sendVolumeDynamically method
sendVolumeDynamically() {
    if (this.volumeTimeout) {
        clearTimeout(this.volumeTimeout);
    }
    // Increased timeout to prevent rapid fire commands
    this.volumeTimeout = setTimeout(() => {
        if (this.connected && this.port && this.writer && !this.volumeCommandPending) {
            this.volumeCommandPending = true; // Prevent multiple simultaneous commands
            const scaledVolume = this.volumeToCAT(this.volumeLevel);
            
            this.sendCommand(`AG${scaledVolume.toString().padStart(3, '0')}`).then(() => {
                // Add delay before allowing next command
                setTimeout(() => {
                    this.volumeCommandPending = false;
                }, 100);
            }).catch(e => {
                console.error("Volume update error:", e);
                this.volumeCommandPending = false;
            });
        }
        this.volumeTimeout = null;
    }, 150); // Increased from 50ms to 150ms
}

        async sendVolumeCommand() {
    if (!this.connected || !this.port || !this.writer || this.volumeCommandPending) return;
    try {
        this.volumeCommandPending = true;
        const scaledVolume = this.volumeToCAT(this.volumeLevel);
        await this.sendCommand(`AG${scaledVolume.toString().padStart(3, '0')}`);
        this.logCAT(`Volume set to ${this.volumeLevel}%`, 'info');
        
        // Prevent feedback for a short time
        this.volumeFeedbackBlock = true;
        setTimeout(() => {
            this.volumeFeedbackBlock = false;
            this.volumeCommandPending = false;
        }, 200);
    } catch (e) {
        this.logCAT(`Volume command error: ${e.message}`, 'error');
        this.volumeCommandPending = false;
    }
}

          // Improved volume conversion with better accuracy
volumeToCAT(volumePercent) {
    if (volumePercent <= 0) return 0;
    if (volumePercent >= 100) return 255;
    
    // Use a more accurate logarithmic scaling
    const normalizedInput = volumePercent / 100;
    const logScaled = Math.pow(normalizedInput, 1.5) * 255;
    return Math.round(Math.max(0, Math.min(255, logScaled)));
}

// Improved reverse conversion
catToVolume(catValue) {
    if (catValue <= 0) return 0;
    if (catValue >= 255) return 100;
    
    const normalized = catValue / 255;
    const volumePercent = Math.pow(normalized, 1/1.5) * 100;
    return Math.round(Math.max(0, Math.min(100, volumePercent)));
}

    // Add this line at the end of initRFGainControl():
initRFGainControl() {
    try {
        const rfGainKnob = document.getElementById('rfGainKnob');
        const rfGainLevel = document.getElementById('rfGainLevel');
        this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
        rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        console.log('RFGaincontrol');
        this.updateRFGainLevel();
        
        rfGainKnob.addEventListener('mousedown', this.startRFGainAdjust.bind(this));
        rfGainKnob.addEventListener('touchstart', this.startRFGainAdjust.bind(this), { passive: false });
        rfGainKnob.addEventListener('wheel', this.handleRFGainWheel.bind(this));
        rfGainKnob.addEventListener('keydown', this.handleRFGainKeyboard.bind(this));
        rfGainKnob.setAttribute('aria-valuenow', this.rfGainLevel);
        
        // NEW: Add hover keyboard control
       // Add hover keyboard control for CW speed
rfGainKnob.addEventListener('mouseenter', () => {
    this.enableCWSpeedHoverKeys();
});
rfGainKnob.addEventListener('mouseleave', () => {
    this.disableCWSpeedHoverKeys();
});
        
        // Initialize the keyer toggle
        this.initKeyerToggle();
        
        console.log('Keyer initialized with toggle (0=STRAIGHT, 1-50 WPM)');
    } catch (error) {
        console.error('Error initializing Keyer:', error);
    }
}
            startRFGainAdjust(e) {
               
// Don't allow manual adjustment in STRAIGHT mode
    if (this.keyerMode === 'straight') {
        return;
    }
			   e.preventDefault();
                this.isRFGainAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueRFGainAdjust = this.continueRFGainAdjust.bind(this);
                this.boundStopRFGainAdjust = this.stopRFGainAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.rfGainLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueRFGainAdjust);
                    document.addEventListener('mouseup', this.boundStopRFGainAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.rfGainLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueRFGainAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopRFGainAdjust);
                }
            }

            continueRFGainAdjust(e) {
                if (!this.isRFGainAdjusting) return;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    const rfGainKnob = document.getElementById('rfGainKnob');
                    const rect = rfGainKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
                    if (distance < rect.width * 2) {
                        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                        let deltaAngle = currentAngle - this.rfGainLastAngle;
                        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                        const sensitivity = 0.7;
                        deltaAngle *= sensitivity;
                        const newRotation = this.rfGainKnobRotation + (deltaAngle * 180 / Math.PI);
                        this.rfGainKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                        rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                        const newRFGainLevel = Math.round(((this.rfGainKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                        if (newRFGainLevel !== this.rfGainLevel) {
                            this.rfGainLevel = newRFGainLevel;
                            this.updateRFGainLevel();
                            this.sendRFGainDynamically();
                        }
                        this.rfGainLastAngle = currentAngle;
                    }
                    this.rfGainAnimationFrame = null;
                });
            }

            stopRFGainAdjust() {
                this.isRFGainAdjusting = false;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                    this.rfGainAnimationFrame = null;
                }
                if (this.boundContinueRFGainAdjust && this.boundStopRFGainAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueRFGainAdjust);
                    document.removeEventListener('mouseup', this.boundStopRFGainAdjust);
                    document.removeEventListener('touchmove', this.boundContinueRFGainAdjust);
                    document.removeEventListener('touchend', this.boundStopRFGainAdjust);
                    this.boundContinueRFGainAdjust = null;
                    this.boundStopRFGainAdjust = null;
                }
                this.sendRFGainCommand();
            }

            handleRFGainKeyboard(e) {
// Don't allow manual adjustment in STRAIGHT mode
    if (this.keyerMode === 'straight') {
        return;
    }               
			   if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustRFGain(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustRFGain(5);
                }
            }

          handleRFGainWheel(e) {
 // Don't allow manual adjustment in STRAIGHT mode
    if (this.keyerMode === 'straight') {
        return;
    }   
   e.preventDefault();
    let steps = e.deltaY > 0 ? -1 : 1;
    const cwSpeedDelta = steps * 1;
    const currentCWSpeed = Math.round((this.rfGainLevel / 100) * 50);
    const newCWSpeed = Math.max(0, Math.min(50, currentCWSpeed + cwSpeedDelta));
    this.rfGainLevel = (newCWSpeed / 50) * 100;
    this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
    if (this.rfGainAnimationFrame) {
        cancelAnimationFrame(this.rfGainAnimationFrame);
    }
    this.rfGainAnimationFrame = requestAnimationFrame(() => {
        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        this.updateRFGainLevel();
        this.sendRFGainCommand();
        this.rfGainAnimationFrame = null;
    });
}

            adjustRFGain(delta) {
                this.rfGainLevel = Math.max(0, Math.min(100, this.rfGainLevel + delta));
                this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                    this.updateRFGainLevel();
                    this.sendRFGainCommand();
                    this.rfGainAnimationFrame = null;
                });
            }

 
// MODIFY your existing updateRFGainLevel method to show mode info:
updateRFGainLevel() {
    const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
    const rfGainLevelEl = document.getElementById('rfGainLevel');
    
    if (cwSpeed === 0) {
        rfGainLevelEl.textContent = 'STRAIGHT';
        rfGainLevelEl.style.color = '#ff4757';
    } else {
        rfGainLevelEl.textContent = `${cwSpeed} WPM`;
        rfGainLevelEl.style.color = '#00ff88';
    }
    document.getElementById('rfGainKnob').setAttribute('aria-valuenow', cwSpeed);
    
    // Update clone knob
    this.updateCWSpeedCloneUI();
}
           sendRFGainDynamically() {
    if (this.rfGainTimeout) {
        clearTimeout(this.rfGainTimeout);
    }
    this.rfGainTimeout = setTimeout(() => {
        if (this.connected && this.port && this.writer) {
            const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
            this.sendCommand(`KS${cwSpeed.toString().padStart(3, '0')}`).catch(e => {
                console.error("CW Speed update error:", e);
            });
        }
        this.rfGainTimeout = null;
    }, 50);
}

           async sendRFGainCommand() {
    if (!this.connected || !this.port || !this.writer) return;
    try {
        const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
        await this.sendCommand(`KS${cwSpeed.toString().padStart(3, '0')}`);
        if (cwSpeed === 0) {
            this.logCAT(`Keyer set to STRAIGHT KEY mode`, 'info');
        } else {
            this.logCAT(`CW Speed set to ${cwSpeed} WPM`, 'info');
        }
    } catch (e) {
        this.logCAT(`CW Speed command error: ${e.message}`, 'error');
    }
}

            initPowerControl() {
                try {
                    const powerKnob = document.getElementById('powerKnob');
                    const powerLevel = document.getElementById('powerLevel');
                    this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    powerKnob.style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    powerLevel.textContent = `${(this.powerLevel / 10).toFixed(1)}W`;
                    powerKnob.addEventListener('mousedown', this.startPowerAdjust.bind(this));
                    powerKnob.addEventListener('touchstart', this.startPowerAdjust.bind(this), { passive: false });
                    powerKnob.addEventListener('wheel', this.handlePowerWheel.bind(this));
                    powerKnob.addEventListener('keydown', this.handlePowerKeyboard.bind(this));
                    powerKnob.setAttribute('aria-valuenow', this.powerLevel);
                    console.log('Power control initialized at', (this.powerLevel / 10).toFixed(1), 'W');
                } catch (error) {
                    console.error('Error initializing Power control:', error);
                }
            }

            startPowerAdjust(e) {
                e.preventDefault();
                this.isPowerAdjusting = true;
                this.powerLevelBeforeAdjust = this.powerLevel;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinuePowerAdjust = this.continuePowerAdjust.bind(this);
                this.boundStopPowerAdjust = this.stopPowerAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.powerLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinuePowerAdjust);
                    document.addEventListener('mouseup', this.boundStopPowerAdjust);
                    document.addEventListener('mouseleave', this.boundStopPowerAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.powerLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinuePowerAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopPowerAdjust);
                    document.addEventListener('touchcancel', this.boundStopPowerAdjust);
                }
            }

            continuePowerAdjust(e) {
                if (!this.isPowerAdjusting) return;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                }
                this.powerAnimationFrame = requestAnimationFrame(() => {
                    const powerKnob = document.getElementById('powerKnob');
                    const rect = powerKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.powerLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 0.7;
                    deltaAngle *= sensitivity;
                    const newRotation = this.powerKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.powerKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    powerKnob.style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    const normalizedRotation = (this.powerKnobRotation - this.minRotation) / this.totalRotationRange;
                    const newPowerLevel = Math.round(normalizedRotation * 50);
                    if (newPowerLevel !== this.powerLevel && newPowerLevel >= 0 && newPowerLevel <= 50) {
                        this.powerLevel = newPowerLevel;
                        this.updatePowerLevel();
                        this.sendPowerDynamically();
                    }
                    this.powerLastAngle = currentAngle;
                    this.powerAnimationFrame = null;
                });
            }

            stopPowerAdjust() {
                this.isPowerAdjusting = false;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                    this.powerAnimationFrame = null;
                }
                if (this.boundContinuePowerAdjust && this.boundStopPowerAdjust) {
                    document.removeEventListener('mousemove', this.boundContinuePowerAdjust);
                    document.removeEventListener('mouseup', this.boundStopPowerAdjust);
                    document.removeEventListener('mouseleave', this.boundStopPowerAdjust);
                    document.removeEventListener('touchmove', this.boundContinuePowerAdjust);
                    document.removeEventListener('touchend', this.boundStopPowerAdjust);
                    document.removeEventListener('touchcancel', this.boundStopPowerAdjust);
                    this.boundContinuePowerAdjust = null;
                    this.boundStopPowerAdjust = null;
                }
                if (this.powerLevel < 0 || this.powerLevel > 50 || isNaN(this.powerLevel)) {
                    this.powerLevel = this.powerLevelBeforeAdjust || 50;
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                }
                this.updatePowerLevel();
                this.sendPowerCommand();
            }

            handlePowerKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustPower(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustPower(5);
                }
            }

            handlePowerWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const powerDelta = steps * 5;
                this.adjustPower(powerDelta);
            }

            adjustPower(delta) {
                this.powerLevel = Math.max(0, Math.min(50, this.powerLevel + delta));
                this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                }
                this.powerAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    this.updatePowerLevel();
                    this.sendPowerCommand();
                    this.powerAnimationFrame = null;
                });
            }

            updatePowerLevel() {
                const previousLevel = this.powerLevel;
                this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                if (previousLevel > 0 && this.powerLevel === 0 && !this.isPowerAdjusting) {
                    console.warn('Power level unexpectedly dropped to 0 from', previousLevel);
                }
                const watts = (this.powerLevel / 10).toFixed(1);
                document.getElementById('powerLevel').textContent = `${watts}W`;
                document.getElementById('powerKnob').setAttribute('aria-valuenow', this.powerLevel);
            }

            sendPowerDynamically() {
                if (this.powerTimeout) {
                    clearTimeout(this.powerTimeout);
                }
                this.powerTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const validPowerLevel = Math.max(0, Math.min(50, this.powerLevel));
                        this.sendCommand(`PC${validPowerLevel.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Power update error:", e);
                        });
                    }
                    this.powerTimeout = null;
                }, 50);
            }

            async sendPowerCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                    await this.sendCommand(`PC${this.powerLevel.toString().padStart(3, '0')}`);
                    this.logCAT(`Power set to ${(this.powerLevel / 10).toFixed(1)}W`, 'info');
                } catch (e) {
                    this.logCAT(`Power command error: ${e.message}`, 'error');
                }
            }
			 initTuningKnob() {
    try {
        const tuningKnob = document.getElementById('tuningKnob');
        this.createFrequencyMarkings();
        this.tuningKnobRotation = 0;
        tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
        
        // Existing event listeners
        tuningKnob.addEventListener('mousedown', this.startTuningAdjust.bind(this));
        tuningKnob.addEventListener('touchstart', this.startTuningAdjust.bind(this), { passive: false });
        tuningKnob.addEventListener('wheel', this.handleTuningWheel.bind(this));
        tuningKnob.addEventListener('keydown', this.handleTuningKeyboard.bind(this));
        
        // NEW: Add hover keyboard control
        tuningKnob.addEventListener('mouseenter', this.enableTuningHoverKeys.bind(this));
        tuningKnob.addEventListener('mouseleave', this.disableTuningHoverKeys.bind(this));
        
        tuningKnob.setAttribute('aria-valuenow', this.frequency);
        console.log('CSS tuning knob initialized with hover keyboard control');
    } catch (error) {
        console.error('Error initializing tuning knob:', error);
    }
}

            createFrequencyMarkings() {
                const markingsContainer = document.getElementById('frequencyMarkings');
                markingsContainer.innerHTML = '';
                for (let i = 0; i < 72; i++) {
                    const angle = (i / 72) * 360;
                    const isLarge = i % 6 === 0;
                    const mark = document.createElement('div');
                    mark.className = `frequency-mark ${isLarge ? 'major' : 'minor'}`;
                    mark.style.transform = `rotate(${angle}deg) translate(0, -140px)`;
                    mark.style.left = '50%';
                    mark.style.top = '50%';
                    mark.style.marginLeft = isLarge ? '-1.5px' : '-0.5px';
                    mark.style.marginTop = isLarge ? '-10px' : '-5px';
                    markingsContainer.appendChild(mark);
                }
            }

            startTuningAdjust(e) {
                e.preventDefault();
                this.isTuningAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueTuningAdjust = this.continueTuningAdjust.bind(this);
                this.boundStopTuningAdjust = this.stopTuningAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.tuningLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.addEventListener('mouseup', this.boundStopTuningAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.tuningLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueTuningAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopTuningAdjust);
                }
            }

// REPLACE your existing continueTuningAdjust method with this enhanced version:
continueTuningAdjust(e) {
    if (!this.isTuningAdjusting) return;
    if (this.tuningAnimationFrame) {
        cancelAnimationFrame(this.tuningAnimationFrame);
    }
    this.tuningAnimationFrame = requestAnimationFrame(() => {
        const tuningKnob = document.getElementById('tuningKnob');
        const rect = tuningKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let currentX, currentY;
        
        if (e.type === 'mousemove') {
            currentX = e.clientX;
            currentY = e.clientY;
        } else if (e.type === 'touchmove') {
            e.preventDefault();
            const t = e.touches[0];
            currentX = t.clientX;
            currentY = t.clientY;
        }
        
        const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
        if (distance < rect.width * 2) {
            const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
            let deltaAngle = currentAngle - this.tuningLastAngle;
            if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
            if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
            
            // NEW: Calculate tuning speed
            const now = performance.now();
            const timeDelta = now - this.lastTuningTime;
            const angleDelta = Math.abs(deltaAngle);
            
            if (timeDelta > 0) {
                const speed = angleDelta / (timeDelta / 1000); // radians per second
                this.updateTuningSpeed(speed);
            }
            this.lastTuningTime = now;
            
            const sensitivity = 1.5;
            deltaAngle *= sensitivity;
            this.tuningKnobRotation += (deltaAngle * 180 / Math.PI);
            tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
            
            // NEW: Use variable step size
            const currentStepSize = this.getCurrentStepSize();
            const freqDelta = (deltaAngle * 180 / Math.PI) * currentStepSize * 0.3;
            
            if (Math.abs(freqDelta) > 0.1) {
                this.updateFrequency(freqDelta);
                this.sendFrequencyImmediate();
            }
            this.tuningLastAngle = currentAngle;
        }
        this.tuningAnimationFrame = null;
    });
}

            stopTuningAdjust() {
                this.isTuningAdjusting = false;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                    this.tuningAnimationFrame = null;
                }
                if (this.boundContinueTuningAdjust && this.boundStopTuningAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.removeEventListener('mouseup', this.boundStopTuningAdjust);
                    document.removeEventListener('touchmove', this.boundContinueTuningAdjust);
                    document.removeEventListener('touchend', this.boundStopTuningAdjust);
                    this.boundContinueTuningAdjust = null;
                    this.boundStopTuningAdjust = null;
                }
                this.sendFrequencyImmediate();
				this.triggerAutotuneScan(); // Add this line
            }

           handleTuningWheel(e) {
    e.preventDefault();
    
    // NEW: Track wheel speed
    const now = performance.now();
    const timeDelta = now - this.lastTuningTime;
    const wheelSpeed = Math.abs(e.deltaY) / Math.max(timeDelta, 16); // Normalize speed
    this.updateTuningSpeed(wheelSpeed * 0.1); // Scale wheel speed
    this.lastTuningTime = now;
    
    let steps;
    if (Math.abs(e.deltaY) < 50) {
        steps = e.deltaY > 0 ? -1 : 1;
    } else {
        steps = e.deltaY > 0 ? -1 : 1;
    }
    
    // NEW: Use variable step size
    const currentStepSize = this.getCurrentStepSize();
    const freqDelta = steps * currentStepSize;
    
    this.updateFrequency(freqDelta);
    const rotationDelta = steps * 2;
    this.tuningKnobRotation += rotationDelta;
    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
    this.sendFrequencyDynamically();
	this.triggerAutotuneScan(); // Add this line
	
	
 
	
}

            handleTuningKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustFrequency(-this.stepSize);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustFrequency(this.stepSize);
                }
            }

            adjustFrequency(delta) {
                this.updateFrequency(delta);
                const rotationDelta = (delta / this.stepSize) * 2;
                this.tuningKnobRotation += rotationDelta;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    this.sendFrequencyImmediate();
                    this.tuningAnimationFrame = null;
                });
            }

           sendFrequencyImmediate() {
  
    // Use the new combo function to set frequency and restore gain
    this.setFrequencyAndRestoreGain(this.frequency);

}

           sendFrequencyDynamically() {
   this.setFrequencyAndRestoreGain(this.frequency);
}
			
            startPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                this.pollingInterval = setInterval(async () => {
                    if (this.connected) {
                        await this.sendCommand('IF');
                        await this.sendCommand('LC');
                        await this.sendCommand('SM');
                        await this.sendCommand('SW');
                        await this.sendCommand('KS');
						await this.sendCommand('AG0');
						await this.sendCommand('PC');
						await this.sendCommand('RT');  // Poll RIT status
                    }
					

					
					
					
					
					
                }, 350);
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                }
            }

          parseIfResponse(data) {
    try {
        const freq = parseInt(data.substring(0, 11));
		  // --- ADD THIS LOGIC BLOCK ---
                    // Check if we manually set the frequency within the last 2 seconds.
                    // If so, ignore the (potentially rounded) frequency from the radio's report.
                    const timeSinceLastSet = Date.now() - this.lastManualFreqSet;
                    if (timeSinceLastSet < 2000) {
                         // We still process the rest of the IF response (like TX status), just not the frequency.
                    } else if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                    // --- END OF NEW LOGIC ---
        if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
            this.frequency = freq;
            this.updateDisplay(); // This will now trigger band auto-selection
            document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
        }
        const txStatus = data.substring(26, 27);
        const isTransmitting = (txStatus === '1');
        if (isTransmitting !== this.transmitting) {
            this.transmitting = isTransmitting;
            this.updateTXStatus();
        }
        const catMode = data.substring(27, 28);
        this.updateModeFromCAT(catMode);
    } catch (error) {
        this.logCAT(`Error parsing IF response: ${error.message}`, 'error');
    }
	 }

          async sendFrequencyCommand() {
    if (!this.connected || !this.port || !this.writer) return;
    try {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        await this.sendCommand(`${vfoCommand}${freqStr}`);
        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
        const displayStr = this.frequency.toString().padStart(9, '0');
        const mhz = displayStr.substring(0, 3);
        const khz = displayStr.substring(3, 6); 
        const hz = displayStr.substring(6, 9);
        this.logCAT(`VFO ${this.currentVFO} frequency set to ${mhz}.${khz}.${hz} Hz`, 'info');
    } catch (e) {
        this.logCAT(`Frequency command error: ${e.message}`, 'error');
    }
}

          async updateFrequency(delta) {
    const oldFreq = this.frequency;
    this.frequency += delta;
    this.frequency = Math.max(100000, Math.min(999999999, this.frequency));
    this.frequency = Math.round(this.frequency);
    
    // NEW: Add visual effects
   // this.createFrequencyParticles();
   if (Math.abs(delta) > 1000) {
    this.animateFrequencyChange(oldFreq, this.frequency);
}
     //this.animateFrequencyText(freqDelta);     // <-- ADD
   this.animateLCDDigits()
    this.updateDisplay();
    this.saveLastFrequency();
}

// Modify setBandFrequency to add animation:
setBandFrequency(band) {
    if (this.lastFrequencies[band]) {
        this.frequency = this.lastFrequencies[band];
        
        // NEW: Add band change animation
        this.showBandChangeAnimation(band);
        if (this.sounds) this.sounds.click();
        
        this.updateDisplay();
        if (this.connected) {
            this.setFrequencyAndRestoreGain(this.frequency);
        }
    }
}


            async connectSerial() {
                try {
                    if (!navigator.serial) {
                        this.logCAT('WebSerial API not supported', 'error');
                        return false;
                    }

                    const selectedBaud = parseInt(document.getElementById('baudRate').value);
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ 
                        baudRate: selectedBaud,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    
                    this.connected = true;
					if (this.sounds) this.sounds.connect();
                    this.lastCommandTime = Date.now();
                    this.updateConnectionStatus();
                    this.logCAT(`Serial connected at ${selectedBaud} baud`, 'rx');
                    await this.sendCommand('QB0');
                    await this.sendCommand('Q90'); 
                    
                    this.startReading();
                    this.startConnectionHealthCheck();
                    await this.initializeRadio();
                    this.startPolling();
                    return true;
                } catch (error) {
                    this.logCAT(`Connection failed: ${error.message}`, 'error');
                    this.connected = false;
                    this.updateConnectionStatus();
                    return false;
                }
            }

            async disconnectSerial() {
                try {
                    this.connected = false;
                    if (this.port) {
                        await this.sendCommand('QB1');
                    }
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.stopPolling();
                    if (this.reader) {
                        try {
                            await this.reader.cancel();
                        } catch (e) {
                            console.log('Reader cancel error:', e);
                        }
                        try {
                            await this.reader.releaseLock();
                        } catch (e) {
                            console.log('Reader release error:', e);
                        }
                        this.reader = null;
                    }
                    if (this.writer) {
                        try {
                            await this.writer.releaseLock();
                        } catch (e) {
                            console.log('Writer release error:', e);
                        }
                        this.writer = null;
                    }
                    if (this.port) {
                        try {
                            await this.port.close();
                        } catch (e) {
                            console.log('Port close error:', e);
                        }
                        this.port = null;
                    }
                    this.logCAT('Serial disconnected', 'rx');
                } catch (error) {
                    this.connected = false;
                    this.reader = null;
                    this.writer = null;
                    this.port = null;
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.logCAT(`Disconnect error: ${error.message}`, 'rx');
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.connected && this.reader) {
                        try {
                            const { value, done } = await this.reader.read();
                            if (done) {
                                this.logCAT('Hardware disconnected', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            }
                            const text = new TextDecoder().decode(value);
                            buffer += text;
                            this.lastCommandTime = Date.now();
                            while (buffer.includes(';')) {
                                const end = buffer.indexOf(';');
                                const response = buffer.substring(0, end);
                                buffer = buffer.substring(end + 1);
                                if (response.trim()) {
                                    this.processResponse(response.trim());
                                }
                            }
                        } catch (readError) {
                            if (readError.name === 'NetworkError' || 
                                readError.message.includes('device has been lost') ||
                                readError.message.includes('The port is not open') ||
                                readError.code === 19) {
                                this.logCAT('Hardware disconnected during read', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            } else {
                                this.logCAT(`Read error: ${readError.message}`, 'error');
                            }
                        }
                    }
                } catch (error) {
                    this.logCAT(`Reader stream error: ${error.message}`, 'error');
                    if (this.connected) {
                        this.handleHardwareDisconnect();
                    }
                }
            }

            async sendCommand(command) {
                if (!this.connected || !this.writer) {
                    return null;
                }
                try {
                    const fullCommand = command + ';';
                    const data = new TextEncoder().encode(fullCommand);
                    await this.writer.write(data);
                    this.logCAT(command, 'tx');
                    this.lastCommandTime = Date.now();
                    return true;
                } catch (error) {
                    if (error.name === 'NetworkError' || 
                        error.message.includes('device has been lost') ||
                        error.message.includes('The port is not open') ||
                        error.code === 19) {
                        this.logCAT('Hardware disconnected during command', 'error');
                        this.handleHardwareDisconnect();
                    } else {
                        this.logCAT(`Send error: ${error.message}`, 'error');
                    }
                    return false;
                }
            }

            handleHardwareDisconnect() {
                if (!this.connected) return;
                this.connected = false;
                this.reader = null;
                this.writer = null;
                this.port = null;
                if (this.connectionCheckTimeout) {
                    clearTimeout(this.connectionCheckTimeout);
                    this.connectionCheckTimeout = null;
                }
                this.updateConnectionStatus();
                this.logCAT('Auto-disconnect complete', 'rx');
            }

            startConnectionHealthCheck() {
                if (!this.connected) return;
                const now = Date.now();
                const timeSinceLastCommand = now - this.lastCommandTime;
                if (timeSinceLastCommand > 10000 && this.connected) {
                    this.sendCommand('ID').catch(() => {
                        this.logCAT('Connection health check failed', 'error');
                        this.handleHardwareDisconnect();
                    });
                }
                this.connectionCheckTimeout = setTimeout(() => {
                    this.startConnectionHealthCheck();
                }, 5000);
            }
			
			
			
			
	//-----------------------------------------------------------		
			
			
			
			

 processResponse(response) {
            this.logCAT(response, 'rx');
            
            if (response.startsWith('IF')) {
                this.parseIfResponse(response.substring(2));
            } else if (response.startsWith('LC')) {
                let lcdData = response.substring(2).padEnd(32, ' ');
                this.updateLcdDisplay(lcdData.substring(0, 16), lcdData.substring(16, 32));
          } else if (response.startsWith('AG')) {
    const gain = parseInt(response.substring(2));
    if (!isNaN(gain) && !this.isVolumeAdjusting && !this.volumeFeedbackBlock) {
        const newVolumeLevel = this.catToVolume(gain);
        // Only update if significantly different (reduces jitter)
        if (Math.abs(newVolumeLevel - this.volumeLevel) > 2) {
            this.volumeLevel = newVolumeLevel;
            this.updateVolumeUI();
        }
    }

            } else if (response.startsWith('FA')) {
                const freq = parseInt(response.substring(2));
                if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'A') {
                    this.frequency = freq;
                    this.updateDisplay();
                    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                }
            } else if (response.startsWith('FB')) {
                const freq = parseInt(response.substring(2));
                if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'B') {
                    this.frequency = freq;
                    this.updateDisplay();
                    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                }
            } else if (response.startsWith('SM')) {
                const smeterValue = parseInt(response.substring(2));
                if (!isNaN(smeterValue)) {
                    const smeterPercent = Math.max(0, Math.min(100, (smeterValue / 255) * 100));
                    this.updateSMeter(smeterPercent);
                    this.updateSMeterLabel(smeterPercent);
                }
            } else if (response.startsWith('SW')) {
                const swrResponse = response.substring(2);
                if (swrResponse.length > 0) {
                    const swrHundredths = parseInt(swrResponse);
                    if (!isNaN(swrHundredths)) {
                        const actualSWR = swrHundredths / 100;
                        const swrPercent = Math.max(0, Math.min(100, ((actualSWR - 1.0) / 2.0) * 100));
                        this.updateSWRMeter(swrPercent);
                    }
                } else {
                    this.updateSWRMeter(0); // RX mode
                }
        } else if (response.startsWith('PC')) {
    const powerTenths = parseInt(response.substring(2));

	if (!isNaN(powerTenths)) {
        // Update the power meter display
        this.updatePowerMeter(powerTenths);
		//console.log('Powermeter working');
    }

            } else if (response.startsWith('MD')) {
                this.updateModeFromCAT(response.substring(2));
            } else if (response.startsWith('KS')) {
                const wpm = parseInt(response.substring(2));
                if (!isNaN(wpm) && !this.isRFGainAdjusting && wpm >= 0 && wpm <= 50) {
                    this.rfGainLevel = (wpm / 50) * 100;
                    this.updateRFGainLevel();
                    this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                    document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                }
            } else if (response.startsWith('TX')) {
                this.transmitting = true;
                this.updateTXStatus();
            } else if (response.startsWith('RX')) {
                this.transmitting = false;
                this.updateTXStatus();
            } else if (response.startsWith('RT')) {
                const ritStatus = response.substring(2);
                if (ritStatus === '0' || ritStatus === '1') {
                    this.ritEnabled = (ritStatus === '1');
                    this.updateRITUI();
                    if (!this.isRITAdjusting) {
                        this.logCAT(`RIT status: ${this.ritEnabled ? 'ON' : 'OFF'}`, 'rx');
                    }
                }
            } else if (response.startsWith('RD') || response.startsWith('RU')) {
                const offsetStr = response.substring(2);
                const offsetValue = parseInt(offsetStr);
                if (!isNaN(offsetValue) && !this.isRITAdjusting) {
                    this.ritOffset = response.startsWith('RD') ? -offsetValue : offsetValue;
                    this.updateRITUI();
                }
           
			
			
			
			// Add this to your processResponse() method
} else if (response.startsWith('KY')) {
    const status = response.trim();
    this.cwKeyer.bufferStatus = status;
    
    if (status === 'KY2') {
        // Buffer empty - transmission complete
        if (this.cwKeyer.isSending) {
            this.cwKeyer.isSending = false;
            this.cwKeyer.sendingMessage = '';
            this.updateCWKeyerUI();
            this.logCAT('CW transmission completed', 'info');
        }
    } else if (status === 'KY0') {
        // Buffer <75% full
        document.getElementById('cwKeyerStatus').textContent = 'Sending... (buffer <75%)';
    } else if (status === 'KY1') {
        // Buffer >75% full
        document.getElementById('cwKeyerStatus').textContent = 'Sending... (buffer >75%)';
    } else if (status === '?') {
        // Buffer overflow
        this.cwKeyer.isSending = false;
        this.updateCWKeyerUI();
        this.logCAT('CW buffer overflow - message cancelled', 'error');
    }
			
	 }		
		
			
			
			
			
			
        } // This is the single, correct closing brace for the function

//----------------------------------------------------------


updateSMeterLabel(percentage) {
    // Convert percentage to S-units (S1-S9, then +10, +20, etc.)
    let label;
    if (percentage <= 50) {
        // S1 through S9
        const sUnits = Math.floor((percentage / 50) * 9) + 1;
        label = `S${sUnits}`;
    } else {
        // S9+ readings
        const overS9 = Math.floor((percentage - 50) / 10) * 10;
        label = `S9+${overS9}`;
    }
    
    // Update label if element exists
    const sMeterText = document.getElementById('sMeterText');
    if (sMeterText) {
        sMeterText.textContent = label;
    }
}










//______________________________________________________________________
        
 /*      // Modify the initFrequencyKeyboard method to include this at the end:
initFrequencyKeyboard() {
    // ... existing code ...
    
    // NEW: Initialize permanent frequency input
    this.initPermanentFreqInput();
    
    // NEW: Add mode toggle listener
    document.getElementById('freqInputMode').addEventListener('change', (e) => {
        this.setFreqInputMode(e.target.value);
    });
}*/

// NEW: Add these methods
initPermanentFreqInput() {
    this.freqInputModePerm = 'mhz';
    this.freqInputValuePerm = '';
    
    // Format buttons for permanent panel
    document.querySelectorAll('[data-target="permanent"].freq-format-btn').forEach(btn => {
        btn.addEventListener('click', () => this.setFreqInputFormatPerm(btn.dataset.format));
    });
    
    // Keypad buttons for permanent panel
    document.querySelectorAll('[data-target="permanent"].freq-key').forEach(key => {
        key.addEventListener('click', () => this.handleFreqKeyInputPerm(key.dataset.key));
    });
    
    // Action buttons for permanent panel
    document.getElementById('freqSetBtnPerm').addEventListener('click', () => this.setFrequencyFromInputPerm());
    document.getElementById('freqClearBtnPerm').addEventListener('click', () => this.clearFreqInputPerm());
    
    // Input field events for permanent panel
    const freqInputPerm = document.getElementById('freqDisplayInputPerm');
    freqInputPerm.addEventListener('input', (e) => this.handleFreqInputChangePerm(e));
    freqInputPerm.addEventListener('keydown', (e) => this.handleFreqInputKeyboardPerm(e));
}

setFreqInputMode(mode) {
    const permanentPanel = document.getElementById('freqInputPermanentPanel');
    const lcdPanel = document.getElementById('lcdPanel');
    
    if (mode === 'permanent') {
        permanentPanel.style.display = 'block';
        // Update the input with current frequency
        this.freqInputValuePerm = this.formatFrequencyForInput(this.frequency, this.freqInputModePerm);
        document.getElementById('freqDisplayInputPerm').value = this.freqInputValuePerm;
        // Disable LCD click for popup
        lcdPanel.style.pointerEvents = 'none';
        lcdPanel.style.opacity = '0.8';
        lcdPanel.style.cursor = 'not-allowed';
        this.logCAT('Frequency input: Permanent mode enabled', 'info');
    } else {
        // Popup mode
        permanentPanel.style.display = 'none';
        // Re-enable LCD click for popup
        lcdPanel.style.pointerEvents = 'auto';
        lcdPanel.style.opacity = '1';
        lcdPanel.style.cursor = 'pointer';
        this.logCAT('Frequency input: Popup mode enabled', 'info');
    }
    
    // Update the dropdown to reflect the current mode
    const modeSelect = document.getElementById('freqInputMode');
    if (modeSelect.value !== mode) {
        modeSelect.value = mode;
    }
}
setFreqInputFormatPerm(format) {
    this.freqInputModePerm = format;
    
    // Update active button
    document.querySelectorAll('[data-target="permanent"].freq-format-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.format === format) {
            btn.classList.add('active');
        }
    });
    
    // Update the input field with current frequency in new format
    this.freqInputValuePerm = this.formatFrequencyForInput(this.frequency, format);
    document.getElementById('freqDisplayInputPerm').value = this.freqInputValuePerm;
    this.clearFreqErrorPerm();
}

handleFreqKeyInputPerm(key) {
    const freqInput = document.getElementById('freqDisplayInputPerm');
    
    if (key === 'backspace') {
        this.freqInputValuePerm = this.freqInputValuePerm.slice(0, -1);
    } else {
        if (this.freqInputValuePerm.length >= 15) return;
        
        if (key === '.') {
            if (this.freqInputValuePerm.includes('.')) return;
            if (this.freqInputValuePerm.length === 0) return;
        }
        
        this.freqInputValuePerm += key;
    }
    
    freqInput.value = this.freqInputValuePerm;
    this.validateFreqInputPerm();
    freqInput.focus();
}

handleFreqInputChangePerm(e) {
    let value = e.target.value.replace(/[^0-9.]/g, '');
    
    const parts = value.split('.');
    if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
    }
    
    this.freqInputValuePerm = value;
    e.target.value = value;
    this.validateFreqInputPerm();
}

handleFreqInputKeyboardPerm(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        this.setFrequencyFromInputPerm();
    }
}

clearFreqInputPerm() {
    this.freqInputValuePerm = '';
    document.getElementById('freqDisplayInputPerm').value = '';
    this.clearFreqErrorPerm();
    document.getElementById('freqDisplayInputPerm').focus();
}

validateFreqInputPerm() {
    const errorEl = document.getElementById('freqErrorPerm');
    errorEl.textContent = '';
    
    if (!this.freqInputValuePerm) return true;
    
    const freq = this.parseFrequencyInput(this.freqInputValuePerm, this.freqInputModePerm);
    
    if (freq === null) {
        errorEl.textContent = 'Invalid format';
        return false;
    }
    
    if (freq < 100000 || freq > 999999999) {
        errorEl.textContent = 'Out of range';
        return false;
    }
    
    return true;
}

clearFreqErrorPerm() {
    document.getElementById('freqErrorPerm').textContent = '';
}

setFrequencyFromInputPerm() {
    if (!this.validateFreqInputPerm()) return;
    
    const freq = this.parseFrequencyInput(this.freqInputValuePerm, this.freqInputModePerm);
    if (freq === null) return;
    
    // Set the new frequency (reuse existing logic)
    this.frequency = freq;
    this.updateDisplay();
    this.updateBandFromFrequency();
    this.updateBandButtons();
    this.saveLastFrequency();
    
    if (this.connected) {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
            setTimeout(() => {
                this.sendCommand(this.getVFOCommand());
            }, 100);
        }).catch(e => {
            this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
        });
    }
    
    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
    
    const displayStr = this.frequency.toString().padStart(9, '0');
    const mhz = displayStr.substring(0, 3);
    const khz = displayStr.substring(3, 6);
    const hz = displayStr.substring(6, 9);
    this.logCAT(`Direct frequency entry: ${mhz}.${khz}.${hz} Hz`, 'info');
    
    // Update the permanent input to show the set frequency
    this.freqInputValuePerm = this.formatFrequencyForInput(this.frequency, this.freqInputModePerm);
    document.getElementById('freqDisplayInputPerm').value = this.freqInputValuePerm;
}    
              
   // Add these methods to the QMXInterface class

initRITControl() {
    try {
        console.log('Initializing RIT control...');
        
        // Check if RIT elements exist
        const ritToggleBtn = document.getElementById('ritToggleBtn');
        const ritClearBtn = document.getElementById('ritClearBtn');
        const ritKnob = document.getElementById('ritKnob');
        
        if (!ritToggleBtn) {
            console.error('RIT Toggle button not found! Make sure HTML is added.');
            return;
        }
        
        console.log('RIT elements found, setting up event listeners...');
        
        // Initialize RIT state
        this.ritEnabled = false;
        this.ritOffset = 0;
        this.updateRITUI();
        
        // RIT Toggle button - WITH DEBUGGING
        ritToggleBtn.addEventListener('click', (e) => {
            console.log('RIT Toggle button clicked!');
            this.toggleRIT();
        });
        
        // RIT Clear button
        if (ritClearBtn) {
            ritClearBtn.addEventListener('click', (e) => {
                console.log('RIT Clear button clicked!');
                this.clearRIT();
            });
        }
        
        // RIT adjustment buttons
        document.querySelectorAll('.rit-adjust').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const offset = parseInt(btn.dataset.offset);
                console.log(`RIT adjust button clicked: ${offset} Hz`);
                this.adjustRIT(offset);
            });
        });
        
        // RIT Fine control knob
        if (ritKnob) {
            ritKnob.addEventListener('mousedown', this.startRITAdjust.bind(this));
            ritKnob.addEventListener('touchstart', this.startRITAdjust.bind(this), { passive: false });
            ritKnob.addEventListener('wheel', this.handleRITWheel.bind(this));
            ritKnob.addEventListener('keydown', this.handleRITKeyboard.bind(this));
        }
        
        console.log('RIT control initialized successfully');
        this.logCAT('RIT control system ready', 'info');
        
    } catch (error) {
        console.error('Error initializing RIT control:', error);
        this.logCAT(`RIT init error: ${error.message}`, 'error');
    }
}

toggleRIT() {
    try {
        this.ritEnabled = !this.ritEnabled;

        if (this.connected) {
            if (this.ritEnabled) {
                // --- Turning RIT ON ---
                // If the offset is currently zero, set it to a tiny value (+1 Hz).
                // This forces the radio to engage RIT mode.
                if (this.ritOffset === 0) {
                    this.ritOffset = 1;
                }
                // Now, send the command to set the current offset value.
                this.sendRITCommand();
                this.logCAT(`RIT ENABLED (offset: ${this.ritOffset} Hz)`, 'info');
            } else {
                // --- Turning RIT OFF ---
                // The 'RIT Clear' (RC) command is the most reliable way to turn RIT off.
                this.sendCommand('RC');
                this.ritOffset = 0; // Also reset our internal state to match.
                this.logCAT(`RIT DISABLED`, 'info');
            }
        } else {
            // This handles toggling when not connected to the radio.
            if (!this.ritEnabled) {
                this.ritOffset = 0;
            }
            this.logCAT(`RIT toggled (offline)`, 'info');
        }

        // Finally, update the UI to reflect the new state.
        this.updateRITUI();

    } catch (error) {
        this.logCAT(`RIT toggle error: ${error.message}`, 'error');
    }
}
clearRIT() {
    try {
        console.log('Clearing RIT offset');
        
        this.ritOffset = 0;
        this.ritKnobRotation = 0;
        this.updateRITUI();
        
        if (this.connected) {
            this.sendCommand('RC').then(() => {
                this.logCAT('RIT offset cleared', 'info');
                console.log('RIT clear command sent successfully');
            }).catch(e => {
                console.error('RIT clear command failed:', e);
                this.logCAT(`RIT clear error: ${e.message}`, 'error');
            });
        } else {
            this.logCAT('RIT offset cleared (radio not connected)', 'info');
            console.log('RIT cleared locally');
        }
        
    } catch (error) {
        console.error('Error in clearRIT:', error);
        this.logCAT(`RIT clear error: ${error.message}`, 'error');
    }
}

adjustRIT(offsetHz) {
    try {
        console.log(`Adjusting RIT by ${offsetHz} Hz (current: ${this.ritOffset} Hz)`);
        
        if (!this.ritEnabled) {
            this.logCAT('Enable RIT first before adjusting', 'error');
            console.log('RIT adjustment blocked - RIT not enabled');
            return;
        }
        
        const newOffset = this.ritOffset + offsetHz;
        
        // Limit RIT range to ±9999 Hz
        if (newOffset < -9999 || newOffset > 9999) {
            this.logCAT(`RIT offset limited to ±9999 Hz`, 'error');
            console.log(`RIT adjustment blocked - would exceed range: ${newOffset}`);
            return;
        }
        
        this.ritOffset = newOffset;
        console.log(`RIT offset set to: ${this.ritOffset} Hz`);
        
        this.updateRITUI();
        this.sendRITCommand();
        
    } catch (error) {
        console.error('Error in adjustRIT:', error);
        this.logCAT(`RIT adjust error: ${error.message}`, 'error');
    }
}

updateRITUI() {
    try {
        //console.log(`Updating RIT UI - Enabled: ${this.ritEnabled}, Offset: ${this.ritOffset}`);
        
        // Get elements
        const statusDisplay = document.getElementById('ritStatusDisplay');
        const statusText = document.getElementById('ritStatus');
        const offsetValue = document.getElementById('ritOffsetValue');
        const ritPanel = document.getElementById('ritPanel');
        const ritKnob = document.getElementById('ritKnob');
        const toggleBtn = document.getElementById('ritToggleBtn');
        
        // Check if elements exist
        if (!statusDisplay || !statusText || !offsetValue) {
            console.error('RIT UI elements not found! Check HTML structure.');
            return;
        }
        
        // Update status
        if (this.ritEnabled) {
            statusDisplay.classList.add('active');
            statusText.textContent = 'ON';
            statusText.classList.add('active');
            if (ritPanel) ritPanel.classList.add('rit-active');
            if (ritKnob) ritKnob.classList.add('rit-active');
            if (toggleBtn) {
                toggleBtn.classList.remove('btn-secondary');
                toggleBtn.classList.add('btn-primary');
            }
        } else {
            statusDisplay.classList.remove('active');
            statusText.textContent = 'OFF';
            statusText.classList.remove('active');
            if (ritPanel) ritPanel.classList.remove('rit-active');
            if (ritKnob) ritKnob.classList.remove('rit-active');
            if (toggleBtn) {
                toggleBtn.classList.remove('btn-primary');
                toggleBtn.classList.add('btn-secondary');
            }
        }
        
        // Update offset display
        const sign = this.ritOffset >= 0 ? '+' : '';
        offsetValue.textContent = `${sign}${this.ritOffset} Hz`;
        
        // Update offset display color
        offsetValue.classList.remove('positive', 'negative');
        if (this.ritOffset > 0) {
            offsetValue.classList.add('positive');
        } else if (this.ritOffset < 0) {
            offsetValue.classList.add('negative');
        }
        
        // Update knob position
        if (ritKnob) {
            const knobOffset = Math.max(-1000, Math.min(1000, this.ritOffset));
            const normalizedPosition = (knobOffset + 1000) / 2000;
            this.ritKnobRotation = this.minRotation + (normalizedPosition * this.totalRotationRange);
            ritKnob.style.transform = `rotate(${this.ritKnobRotation}deg)`;
            ritKnob.setAttribute('aria-valuenow', this.ritOffset);
        }
        
        // Update knob level display
        const ritKnobLevel = document.getElementById('ritKnobLevel');
        if (ritKnobLevel) {
            ritKnobLevel.textContent = `${sign}${this.ritOffset} Hz`;
        }
        
       // console.log('RIT UI updated successfully');
        
    } catch (error) {
        console.error('Error updating RIT UI:', error);
        this.logCAT(`RIT UI update error: ${error.message}`, 'error');
    }
}

sendRITCommand() {
    if (!this.connected) {
        console.log('RIT command not sent - radio not connected');
        return;
    }
    
    try {
        if (this.ritTimeout) {
            clearTimeout(this.ritTimeout);
        }
        
        this.ritTimeout = setTimeout(() => {
            console.log(`Sending RIT command for offset: ${this.ritOffset} Hz`);
            
            let command;
            if (this.ritOffset === 0) {
                command = 'RC';
            } else if (this.ritOffset > 0) {
                command = `RU${Math.abs(this.ritOffset).toString().padStart(4, '0')}`;
            } else {
                command = `RD${Math.abs(this.ritOffset).toString().padStart(4, '0')}`;
            }
            
            console.log(`Sending command: ${command}`);
            
            this.sendCommand(command).then(() => {
                console.log(`RIT command sent successfully: ${command}`);
                this.logCAT(`RIT offset set: ${this.ritOffset} Hz`, 'info');
            }).catch(e => {
                console.error("RIT command error:", e);
                this.logCAT(`RIT command error: ${e.message}`, 'error');
            });
            
            this.ritTimeout = null;
        }, 100);
        
    } catch (error) {
        console.error('Error in sendRITCommand:', error);
        this.logCAT(`RIT send error: ${error.message}`, 'error');
    }
}  

    

//-----------------------------------------------------
// Add this temporary test function to check if RIT is working
// You can call this from the browser console to test

testRIT() {
    console.log('=== RIT TEST START ===');
    console.log('Current RIT state:', {
        enabled: this.ritEnabled,
        offset: this.ritOffset
    });
    
    // Test the toggle function directly
    console.log('Testing toggle function...');
    this.toggleRIT();
    
    console.log('RIT state after toggle:', {
        enabled: this.ritEnabled,
        offset: this.ritOffset
    });
    
    // Test adjustment
    console.log('Testing 50Hz adjustment...');
    this.adjustRIT(50);
    
    console.log('Final RIT state:', {
        enabled: this.ritEnabled,
        offset: this.ritOffset
    });
    console.log('=== RIT TEST END ===');
}

// Also add this method to help debug
checkRITElements() {
    const elements = {
        ritPanel: document.getElementById('ritPanel'),
        ritToggleBtn: document.getElementById('ritToggleBtn'),
        ritStatus: document.getElementById('ritStatus'),
        ritOffsetValue: document.getElementById('ritOffsetValue'),
        ritKnob: document.getElementById('ritKnob')
    };
    
    console.log('RIT Elements Check:', elements);
    
    Object.keys(elements).forEach(key => {
        if (!elements[key]) {
            console.error(`❌ Missing element: ${key}`);
        } else {
            console.log(`✅ Found element: ${key}`);
        }
    });
    
    return elements;
}

//--------------------------

async initAudioStreaming() {
    try {
        console.log('Initializing audio streaming...');
        this.setupAudioEventListeners();
        
        // Automatically enumerate devices on startup
        await this.enumerateAudioDevices();
        
        this.logCAT('Audio streaming ready', 'info');
        
        // Set default gain boost
        this.audioGain = 2.0;
        const gainSlider = document.getElementById('audioGainSlider');
        if (gainSlider) {
            gainSlider.value = this.audioGain * 100;
        }
        this.updateGainDisplay();
        
    } catch (error) {
        console.error('Audio init error:', error);
        this.logCAT(`Audio init error: ${error.message}`, 'error');
        
        // If automatic enumeration fails, set up a fallback
        this.setupDeviceEnumerationFallback();
    }
}
setupDeviceEnumerationFallback() {
    // Show a helpful message in the dropdowns
    const inputSelect = document.getElementById('audioInputDevice');
    const outputSelect = document.getElementById('audioOutputDevice');
    
    if (inputSelect && outputSelect) {
        inputSelect.innerHTML = '<option value="">Click "Refresh" to load devices</option>';
        outputSelect.innerHTML = '<option value="">Click "Refresh" to load devices</option>';
    }
    
    this.logCAT('Click "Refresh" to load audio devices', 'info');
}

setupAudioEventListeners() {
    const inputSelect = document.getElementById('audioInputDevice');
    const outputSelect = document.getElementById('audioOutputDevice');
    
    if (!inputSelect || !outputSelect) {
        console.error('Audio select elements not found!');
        return;
    }
    
    // Input device selection with debugging
    inputSelect.addEventListener('change', (e) => {
        this.selectedInputDevice = e.target.value;
        const selectedName = e.target.options[e.target.selectedIndex].text;
        console.log('Input device changed to:', this.selectedInputDevice, '-', selectedName);
        this.logCAT(`Input selected: ${selectedName}`, 'info');
        
        if (this.isAudioStreaming) {
            this.stopAudioStream();
        }
    });
    
    // Output device selection with debugging
    outputSelect.addEventListener('change', (e) => {
        this.selectedOutputDevice = e.target.value;
        const selectedName = e.target.options[e.target.selectedIndex].text;
        console.log('Output device changed to:', this.selectedOutputDevice, '-', selectedName);
        this.logCAT(`Output selected: ${selectedName}`, 'info');
        
        if (this.isAudioStreaming && this.audioContext && this.audioContext.setSinkId) {
            this.audioContext.setSinkId(this.selectedOutputDevice).catch(console.error);
        }
    });
    
    // Button listeners
    document.getElementById('startStreamBtn').addEventListener('click', () => {
        console.log('START BUTTON CLICKED - selectedInputDevice:', this.selectedInputDevice);
        this.startAudioStream();
    });
    // Add this to your setupAudioEventListeners() method
document.getElementById('refreshDevicesBtn').addEventListener('click', async () => {
    this.logCAT('Refreshing audio devices...', 'info');
    console.log('Manual device refresh requested');
    await this.enumerateAudioDevices();
	});
	
	const gainSlider = document.getElementById('audioGainSlider');
if (gainSlider) {
    gainSlider.addEventListener('input', (e) => {
        const gainValue = parseInt(e.target.value) / 100; // Convert to multiplier
        this.audioGain = gainValue;
        this.updateAudioGain();
        this.updateGainDisplay();
    });
}


	
    document.getElementById('stopStreamBtn').addEventListener('click', () => this.stopAudioStream());
    document.getElementById('muteInputBtn').addEventListener('click', () => this.toggleInputMute());
    document.getElementById('muteOutputBtn').addEventListener('click', () => this.toggleOutputMute());
}

async enumerateAudioDevices() {
    try {
        console.log('=== STARTING DEVICE ENUMERATION ===');
        
        // Request permission with more explicit constraints
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false
            }
        });
        
        // Stop the temporary stream
        stream.getTracks().forEach(track => track.stop());
        console.log('Microphone permission granted and test stream closed');
        
        // Small delay to ensure devices are properly enumerated
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        console.log('All devices found:', devices.length);
        
        const inputSelect = document.getElementById('audioInputDevice');
        const outputSelect = document.getElementById('audioOutputDevice');
        
        if (!inputSelect || !outputSelect) {
            console.error('Audio select elements not found!');
            return;
        }
        
        // Clear existing options
        inputSelect.innerHTML = '<option value="">Select Input Device...</option>';
        outputSelect.innerHTML = '<option value="">Select Output Device...</option>';
        
        // Reset arrays
        this.audioDevices = { input: [], output: [] };
        
        devices.forEach((device, index) => {
            const deviceName = device.label || `Device ${index + 1}`;
            const deviceId = device.deviceId || `device-${index}-${device.kind}`;
            
            console.log(`Device ${index}: ${device.kind} - ${deviceName}`);
            console.log(`  ID: "${deviceId}"`);
            console.log(`  GroupID: "${device.groupId}"`);
            
            if (device.kind === 'audioinput') {
                const option = document.createElement('option');
                option.value = deviceId;
                option.textContent = deviceName;
                inputSelect.appendChild(option);
                this.audioDevices.input.push({
                    ...device,
                    deviceId: deviceId // Ensure we have a valid ID
                });
            }
            
            else if (device.kind === 'audiooutput') {
                const option = document.createElement('option');
                option.value = deviceId;
                option.textContent = deviceName;
                outputSelect.appendChild(option);
                this.audioDevices.output.push({
                    ...device,
                    deviceId: deviceId // Ensure we have a valid ID
                });
            }
        });
        
        // Enhanced selection logic with validation
        if (this.audioDevices.input.length > 0) {
            const firstInput = this.audioDevices.input[0];
            this.selectedInputDevice = firstInput.deviceId;
            inputSelect.selectedIndex = 1; // Select first real option
            
            console.log('✅ SELECTED INPUT DEVICE:', firstInput.label || 'Device 1');
            console.log('✅ INPUT DEVICE ID:', this.selectedInputDevice);
            this.logCAT(`Selected input: ${firstInput.label || 'Device 1'}`, 'info');
        } else {
            console.log('❌ NO INPUT DEVICES FOUND');
            this.selectedInputDevice = null;
        }
        
        if (this.audioDevices.output.length > 0) {
            const firstOutput = this.audioDevices.output[0];
            this.selectedOutputDevice = firstOutput.deviceId;
            outputSelect.selectedIndex = 1; // Select first real option
            
            console.log('✅ SELECTED OUTPUT DEVICE:', firstOutput.label || 'Device 2');
            console.log('✅ OUTPUT DEVICE ID:', this.selectedOutputDevice);
            this.logCAT(`Selected output: ${firstOutput.label || 'Device 2'}`, 'info');
        } else {
            console.log('❌ NO OUTPUT DEVICES FOUND');
            this.selectedOutputDevice = null;
        }
        
        console.log('=== DEVICE ENUMERATION COMPLETE ===');
        console.log('🎯 FINAL Selected Input Device ID:', this.selectedInputDevice);
        console.log('🎯 FINAL Selected Output Device ID:', this.selectedOutputDevice);
        
        // Validate that we have valid selections
        if (!this.selectedInputDevice) {
            console.warn('⚠️ No valid input device selected - using default');
            this.selectedInputDevice = 'default';
        }
        if (!this.selectedOutputDevice) {
            console.warn('⚠️ No valid output device selected - using default');
            this.selectedOutputDevice = 'default';
        }
        
        this.logCAT(`Ready: ${this.audioDevices.input.length} input, ${this.audioDevices.output.length} output devices`, 'info');
        
    } catch (error) {
        console.error('Device enumeration error:', error);
        this.logCAT(`Device enumeration error: ${error.message}`, 'error');
        
        // Fallback to default devices
        this.selectedInputDevice = 'default';
        this.selectedOutputDevice = 'default';
        console.log('Using fallback default devices');
    }
}
async startAudioStream() {
    try {
        console.log('🎯 START BUTTON CLICKED');
        console.log('📍 selectedInputDevice:', this.selectedInputDevice);
        
        if (!this.selectedInputDevice) {
            console.log('❌ No input device - setting to default');
            this.selectedInputDevice = 'default';
        }
        
        this.logCAT('Starting audio stream...', 'info');
        
        // Create audio context
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 48000
        });
        
        console.log('Audio context created, state:', this.audioContext.state);
        
        if (this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
            console.log('Audio context resumed');
        }
        
        // Prepare audio constraints
        let audioConstraints = {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
        };
        
        // Only specify deviceId if it's not 'default' and not empty
        if (this.selectedInputDevice && this.selectedInputDevice !== 'default' && this.selectedInputDevice.trim() !== '') {
            audioConstraints.deviceId = { exact: this.selectedInputDevice };
            console.log('Using specific device ID:', this.selectedInputDevice);
        } else {
            console.log('Using default device (no specific ID)');
        }
        
        console.log('Requesting microphone with constraints:', audioConstraints);
        
        // Get microphone access
        this.inputStream = await navigator.mediaDevices.getUserMedia({
            audio: audioConstraints
        });
        
        console.log('✅ Got input stream:', this.inputStream);
        console.log('Stream tracks:', this.inputStream.getTracks());
        
        // Create audio nodes
        this.inputSource = this.audioContext.createMediaStreamSource(this.inputStream);
      
        
		
		// In your startAudioStream() method, after creating gainNode:
this.gainNode = this.audioContext.createGain();
this.gainNode.gain.value = this.audioGain; // Use current gain setting instead of 1.0

// Initialize gain display
this.updateGainDisplay();
        
        this.inputAnalyser = this.audioContext.createAnalyser();
        this.inputAnalyser.fftSize = 256;
        
        // Connect audio graph: Input → Gain → Analyser → Speakers
        this.inputSource.connect(this.gainNode);
        this.gainNode.connect(this.inputAnalyser);
        this.gainNode.connect(this.audioContext.destination);
         this.startSpectrum(); // Add this line
        console.log('✅ Audio nodes connected');
        
        // Set output device if available and not default
        if (this.selectedOutputDevice && 
            this.selectedOutputDevice !== 'default' && 
            this.selectedOutputDevice.trim() !== '' && 
            this.audioContext.setSinkId) {
            
            try {
                await this.audioContext.setSinkId(this.selectedOutputDevice);
                console.log('✅ Output device set:', this.selectedOutputDevice);
            } catch (outputError) {
                console.warn('⚠️ Could not set output device:', outputError.message);
            }
        }
        
        // Start monitoring
        this.startLevelMonitoring();
        
        // Update state
        this.isAudioStreaming = true;
        this.updateStreamingButtons();
        
        document.getElementById('audioStatusText').textContent = 'Streaming active';
        document.getElementById('audioStatusDot').classList.add('active');
        
        console.log('🎉 Audio streaming started successfully!');
        this.logCAT('✅ Audio streaming: QMX → PC Speakers', 'info');
        
    } catch (error) {
        console.error('❌ Stream start error:', error);
        this.logCAT(`Stream start error: ${error.message}`, 'error');
        
        // More specific error messages
        if (error.name === 'NotAllowedError') {
            alert('Microphone permission denied. Please allow microphone access and try again.');
        } else if (error.name === 'NotFoundError') {
            alert('No microphone found. Please connect a microphone and refresh the page.');
        } else if (error.name === 'OverconstrainedError') {
            alert('The selected audio device is not available. Trying with default device...');
            // Retry with default device
            this.selectedInputDevice = 'default';
            setTimeout(() => this.startAudioStream(), 1000);
            return;
        } else {
            alert(`Audio start failed: ${error.message}`);
        }
        
        // Reset state on error
        this.isAudioStreaming = false;
        this.updateStreamingButtons();
    }
}


startLevelMonitoring() {
    if (!this.inputAnalyser) return;
    
    const bufferLength = this.inputAnalyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    const updateLevel = () => {
        if (!this.isAudioStreaming) return;
        
        this.inputAnalyser.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i] * dataArray[i];
        }
        const rms = Math.sqrt(sum / bufferLength);
        const level = (rms / 255) * 100;
        
        const meter = document.getElementById('inputLevelMeter');
        const text = document.getElementById('inputLevelText');
        
        if (meter && text) {
            meter.style.width = `${level}%`;
            const db = level > 0 ? (20 * Math.log10(level / 100)) : -Infinity;
            text.textContent = isFinite(db) ? `${db.toFixed(1)} dB` : '-∞ dB';
        }
        
        requestAnimationFrame(updateLevel);
    };
    
    updateLevel();
}



async stopAudioStream() {
    try {
        if (this.inputStream) {
            this.inputStream.getTracks().forEach(track => track.stop());
            this.inputStream = null;
        }
        
        this.isAudioStreaming = false;
        this.updateStreamingButtons();
        
        document.getElementById('audioStatusText').textContent = 'Ready to stream';
        document.getElementById('audioStatusDot').classList.remove('active');
        
        this.logCAT('Audio streaming stopped', 'info');
    } catch (error) {
        this.logCAT(`Stop error: ${error.message}`, 'error');
    }
}

updateStreamingButtons() {
    const startBtn = document.getElementById('startStreamBtn');
    const stopBtn = document.getElementById('stopStreamBtn');
    
    if (this.isAudioStreaming) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        stopBtn.classList.add('btn-danger');
    } else {
        startBtn.disabled = false;
        stopBtn.disabled = true;
        stopBtn.classList.remove('btn-danger');
    }
}






toggleInputMute() {
    // Implementation for input mute
    this.logCAT('Input mute toggled', 'info');
}

toggleOutputMute() {
    // Implementation for output mute
    this.logCAT('Output mute toggled', 'info');
}



// Update audio gain in real-time
updateAudioGain() {
    if (this.gainNode) {
        this.gainNode.gain.value = this.audioGain;
        console.log('Audio gain set to:', this.audioGain, '(' + (20 * Math.log10(this.audioGain)).toFixed(1) + ' dB)');
    }
}

// Update gain display
updateGainDisplay() {
    const gainLevelElement = document.getElementById('audioGainLevel');
    if (gainLevelElement) {
        const gainMultiplier = this.audioGain.toFixed(1);
        const gainDB = this.audioGain > 0 ? (20 * Math.log10(this.audioGain)).toFixed(1) : '-∞';
        gainLevelElement.textContent = `${gainMultiplier}x (${gainDB} dB)`;
        
        // Color coding based on gain level
        if (this.audioGain >= 3.0) {
            gainLevelElement.style.color = '#ff4757'; // High gain - red
        } else if (this.audioGain >= 2.0) {
            gainLevelElement.style.color = '#ff9500'; // Medium-high gain - orange  
        } else if (this.audioGain >= 1.5) {
            gainLevelElement.style.color = '#ffff00'; // Medium gain - yellow
        } else {
            gainLevelElement.style.color = '#00ff88'; // Normal gain - green
        }
    }
}
	

         // Add this method to test SWR during transmission
async testSWRDuringTX() {
    if (!this.connected) {
        this.logCAT('Connect radio first', 'error');
        return;
    }
    
    this.logCAT('Testing SWR during transmission...', 'info');
    
    try {
        // Switch to TX mode
        await this.sendCommand('TX');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Request SWR reading
        await this.sendCommand('SW');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Switch back to RX mode
        await this.sendCommand('RX');
        
        this.logCAT('SWR test completed', 'info');
    } catch (error) {
        this.logCAT(`SWR test error: ${error.message}`, 'error');
    }
} 
 

async setFrequencyAndRestoreGain(freqHz) {
                if (!this.connected || !this.writer) return;
 this.lastManualFreqSet = Date.now(); // Record when we sent the command
                try {
                    // 1. Send the command to change the frequency
                    const freqStr = freqHz.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    await this.sendCommand(`${vfoCommand}${freqStr}`);

                    // 2. Immediately send a command to set the AF gain back to the UI's level
                    // A tiny delay ensures the radio processes the frequency change first.
                    setTimeout(() => {
                        if (this.connected) {
                            const scaledVolume = this.volumeToCAT(this.volumeLevel);
                            const gainCommand = `AG${scaledVolume.toString().padStart(3, '0')}`;
                            this.sendCommand(gainCommand);
                        }
                    }, 50); // 50ms delay
                } catch (e) {
                    this.logCAT(`Frequency/Gain Restore Error: ${e.message}`, 'error');
                }
            } 

initSpectrumDisplay() {
    this.spectrumCanvas = document.getElementById('spectrumCanvas');
    this.spectrumCtx = this.spectrumCanvas.getContext('2d');

    this.resizeSpectrumCanvas = () => {
        if (this.spectrumCanvas.width !== this.spectrumCanvas.clientWidth ||
            this.spectrumCanvas.height !== this.spectrumCanvas.clientHeight) {
            this.spectrumCanvas.width = this.spectrumCanvas.clientWidth;
            this.spectrumCanvas.height = this.spectrumCanvas.clientHeight;
        }
    };

    const targetPitchSelect = document.getElementById('targetPitch');
    targetPitchSelect.addEventListener('change', (e) => {
        this.targetPitch = parseInt(e.target.value, 10);
        this.logCAT(`Target CW pitch set to ${this.targetPitch} Hz`, 'info');
    });

    // --- MOVED EVENT LISTENERS START HERE ---
    const thresholdSlider = document.getElementById('signalThreshold');
    const thresholdValue = document.getElementById('thresholdValue');
    const noiseFloorCheck = document.getElementById('showNoiseFloor');
    const noiseMethodSelect = document.getElementById('noiseMethod');
    
    if (thresholdSlider) {
        thresholdSlider.addEventListener('input', (e) => {
            this.signalThreshold = parseInt(e.target.value);
            if (thresholdValue) thresholdValue.textContent = this.signalThreshold;
        });
    }
    
    if (noiseFloorCheck) {
        noiseFloorCheck.addEventListener('change', (e) => {
            this.showNoiseFloor = e.target.checked;
        });
    }
    
    if (noiseMethodSelect) {
        noiseMethodSelect.addEventListener('change', (e) => {
            this.noiseFloorMethod = e.target.value;
            this.adaptiveNoiseHistory = []; // Reset adaptive history
        });
    }
    // --- MOVED EVENT LISTENERS END HERE ---

    this.spectrumCanvas.addEventListener('click', (e) => {
        if (!this.spectrumEnabled || !this.connected) return;

        const rect = this.spectrumCanvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;

        const searchRadiusPx = 15;
        const displayBandwidth = this.spectrumBandwidth;
        const audioSampleRate = this.audioContext.sampleRate || 48000;
        const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (displayBandwidth / (audioSampleRate / 2)));
        
        const startBin = Math.floor(((clickX - searchRadiusPx) / this.spectrumCanvas.width) * relevantBins);
        const endBin = Math.floor(((clickX + searchRadiusPx) / this.spectrumCanvas.width) * relevantBins);

        let peakSignal = -1;
        let peakBin = -1;

        for (let i = Math.max(0, startBin); i < Math.min(relevantBins, endBin); i++) {
            if (this.frequencyData[i] > peakSignal) {
                peakSignal = this.frequencyData[i];
                peakBin = i;
            }
        }
        
        if (peakBin === -1) {
            this.logCAT('No signal peak found near click.', 'error');
            return;
        }

        const peakFreq = (peakBin / relevantBins) * displayBandwidth;
        const targetFreq = this.mode === 'CW' ? this.targetPitch : 1500;
        const offset = peakFreq - targetFreq;

        this.logCAT(`Peak found at ${peakFreq.toFixed(0)} Hz. Tuning by ${offset.toFixed(0)} Hz`, 'info');

        const currentFreq = Number(this.frequency);
        const newFrequency = currentFreq + offset;
        this.frequency = Math.round(newFrequency);
        this.updateDisplay();
        this.setFrequencyAndRestoreGain(this.frequency);
		
		// Add this to initSpectrumDisplay():
const calibrateBtn = document.getElementById('calibrateNoiseBtn');
if (calibrateBtn) {
    calibrateBtn.addEventListener('click', () => {
        this.calibrateNoiseFloor();
    });
}
		
		
		
		
		
		
		
		
		
		
    });
} // <<< ADD THIS MISSING BRACE
  


         startSpectrum() {
    if (!this.audioContext || !this.inputAnalyser) return;

    // This correctly resizes the canvas right before drawing starts.
    this.resizeSpectrumCanvas(); 

    this.spectrumEnabled = true;

    // These lines were missing: they set up the analyzer's resolution 
    // and create the data array needed for drawing.
    this.inputAnalyser.fftSize = 2048; 
    this.frequencyData = new Uint8Array(this.inputAnalyser.frequencyBinCount);

    // This crucial call starts the drawing loop.
    this.drawSpectrum();

    this.logCAT('Spectrum analyzer started', 'info');
}



           drawSpectrum() {
    if (!this.spectrumEnabled) {
        cancelAnimationFrame(this.spectrumAnimationFrame);
        return;
    }

    this.spectrumAnimationFrame = requestAnimationFrame(() => this.drawSpectrum());

    this.inputAnalyser.getByteFrequencyData(this.frequencyData);

    this.spectrumCtx.fillStyle = '#10151a'; // Background color
    this.spectrumCtx.fillRect(0, 0, this.spectrumCanvas.width, this.spectrumCanvas.height);

    const barWidth = (this.spectrumCanvas.width / this.inputAnalyser.frequencyBinCount) * 2.5;
    const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (this.spectrumBandwidth / (this.audioContext.sampleRate / 2)));
    
    // CALCULATE NOISE FLOOR - this is the key addition
    const noiseThreshold = this.calculateNoiseFloor(this.frequencyData, relevantBins);
   // In drawSpectrum, modify the signal detection:

    let x = 0;
    for (let i = 0; i < relevantBins; i++) {
        const barHeight = this.frequencyData[i] / 2;
        const signalLevel = this.frequencyData[i];
        
        // DETERMINE IF THIS IS SIGNAL OR NOISE
       const isSignal = signalLevel > noiseThreshold && signalLevel > 50;
        
        if (isSignal) {
            // SIGNAL - Use bright orange/red gradient
            const intensity = Math.min(255, (signalLevel - noiseThreshold) * 3);
            const red = Math.min(255, 200 + intensity * 0.2);
            const green = Math.min(255, 100 + intensity * 0.6);
            this.spectrumCtx.fillStyle = `rgb(${red}, ${green}, 0)`;
        } else {
            // NOISE - Use dim green
            const green = Math.min(255, 80 + barHeight * 1.5);
            this.spectrumCtx.fillStyle = `rgb(0, ${green}, 40)`;
        }
        
        this.spectrumCtx.fillRect(x, this.spectrumCanvas.height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
    
    
    // OPTIONAL: Draw noise floor line
    if (this.showNoiseFloor) {
        const noiseLineY = this.spectrumCanvas.height - (noiseThreshold / 2);
        this.spectrumCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
        this.spectrumCtx.lineWidth = 1;
        this.spectrumCtx.beginPath();
        this.spectrumCtx.moveTo(0, noiseLineY);
        this.spectrumCtx.lineTo(this.spectrumCanvas.width, noiseLineY);
        this.spectrumCtx.stroke();
    }
}
}
//...
            
		   
		   
		 initAutotune() {
                const autotuneBtn = document.getElementById('autotuneBtn');
                const manualScanBtn = document.getElementById('manualScanBtn'); // Get the new button

                autotuneBtn.addEventListener('click', () => {
                    this.autotuneEnabled = !this.autotuneEnabled;
                    if (this.autotuneEnabled) {
                        autotuneBtn.classList.add('autotune-active');
                        autotuneBtn.textContent = 'AUTOTUNE ON';
                        this.logCAT('Autotune ENABLED.', 'info');
                    } else {
                        autotuneBtn.classList.remove('autotune-active');
                        autotuneBtn.textContent = 'AUTOTUNE OFF';
                        this.logCAT('Autotune DISABLED.', 'info');
                    }
                });

             // Add this event listener for the new button
manualScanBtn.addEventListener('click', async (event) => { // Add 'event' to the function
    const button = event.currentTarget; // Get the button that was clicked

    // --- Add the flash effect ---
    button.classList.add('btn-flash');
    setTimeout(() => {
        button.classList.remove('btn-flash');
    }, 300); // The flash will last for 300 milliseconds
    // --- End of flash effect code ---

    // Check if the audio stream is already active
    if (this.isAudioStreaming) {
        // If it is, just perform the scan immediately
        this.performAutotuneScan();
    } else {
        // If not, try to start the stream first
        this.logCAT('Audio stream not active. Starting it for manual scan...', 'info');
        await this.startAudioStream(); // Await the stream start

        // After attempting to start, check if it was successful before scanning
        if (this.isAudioStreaming) {
            // A brief delay ensures the spectrum analyzer has data before the scan runs
            setTimeout(() => {
                this.performAutotuneScan();
            }, 250); // 250ms delay
        } else {
            this.logCAT('Failed to start audio stream. Cannot perform scan.', 'error');
        }
    }
});
            }

            triggerAutotuneScan() {
                // If the feature is disabled or the audio stream isn't running, do nothing.
                if (!this.autotuneEnabled || !this.spectrumEnabled) return;

                // Reset the timer every time the user moves the knob.
                if (this.autotuneScanTimeout) {
                    clearTimeout(this.autotuneScanTimeout);
                }

                // After the user stops tuning for autotuneDebounceTime, start the scan.
                this.autotuneScanTimeout = setTimeout(() => {
                    this.performAutotuneScan();
                }, this.autotuneDebounceTime);
            }

  performAutotuneScan() {
               if (!this.autotuneEnabled && !this.spectrumEnabled && !this.connected) return;

               const isSSB = (this.mode === 'USB' || this.mode === 'LSB');
               const isCW = (this.mode === 'CW');

               if (!isSSB && !isCW) {
                   this.logCAT('Autotune: Only available for CW and SSB modes.', 'info');
                   return;
               }

               this.logCAT(`Autotune: Scanning for ${this.mode} signal...`, 'info');

               const scanDuration = 1000;
               const sampleInterval = 50;
               const samplesToTake = scanDuration / sampleInterval;
               
               let samplesTaken = 0;
               const averageSpectrum = new Float32Array(this.inputAnalyser.frequencyBinCount).fill(0);

               const scanner = setInterval(() => {
                   if (!this.autotuneEnabled && samplesTaken > 0) {
                       clearInterval(scanner);
                       return;
                   }

                   this.inputAnalyser.getByteFrequencyData(this.frequencyData);
                   for (let i = 0; i < this.frequencyData.length; i++) {
                       averageSpectrum[i] += this.frequencyData[i];
                   }
                   
                   samplesTaken++;

                   if (samplesTaken >= samplesToTake) {
                       clearInterval(scanner);

                       for (let i = 0; i < averageSpectrum.length; i++) {
                           averageSpectrum[i] /= samplesToTake;
                       }

                       const audioSampleRate = this.audioContext.sampleRate || 48000;
                       const analysisBandwidth = 3500;
                       const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (analysisBandwidth / (audioSampleRate / 2)));
                       let peakFreq = 0;

                       if (isCW) {
                           const cwSignalToNoiseRatio = 15;
                           let noiseSum = 0;
                           for (let i = 0; i < relevantBins; i++) noiseSum += averageSpectrum[i];
                           const dynamicThreshold = (noiseSum / relevantBins) + cwSignalToNoiseRatio;
                           
                           let peakBin = -1, peakSignal = 0;
                           for (let i = 0; i < relevantBins; i++) {
                               if (averageSpectrum[i] > peakSignal) {
                                   peakSignal = averageSpectrum[i];
                                   peakBin = i;
                               }
                           }
                           if (peakBin !== -1 && peakSignal > dynamicThreshold) {
                               peakFreq = (peakBin / relevantBins) * analysisBandwidth;
                           }
                       } else if (isSSB) {
                           let totalPower = 0;
                           for (let i = 0; i < relevantBins; i++) totalPower += averageSpectrum[i];
                           const averagePower = totalPower / relevantBins;
                           const signalThreshold = (averagePower * 1.5) + 5;

                           let lowEdgeBin = -1, highEdgeBin = -1;
                           for (let i = 0; i < relevantBins; i++) {
                               if (averageSpectrum[i] > signalThreshold) {
                                   if (lowEdgeBin === -1) lowEdgeBin = i;
                                   highEdgeBin = i;
                               }
                           }

                           if (lowEdgeBin !== -1 && (highEdgeBin - lowEdgeBin) > 10) {
                               const lowEdgeFreq = (lowEdgeBin / relevantBins) * analysisBandwidth;
                               const highEdgeFreq = (highEdgeBin / relevantBins) * analysisBandwidth;
                               peakFreq = (lowEdgeFreq + highEdgeFreq) / 2;
                           }
                       }
                       
                       if (peakFreq > 0) {
                           const targetCenterFreq = isCW ? this.targetPitch : 1500;
                           const floatingOffset = peakFreq - targetCenterFreq;
                           const offset = Math.round(floatingOffset);

                           if (Math.abs(offset) > 25) {
                               this.logCAT(`Autotune (${this.mode}): Found signal at ${peakFreq.toFixed(0)} Hz. Tuning by ${offset} Hz.`, 'info');
                               const currentFreq = Number(this.frequency);
                               
                               let newFrequency;
                               if (this.mode === 'LSB') {
                                   newFrequency = currentFreq - offset;
                               } else { 
                                   newFrequency = currentFreq + offset;
                               }
                               
                               this.frequency = newFrequency;
                               this.updateDisplay();
                               this.setFrequencyAndRestoreGain(this.frequency);
                           } else {
                               this.logCAT(`Autotune (${this.mode}): Signal already tuned.`, 'info');
                           }
                       } else {
                           this.logCAT(`Autotune (${this.mode}): No stable signal found.`, 'info');
                       }
                   } // This brace closes the "if (samplesTaken >= samplesToTake)" block
               }, sampleInterval);
           } // This brace closes the "performAutotuneScan" function
        
		
		
		// 1. PARTICLE EFFECTS FOR FREQUENCY CHANGES
createFrequencyParticles() {
    const lcdPanel = document.getElementById('lcdPanel');
    const rect = lcdPanel.getBoundingClientRect();
    
    for (let i = 0; i < 5; i++) {
        const particle = document.createElement('div');
        particle.className = 'frequency-particle';
        particle.style.left = (rect.left + Math.random() * rect.width) + 'px';
        particle.style.top = (rect.top + rect.height/2) + 'px';
        document.body.appendChild(particle);
        
        setTimeout(() => particle.remove(), 1000);
    }
}

// 2. SOUND EFFECTS (Optional - can be muted)
initSoundEffects() {
    this.soundEnabled = true;
    this.sounds = {
        click: this.createBeep(800, 50),
        tune: this.createBeep(1200, 30),
        connect: this.createBeep(600, 100),
        error: this.createBeep(300, 200)
    };
}

createBeep(frequency, duration) {
    return () => {
        if (!this.soundEnabled) return;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration/1000);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration/1000);
    };
}

// 3. DYNAMIC KNOB GLOW BASED ON VALUES
updateKnobGlow() {
    // Volume knob - red glow when high
    const volumeKnob = document.getElementById('volumeKnob');
    if (this.volumeLevel > 80) {
        volumeKnob.style.boxShadow += ', 0 0 20px rgba(255, 71, 87, 0.6)';
    }
    
    // Power knob - orange glow when high power
    const powerKnob = document.getElementById('powerKnob');
    if (this.powerLevel > 40) {
        powerKnob.style.boxShadow += ', 0 0 20px rgba(255, 149, 0, 0.6)';
    }
}

// 4. ANIMATED BAND CHANGE INDICATOR
showBandChangeAnimation(bandName) {
    const indicator = document.createElement('div');
    indicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 255, 136, 0.9);
        color: black;
        padding: 20px 40px;
        border-radius: 15px;
        font-size: 2em;
        font-weight: bold;
        z-index: 10000;
        animation: bandChange 1.5s ease-out forwards;
        pointer-events: none;
    `;
    indicator.textContent = `${bandName}m BAND`;
    
    // Add keyframes if not already added
    if (!document.getElementById('bandChangeAnimation')) {
        const style = document.createElement('style');
        style.id = 'bandChangeAnimation';
        style.textContent = `
            @keyframes bandChange {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(indicator);
    setTimeout(() => indicator.remove(), 1500);
}

// 5. MORSE CODE BLINK FOR CW MODE
startMorseCodeBlink() {
    if (this.mode !== 'CW') return;
    
    const statusDot = document.getElementById('statusDot');
    const originalClass = statusDot.className;
    
    // Simple morse pattern for "CW" (-.-, .-- )
    const pattern = [200, 100, 600, 100, 200, 500, 200, 100, 600, 100, 600];
    let index = 0;
    
    const blink = () => {
        if (this.mode !== 'CW' || index >= pattern.length) {
            statusDot.className = originalClass;
            return;
        }
        
        const isOn = index % 2 === 0;
        statusDot.style.opacity = isOn ? '1' : '0.2';
        
        setTimeout(() => {
            index++;
            blink();
        }, pattern[index]);
    };
    
    blink();
}

// 6. RIPPLE EFFECT ON BUTTON CLICKS
addRippleEffect(button, event) {
    const ripple = document.createElement('span');
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = event.clientX - rect.left - size / 2;
    const y = event.clientY - rect.top - size / 2;
    
    ripple.style.cssText = `
        position: absolute;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.6);
        transform: scale(0);
        animation: ripple 0.6s linear;
        left: ${x}px;
        top: ${y}px;
        width: ${size}px;
        height: ${size}px;
        pointer-events: none;
    `;
    
    if (!document.getElementById('rippleAnimation')) {
        const style = document.createElement('style');
        style.id = 'rippleAnimation';
        style.textContent = `
            @keyframes ripple {
                to {
                    transform: scale(2);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
}

// 7. ENHANCED FREQUENCY DISPLAY WITH DIGIT FLIP ANIMATION
animateFrequencyChange(oldFreq, newFreq) {
    return;
	const lcdRow1 = document.getElementById('lcdRow1');
    if (!lcdRow1) return;
    
    lcdRow1.style.animation = 'none';
    lcdRow1.offsetHeight; // Trigger reflow
    lcdRow1.style.animation = 'digitFlip 0.3s ease-out';
    
    if (!document.getElementById('digitFlipAnimation')) {
        const style = document.createElement('style');
        style.id = 'digitFlipAnimation';
        style.textContent = `
            @keyframes digitFlip {
                0% { transform: rotateX(0deg); }
                50% { transform: rotateX(90deg); opacity: 0.5; }
                100% { transform: rotateX(0deg); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
    }
}
createEffectsSettings() {
    const settingsHTML = `
        <div class="panel" id="effectsPanel" style="order: 999;">
            <h3>Visual Effects</h3>
            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="soundToggle" ${this.soundEnabled ? 'checked' : ''}>
                    Sound Effects
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="particlesToggle" checked>
                    Particle Effects
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="animationsToggle" checked>
                    Animations
                </label>
            
			
			
			</div>
        
		
		</div>
    `;
    
    // Add to right panel
    document.querySelector('.right-panel').insertAdjacentHTML('beforeend', settingsHTML);
    
    document.getElementById('soundToggle').addEventListener('change', (e) => {
        this.soundEnabled = e.target.checked;
    });
	
	}
	
	// Add this method to your QMXInterface class

animateVFOSwap(vfoFreqA, vfoFreqB) {
    const vfoAButton = document.getElementById('vfoA');
    const vfoBButton = document.getElementById('vfoB');
    
    if (!vfoAButton || !vfoBButton) return;
    
    // Get button positions
    const rectA = vfoAButton.getBoundingClientRect();
    const rectB = vfoBButton.getBoundingClientRect();
    
    // Create flying frequency elements
    const flyingFreqA = this.createFlyingFrequency(
        (vfoFreqA / 1000000).toFixed(3) + ' MHz',
        rectA,
        rectB,
        '#00ff88'
    );
    
    const flyingFreqB = this.createFlyingFrequency(
        (vfoFreqB / 1000000).toFixed(3) + ' MHz', 
        rectB,
        rectA,
        '#00ccff'
    );
    
    // Add visual feedback to buttons
    vfoAButton.style.animation = 'vfoSwapPulse 1.2s ease-out';
    vfoBButton.style.animation = 'vfoSwapPulse 1.2s ease-out';
    
    // Clean up after animation
    setTimeout(() => {
        flyingFreqA.remove();
        flyingFreqB.remove();
        vfoAButton.style.animation = '';
        vfoBButton.style.animation = '';
    }, 1200);
}


createFlyingFrequency(freqText, startRect, endRect, color) {
    const flyingElement = document.createElement('div');
    flyingElement.textContent = freqText;
    flyingElement.style.cssText = `
        position: fixed;
        left: ${startRect.left + startRect.width/2}px;
        top: ${startRect.top + startRect.height/2}px;
        transform: translate(-50%, -50%);
        background: ${color};
        color: black;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.9em;
        box-shadow: 0 0 20px ${color};
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        animation: flyFrequency 1.2s ease-in-out forwards;
    `;
    
    // Calculate end position
    const endX = endRect.left + endRect.width/2;
    const endY = endRect.top + endRect.height/2;
    
    // Set CSS custom properties for the end position
    flyingElement.style.setProperty('--end-x', endX + 'px');
    flyingElement.style.setProperty('--end-y', endY + 'px');
    
    document.body.appendChild(flyingElement);
    return flyingElement;
}


// 1. BAND CHANGE ANIMATION - frequencies sliding in from the side
animateBandChange(newBand, newFreq) {
    const bandBtn = document.querySelector(`[data-band="${newBand}"].active`);
    const lcdPanel = document.getElementById('lcdPanel');
    
    if (bandBtn && lcdPanel) {
        const freqElement = document.createElement('div');
        freqElement.textContent = `${newBand}m - ${(newFreq/1000000).toFixed(3)} MHz`;
        freqElement.style.cssText = `
            position: fixed;
            right: -300px;
            top: ${lcdPanel.getBoundingClientRect().top}px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: black;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 10000;
            animation: slideInFromRight 1s ease-out forwards;
        `;
        document.body.appendChild(freqElement);
        setTimeout(() => freqElement.remove(), 1000);
    }
}

// 2. MEMORY RECALL ANIMATION - frequency "teleporting" from memory button
animateMemoryRecall(memoryChannel, frequency) {
    const memBtn = document.querySelector(`[data-channel="${memoryChannel}"]`);
    const lcdPanel = document.getElementById('lcdPanel');
    
    if (memBtn && lcdPanel) {
        const memRect = memBtn.getBoundingClientRect();
        const lcdRect = lcdPanel.getBoundingClientRect();
        
        const recallElement = document.createElement('div');
        recallElement.textContent = `M${memoryChannel}: ${(frequency/1000000).toFixed(3)} MHz`;
        recallElement.style.cssText = `
            position: fixed;
            left: ${memRect.left + memRect.width/2}px;
            top: ${memRect.top + memRect.height/2}px;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 136, 0.9);
            color: black;
            padding: 8px 16px;
            border-radius: 15px;
            font-weight: bold;
            z-index: 10000;
            animation: memoryTeleport 0.8s ease-out forwards;
        `;
        
        recallElement.style.setProperty('--target-x', lcdRect.left + lcdRect.width/2 + 'px');
        recallElement.style.setProperty('--target-y', lcdRect.top + lcdRect.height/2 + 'px');
        
        document.body.appendChild(recallElement);
        setTimeout(() => recallElement.remove(), 800);
    }
}

	animateVFOCopy(sourceVFO, targetVFO, frequency) {
    const sourceButton = document.getElementById(`vfo${sourceVFO}`);
    const targetButton = document.getElementById(`vfo${targetVFO}`);
    
    if (!sourceButton || !targetButton) return;
    
    // Get button positions
    const sourceRect = sourceButton.getBoundingClientRect();
    const targetRect = targetButton.getBoundingClientRect();
    
    // Create flying frequency element
    const flyingFreq = this.createCopyingFrequency(
        (frequency / 1000000).toFixed(3) + ' MHz',
        sourceRect,
        targetRect,
        sourceVFO === 'A' ? '#00ff88' : '#00ccff'
    );
    
    // Visual feedback - source button pulses, target button "receives"
    sourceButton.style.animation = 'vfoCopySource 1s ease-out';
    targetButton.style.animation = 'vfoCopyTarget 1s ease-out';
    
    // Clean up after animation
    setTimeout(() => {
        flyingFreq.remove();
        sourceButton.style.animation = '';
        targetButton.style.animation = '';
    }, 1000);
}




createCopyingFrequency(freqText, sourceRect, targetRect, color) {
    const flyingElement = document.createElement('div');
    flyingElement.textContent = freqText;
    flyingElement.style.cssText = `
        position: fixed;
        left: ${sourceRect.left + sourceRect.width/2}px;
        top: ${sourceRect.top + sourceRect.height/2}px;
        transform: translate(-50%, -50%);
        background: ${color};
        color: black;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.9em;
        box-shadow: 0 0 20px ${color};
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        animation: copyFrequency 1s ease-in-out forwards;
    `;
    
    // Calculate target position
    const targetX = targetRect.left + targetRect.width/2;
    const targetY = targetRect.top + targetRect.height/2;
    
    // Set CSS custom properties for the target position
    flyingElement.style.setProperty('--target-x', targetX + 'px');
    flyingElement.style.setProperty('--target-y', targetY + 'px');
    
    document.body.appendChild(flyingElement);
    return flyingElement;
}







// ADD this new method to calculate the noise floor:
calculateNoiseFloor(frequencyData, relevantBins) {
    // Method 1: Simple statistical approach
	//console.log('Method 1:',this.noiseFloorMethod);
   if (this.noiseFloorMethod === 'statistical') {
        // Calculate average and add threshold margin
        let sum = 0;
        for (let i = 0; i < relevantBins; i++) {
            sum += frequencyData[i];
        }
        const average = sum / relevantBins;
        return average + this.signalThreshold;
    } 
	
    
	 
    // Method 2: Moving average with percentile threshold (recommended)
  if (this.noiseFloorMethod === 'percentile' || !this.noiseFloorMethod) {
        // Sort the data to find the 75th percentile as noise floor
        const sortedData = Array.from(frequencyData.slice(0, relevantBins)).sort((a, b) => a - b);
        const percentileIndex = Math.floor(sortedData.length * 0.85);
        const noiseFloor = sortedData[percentileIndex];
		//console.log('Method 2:',this.noiseFloorMethod);
        return noiseFloor + this.signalThreshold;
    }
    
  
  
  // Method 3: Adaptive threshold
  if (this.noiseFloorMethod === 'adaptive') {
  //console.log('Method 3');
        // Track noise floor over time
        if (!this.adaptiveNoiseHistory) {
            this.adaptiveNoiseHistory = [];
        }
        
        let sum = 0;
        for (let i = 0; i < relevantBins; i++) {
            sum += frequencyData[i];
        }
        const currentAverage = sum / relevantBins;
        
        this.adaptiveNoiseHistory.push(currentAverage);
        if (this.adaptiveNoiseHistory.length > 20) {
            this.adaptiveNoiseHistory.shift(); // Keep only last 20 samples
        }
        
        const adaptiveAverage = this.adaptiveNoiseHistory.reduce((a, b) => a + b, 0) / this.adaptiveNoiseHistory.length;
        return adaptiveAverage + this.signalThreshold;
    }
}  

	
	
calibrateNoiseFloor() {
    if (!this.frequencyData) return;
    console.log('Calibrating noise floor');
    // Take several samples during quiet period
    this.logCAT('Calibrating noise floor - ensure no signals present...', 'info');
    
    let samples = [];
    const sampleCount = 10;
    let sampleIndex = 0;
    
    const takeSample = () => {
        if (sampleIndex < sampleCount) {
            this.inputAnalyser.getByteFrequencyData(this.frequencyData);
            const relevantBins = Math.floor(this.inputAnalyser.frequencyBinCount * (this.spectrumBandwidth / (this.audioContext.sampleRate / 2)));
            
            let sum = 0;
            for (let i = 0; i < relevantBins; i++) {
                sum += this.frequencyData[i];
            }
            samples.push(sum / relevantBins);
            sampleIndex++;
            
            setTimeout(takeSample, 200);
        } else {
            // Calculate calibrated threshold
            const avgNoise = samples.reduce((a, b) => a + b, 0) / samples.length;
            this.signalThreshold = Math.round(avgNoise * 0.3); // 30% above average noise
            
            this.logCAT(`Noise floor calibrated: threshold set to ${this.signalThreshold}`, 'info');
            
            // Update UI if slider exists
            const thresholdSlider = document.getElementById('signalThreshold');
            const thresholdValue = document.getElementById('thresholdValue');
            if (thresholdSlider) thresholdSlider.value = this.signalThreshold;
            if (thresholdValue) thresholdValue.textContent = this.signalThreshold;
        }
    };
    
    takeSample();
}


animateFrequencyText(delta) {
    // Create floating direction indicator
    const lcdPanel = document.getElementById('lcdPanel');
    if (!lcdPanel) return;
    
    const rect = lcdPanel.getBoundingClientRect();
    const indicator = document.createElement('div');
    
    // Determine direction and symbol
    const isUp = delta > 0;
    const symbol = isUp ? '▲' : '▼';
    const stepSize = Math.abs(delta);
    
    indicator.textContent = symbol;
    indicator.style.cssText = `
        position: fixed;
        left: ${rect.right - 30}px;
        top: ${rect.top + rect.height/2}px;
        transform: translateY(-50%);
        color: ${isUp ? '#00ff88' : '#ff9500'};
        font-size: 1.5em;
        font-weight: bold;
        z-index: 1000;
        pointer-events: none;
        animation: tuningIndicator 0.6s ease-out forwards;
        text-shadow: 0 0 8px currentColor;
    `;
    
    document.body.appendChild(indicator);
    
    // Also animate the LCD display digits
    this.animateLCDDigits();
    
    // Clean up
    setTimeout(() => indicator.remove(), 600);
}



animateLCDDigits() {
return;   
   const lcdRow1 = document.getElementById('lcdRow1');
    if (!lcdRow1) return;
    
    // Brief glow effect on the frequency display
    lcdRow1.style.textShadow = '0 0 15px var(--accent-color), 0 0 25px var(--accent-color)';
    lcdRow1.style.transform = 'scale(1.02)';
    lcdRow1.style.transition = 'all 0.1s ease';
    
    setTimeout(() => {
        lcdRow1.style.textShadow = '0 0 8px var(--accent-color)';
        lcdRow1.style.transform = 'scale(1)';
    }, 150);
}


animateStepSizeIndicator(delta) {
    const stepDisplay = document.getElementById('stepSize');
    if (!stepDisplay) return;
    
    const currentStep = Math.abs(delta);
    let stepText = '';
    
    if (currentStep >= 10000) stepText = '10k';
    else if (currentStep >= 1000) stepText = '1k';
    else if (currentStep >= 100) stepText = '100';
    else if (currentStep >= 10) stepText = '10';
    else stepText = '1';
    
    // Create floating step indicator
    const rect = stepDisplay.getBoundingClientRect();
    const stepIndicator = document.createElement('div');
    
    stepIndicator.textContent = `±${stepText}`;
    stepIndicator.style.cssText = `
        position: fixed;
        left: ${rect.right + 10}px;
        top: ${rect.top + rect.height/2}px;
        transform: translateY(-50%);
        background: var(--accent-color);
        color: black;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 0.8em;
        font-weight: bold;
        z-index: 1000;
        pointer-events: none;
        animation: stepIndicator 0.8s ease-out forwards;
    `;
    
    document.body.appendChild(stepIndicator);
    setTimeout(() => stepIndicator.remove(), 800);
}


animateFrequencyDirection(delta) {
    const lcdPanel = document.getElementById('lcdPanel');
    if (!lcdPanel) return;
    
    const rect = lcdPanel.getBoundingClientRect();
    const freqText = document.createElement('div');
    
    const sign = delta > 0 ? '+' : '-';
    const absValue = Math.abs(delta);
    let displayValue = '';
    
    if (absValue >= 1000000) {
        displayValue = `${sign}${(absValue/1000000).toFixed(3)}M`;
    } else if (absValue >= 1000) {
        displayValue = `${sign}${(absValue/1000).toFixed(1)}k`;
    } else {
        displayValue = `${sign}${absValue}`;
    }
    
    freqText.textContent = displayValue;
    freqText.style.cssText = `
        position: fixed;
        left: ${rect.left + rect.width/2}px;
        top: ${rect.bottom + 5}px;
        transform: translateX(-50%);
        color: ${delta > 0 ? '#00ff88' : '#ff9500'};
        font-family: 'Courier New', monospace;
        font-size: 1.1em;
        font-weight: bold;
        z-index: 1000;
        pointer-events: none;
        animation: freqChange 1s ease-out forwards;
        text-shadow: 0 0 8px currentColor;
    `;
    
    document.body.appendChild(freqText);
    setTimeout(() => freqText.remove(), 1000);
}


// Replace your existing fixVolumeKnobPointers() function with this:
// Replace your fixVolumeKnobPointers() function with this updated version:
fixVolumeKnobPointers() {
    const style = document.createElement('style');
    style.innerHTML = `
        /* Main line - thinner and shorter for volume knobs */
        .volume-knob::after {
            content: "" !important;
            position: absolute !important;
            width: 3px !important;
            height: 30px !important;
            background: linear-gradient(to top, #333 0%, #333 85%, transparent 85%, transparent 100%) !important;
            top: 10px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 3 !important;
            transition: background-color 0.2s ease !important;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4) !important;
            border-radius: 0 !important;
        }
        
        /* Triangle tip - this creates the pointed end */
        .volume-knob::before {
            content: "" !important;
            position: absolute !important;
            width: 0 !important;
            height: 0 !important;
            border-left: 3px solid transparent !important;
            border-right: 3px solid transparent !important;
            border-bottom: 8px solid #333 !important;
            top: 5px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 4 !important;
        }
        
        /* Hover effects */
        .volume-knob:hover::after {
            background: linear-gradient(to top, #00ff88 0%, #00ff88 85%, transparent 85%, transparent 100%) !important;
        }
        
        .volume-knob:hover::before {
            border-bottom-color: #00ff88 !important;
        }
    `;
    document.head.appendChild(style);
    
    // Force a redraw
    const volumeKnobs = document.querySelectorAll('.volume-knob');
    volumeKnobs.forEach(knob => {
        knob.style.display = 'none';
        knob.offsetHeight; // Trigger reflow
        knob.style.display = '';
    });
    
    console.log('Volume knob pointer styles updated with triangle tip');
}



updatePowerMeter(powerTenths) {
    const meter = document.getElementById('powerMeter');
    const powerText = document.getElementById('powerText');
     
    if (!meter || !powerText) return;
    
    // Convert tenths to actual watts (PC45 = 4.5W)
    const watts = powerTenths / 10.0;
    
    // Calculate percentage (assuming max 5W for QRP)
    const maxWatts = 5.0;
    const percentage = Math.max(0, Math.min(100, (watts / maxWatts) * 100));
    
    // Update meter bar
    meter.style.width = percentage + '%';
    
    // Update text display
    powerText.textContent = `${watts.toFixed(1)}W`;
    
    // Color coding based on power level
    if (watts >= 4.0) {
        powerText.style.color = '#ff4757'; // Red for high power
    } else if (watts >= 2.0) {
        powerText.style.color = '#ffff00'; // Yellow for medium power
    } else {
        powerText.style.color = '#00ff88'; // Green for low power
    }
}



// Add this method to initialize the voice keyer
initVoiceKeyer() {
    try {
        console.log('Initializing Voice Keyer...');
        
        // Add event listeners for voice keyer controls
        document.getElementById('voiceKeyerRecord').addEventListener('click', () => {
            this.toggleVoiceRecording();
        });
        
        document.getElementById('voiceKeyerPlay').addEventListener('click', () => {
            this.playVoiceMessage();
        });
        
        document.getElementById('voiceKeyerStop').addEventListener('click', () => {
            this.stopVoiceKeyer();
        });
        
        document.getElementById('voiceKeyerClear').addEventListener('click', () => {
            this.clearVoiceMessage();
        });
        
        // Message slot buttons
        document.querySelectorAll('.voice-msg-btn').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                this.selectVoiceMessage(index + 1);
            });
        });
        
        // Auto-transmit checkbox
        document.getElementById('voiceAutoTx').addEventListener('change', (e) => {
            this.voiceKeyer.autoTransmit = e.target.checked;
			localStorage.setItem('qmxVoiceAutoTx', e.target.checked.toString());
        });
        
        this.updateVoiceKeyerUI();
        this.logCAT('Voice Keyer initialized', 'info');
		
		// Management buttons
document.getElementById('voiceExportBtn').addEventListener('click', () => {
    this.exportVoiceMessages();
});

document.getElementById('voiceImportBtn').addEventListener('click', () => {
    document.getElementById('voiceImportFile').click();
});

document.getElementById('voiceImportFile').addEventListener('change', (e) => {
    this.importVoiceMessages(e);
});

document.getElementById('voiceClearAllBtn').addEventListener('click', () => {
    this.clearAllVoiceMessages();
});
        
    } catch (error) {
        console.error('Error initializing voice keyer:', error);
        this.logCAT(`Voice keyer init error: ${error.message}`, 'error');
    }
}

async toggleVoiceRecording() {
    if (this.voiceKeyer.isRecording) {
        await this.stopVoiceRecording();
    } else {
        await this.startVoiceRecording();
    }
}

async startVoiceRecording() {
    try {
	
	     
         this.voiceKeyer.volumeBeforeRecord = this.volumeLevel;
        this.volumeLevel = 0;
        this.updateVolumeUI();
        
        // Send volume command to radio if connected
        if (this.connected) {
            await this.sendVolumeCommand();
        }
        
        this.logCAT('Volume set to 0 for clean recording', 'info');




		 // Auto-pause audio streaming to prevent interference
        if (this.isAudioStreaming) {
            this.wasStreamingBeforeRecord = true;
            await this.stopAudioStream();
            this.logCAT('Audio streaming paused for clean recording', 'info');
        } else {
            this.wasStreamingBeforeRecord = false;
        }
        
        if (!this.selectedInputDevice) {
            this.logCAT('Select an input device first', 'error');
            return;
        }
        
        this.logCAT(`Recording message ${this.voiceKeyer.currentSlot}...`, 'info');
        
        // Get microphone stream with same settings as audio streaming
        let audioConstraints = {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
            sampleRate: 48000
        };
        
        if (this.selectedInputDevice !== 'default') {
            audioConstraints.deviceId = { exact: this.selectedInputDevice };
        }
        
        this.voiceKeyer.recordingStream = await navigator.mediaDevices.getUserMedia({
            audio: audioConstraints
        });
        
        // Create MediaRecorder
        const options = {
            mimeType: 'audio/webm;codecs=opus',
            audioBitsPerSecond: 64000 // Good quality for voice
        };
        
        this.voiceKeyer.mediaRecorder = new MediaRecorder(this.voiceKeyer.recordingStream, options);
        this.voiceKeyer.recordedChunks = [];
        
        this.voiceKeyer.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                this.voiceKeyer.recordedChunks.push(event.data);
            }
        };
        
        this.voiceKeyer.mediaRecorder.onstop = () => {
            this.finishVoiceRecording();
        };
        
        // Start recording
        this.voiceKeyer.mediaRecorder.start(100); // Collect data every 100ms
        this.voiceKeyer.isRecording = true;
        this.updateVoiceKeyerUI();
        
    } catch (error) {
        console.error('Voice recording start error:', error);
        this.logCAT(`Recording error: ${error.message}`, 'error');
    }
}

async stopVoiceRecording() {
    if (this.voiceKeyer.mediaRecorder && this.voiceKeyer.isRecording) {
        this.voiceKeyer.mediaRecorder.stop();
        this.voiceKeyer.isRecording = false;
        
        // Stop recording stream
        if (this.voiceKeyer.recordingStream) {
            this.voiceKeyer.recordingStream.getTracks().forEach(track => track.stop());
            this.voiceKeyer.recordingStream = null;
        }
        
        // Restore original volume
        if (this.voiceKeyer.volumeBeforeRecord !== null) {
            this.volumeLevel = this.voiceKeyer.volumeBeforeRecord;
            this.updateVolumeUI();
            
            // Send restored volume to radio if connected
            if (this.connected) {
                await this.sendVolumeCommand();
            }
            
            this.logCAT(`Volume restored to ${this.volumeLevel}%`, 'info');
            this.voiceKeyer.volumeBeforeRecord = null;
        }
        
        // Auto-resume audio streaming if it was running before
        if (this.wasStreamingBeforeRecord) {
            setTimeout(async () => {
                await this.startAudioStream();
                this.logCAT('Audio streaming resumed after recording', 'info');
            }, 500);
        }
        
        this.updateVoiceKeyerUI();
    }
}

finishVoiceRecording() {
    try {
        // Create blob from recorded chunks
        const blob = new Blob(this.voiceKeyer.recordedChunks, {
            type: 'audio/webm;codecs=opus'
        });
        
        // Store in current slot
        this.voiceKeyer.messages[this.voiceKeyer.currentSlot - 1] = {
            blob: blob,
            duration: 0, // Will be calculated when playing
            recorded: new Date().toISOString()
        };
        this.saveVoiceMessages();
        this.logCAT(`Message ${this.voiceKeyer.currentSlot} recorded (${(blob.size/1024).toFixed(1)} KB)`, 'info');
        this.updateVoiceKeyerUI();
        
    } catch (error) {
        console.error('Error finishing recording:', error);
        this.logCAT(`Recording finish error: ${error.message}`, 'error');
    }
}

async playVoiceMessage() {
    try {
        const message = this.voiceKeyer.messages[this.voiceKeyer.currentSlot - 1];
        if (!message) {
            this.logCAT(`Message slot ${this.voiceKeyer.currentSlot} is empty`, 'error');
            return;
        }
        
        if (this.voiceKeyer.isPlaying) {
            this.logCAT('Already playing a message', 'error');
            return;
        }
        
        // **NEW: Save current volume and mute before transmission**
        this.voiceKeyer.volumeBeforePlayback = this.volumeLevel;
        this.volumeLevel = 0;
        this.updateVolumeUI();
        
        // Send volume command to radio if connected
        if (this.connected) {
            await this.sendVolumeCommand();
        }
        
        this.logCAT('Volume muted for transmission', 'info');
        
        // Auto-transmit if enabled and connected
        if (this.voiceKeyer.autoTransmit && this.connected) {
            await this.sendCommand('TX');
            this.transmitting = true;
            this.updateTXStatus();
            
            // Small delay to ensure TX is active
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        this.logCAT(`Playing message ${this.voiceKeyer.currentSlot}...`, 'info');
        
        // Create audio context if needed
        if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // Convert blob to array buffer
        const arrayBuffer = await message.blob.arrayBuffer();
        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        
        // Create audio source
        this.voiceKeyer.playbackNode = this.audioContext.createBufferSource();
        this.voiceKeyer.playbackNode.buffer = audioBuffer;
        
        // Connect to output (speakers)
        this.voiceKeyer.playbackNode.connect(this.audioContext.destination);
        
        // Handle playback end
        this.voiceKeyer.playbackNode.onended = () => {
            this.voiceKeyerPlaybackEnded();
        };
        
        // Start playback
        this.voiceKeyer.playbackNode.start(0);
        this.voiceKeyer.isPlaying = true;
        this.updateVoiceKeyerUI();
        
    } catch (error) {
        console.error('Voice playback error:', error);
        this.logCAT(`Playback error: ${error.message}`, 'error');
        this.voiceKeyerPlaybackEnded();
    }
}

voiceKeyerPlaybackEnded() {
    this.voiceKeyer.isPlaying = false;
    this.voiceKeyer.playbackNode = null;
    
    // Auto return to RX if auto-transmit was used
    if (this.voiceKeyer.autoTransmit && this.connected && this.transmitting) {
        setTimeout(async () => {
            await this.sendCommand('RX');
            this.transmitting = false;
            this.updateTXStatus();
            
            // **NEW: Restore volume after returning to RX**
            this.restoreVolumeAfterPlayback();
        }, 100);
    } else {
        // **NEW: If not using auto-transmit, restore volume immediately**
        this.restoreVolumeAfterPlayback();
    }
    
    this.updateVoiceKeyerUI();
    this.logCAT('Playback finished', 'info');
}
stopVoiceKeyer() {
    if (this.voiceKeyer.isRecording) {
        this.stopVoiceRecording();
    }
    
    if (this.voiceKeyer.isPlaying && this.voiceKeyer.playbackNode) {
        this.voiceKeyer.playbackNode.stop();
        this.voiceKeyer.playbackNode = null;
        this.voiceKeyerPlaybackEnded();
    }
    
    // Emergency volume restoration for recording
    if (this.voiceKeyer.volumeBeforeRecord !== null) {
        this.volumeLevel = this.voiceKeyer.volumeBeforeRecord;
        this.updateVolumeUI();
        if (this.connected) {
            this.sendVolumeCommand();
        }
        this.voiceKeyer.volumeBeforeRecord = null;
        this.logCAT('Volume restored after stop', 'info');
    }
    
    // **NEW: Emergency volume restoration for playback**
    if (this.voiceKeyer.volumeBeforePlayback !== null) {
        this.restoreVolumeAfterPlayback();
    }
}
clearVoiceMessage() {
    const slot = this.voiceKeyer.currentSlot;
    if (this.voiceKeyer.messages[slot - 1]) {
        if (confirm(`Clear message ${slot}?`)) {
            this.voiceKeyer.messages[slot - 1] = null;
			this.saveVoiceMessages(); // Add this line
            this.logCAT(`Message ${slot} cleared`, 'info');
            this.updateVoiceKeyerUI();
        }
    } else {
        this.logCAT(`Message slot ${slot} is already empty`, 'info');
    }
}

selectVoiceMessage(slot) {
    this.voiceKeyer.currentSlot = slot;
    this.updateVoiceKeyerUI();
    this.logCAT(`Voice message slot ${slot} selected`, 'info');
}

updateVoiceKeyerUI() {
    // Update record button
    const recordBtn = document.getElementById('voiceKeyerRecord');
    if (recordBtn) {
        if (this.voiceKeyer.isRecording) {
            recordBtn.textContent = 'STOP REC';
            recordBtn.classList.add('btn-danger');
            recordBtn.classList.remove('btn-secondary');
        } else {
            recordBtn.textContent = 'RECORD';
            recordBtn.classList.remove('btn-danger');
            recordBtn.classList.add('btn-secondary');
        }
    }
    
    // Update play button
    const playBtn = document.getElementById('voiceKeyerPlay');
    if (playBtn) {
        const hasMessage = this.voiceKeyer.messages[this.voiceKeyer.currentSlot - 1] !== null;
        playBtn.disabled = !hasMessage || this.voiceKeyer.isRecording;
        
        if (this.voiceKeyer.isPlaying) {
            playBtn.textContent = 'PLAYING...';
            playBtn.classList.add('btn-primary');
        } else {
            playBtn.textContent = 'PLAY';
            playBtn.classList.remove('btn-primary');
        }
    }
    
    // Update message slot buttons
    document.querySelectorAll('.voice-msg-btn').forEach((btn, index) => {
        const slot = index + 1;
        const hasMessage = this.voiceKeyer.messages[index] !== null;
        
        btn.classList.remove('voice-msg-active', 'voice-msg-occupied');
        
        if (slot === this.voiceKeyer.currentSlot) {
            btn.classList.add('voice-msg-active');
        }
        if (hasMessage) {
            btn.classList.add('voice-msg-occupied');
        }
        
        btn.title = hasMessage ? 
            `MSG ${slot}: Recorded ${new Date(this.voiceKeyer.messages[index].recorded).toLocaleString()}` :
            `MSG ${slot}: Empty`;
    });
    
    // Update current slot indicator
    const slotIndicator = document.getElementById('voiceCurrentSlot');
    if (slotIndicator) {
        const hasMessage = this.voiceKeyer.messages[this.voiceKeyer.currentSlot - 1] !== null;
        slotIndicator.textContent = `MSG ${this.voiceKeyer.currentSlot} ${hasMessage ? '(READY)' : '(EMPTY)'}`;
    }
}








// Add this method to your QMXInterface class
initZoomControls() {
    try {
        const container = document.querySelector('.transceiver-container');
        const zoomLevel = document.getElementById('zoomLevel');
        
        document.getElementById('zoomIn').addEventListener('click', () => {
            this.adjustZoom(this.zoomStep);
        });
        
        document.getElementById('zoomOut').addEventListener('click', () => {
            this.adjustZoom(-this.zoomStep);
        });
        
        document.getElementById('zoomReset').addEventListener('click', () => {
            this.setZoom(1.0);
        });
        
        document.getElementById('zoomFit').addEventListener('click', () => {
            this.fitToWindow();
        });
		
		
		  
        // Add fullscreen toggle
        document.getElementById('fullscreenToggle').addEventListener('click', () => {
            this.toggleFullscreen();
        });
        
        // Listen for fullscreen changes to update button
        document.addEventListener('fullscreenchange', () => {
            this.updateFullscreenButton();
        });
		
		
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    this.adjustZoom(this.zoomStep);
                } else if (e.key === '-') {
                    e.preventDefault();
                    this.adjustZoom(-this.zoomStep);
                } else if (e.key === '0') {
                    e.preventDefault();
                    this.setZoom(1.0);
                }
            }
        });
		
		  // Keyboard shortcut F11
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey) {
                // Existing zoom shortcuts...
            }
            
            // F11 for fullscreen (prevent browser default)
            if (e.key === 'F11') {
                e.preventDefault();
                this.toggleFullscreen();
            }
        });
        
        this.updateFullscreenButton();
        console.log('Zoom and fullscreen controls initialized');
   
        
        console.log('Zoom controls initialized');
    } catch (error) {
        console.error('Error initializing zoom controls:', error);
    }
}

adjustZoom(delta) {
    const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.currentZoom + delta));
    this.setZoom(newZoom);
}

setZoom(zoom) {
    this.currentZoom = zoom;
    const container = document.querySelector('.transceiver-container');
    const zoomLevel = document.getElementById('zoomLevel');
    
    if (container) {
        container.style.transform = `scale(${zoom})`;
        container.style.width = `${1400 / zoom}px`;
        container.style.height = `${750 / zoom}px`;
    }
    
    if (zoomLevel) {
        zoomLevel.textContent = `${Math.round(zoom * 100)}%`;
    }
    
    // Adjust body scroll to accommodate scaled content
    document.body.style.overflow = zoom > 1.0 ? 'auto' : 'hidden';
}

fitToWindow() {
    const container = document.querySelector('.transceiver-container');
    if (!container) return;
    
    const windowWidth = window.innerWidth - 40; // 20px margin each side
    const windowHeight = window.innerHeight - 40;
    const containerWidth = 1400;
    const containerHeight = 750;
    
    const scaleX = windowWidth / containerWidth;
    const scaleY = windowHeight / containerHeight;
    const optimalZoom = Math.min(scaleX, scaleY, this.maxZoom);
    
    this.setZoom(Math.max(this.minZoom, optimalZoom));
}

// Add fullscreen capability
toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        document.exitFullscreen();
    }
}



// Add these new methods
toggleFullscreen() {
    try {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            this.logCAT('Entering fullscreen mode', 'info');
        } else {
            document.exitFullscreen();
            this.logCAT('Exiting fullscreen mode', 'info');
        }
    } catch (error) {
        console.error('Fullscreen error:', error);
        this.logCAT(`Fullscreen error: ${error.message}`, 'error');
    }
}

updateFullscreenButton() {
    const button = document.getElementById('fullscreenToggle');
    if (button) {
        if (document.fullscreenElement) {
            button.textContent = '⛷'; // Exit fullscreen icon
            button.title = 'Exit Fullscreen (F11)';
        } else {
            button.textContent = '⛶'; // Enter fullscreen icon
            button.title = 'Enter Fullscreen (F11)';
        }
    }
}



// Load voice messages from persistent storage
async loadVoiceMessages() {
    try {
        const savedMessages = localStorage.getItem('qmxVoiceMessages');
        if (savedMessages) {
            const messageData = JSON.parse(savedMessages);
            
            // Convert Base64 back to Blobs
            for (let i = 0; i < messageData.length; i++) {
                if (messageData[i] && messageData[i].blobData) {
                    try {
                        // Convert Base64 back to Blob
                        const binaryString = atob(messageData[i].blobData);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let j = 0; j < binaryString.length; j++) {
                            bytes[j] = binaryString.charCodeAt(j);
                        }
                        
                        const blob = new Blob([bytes], { type: 'audio/webm;codecs=opus' });
                        
                        this.voiceKeyer.messages[i] = {
                            blob: blob,
                            duration: messageData[i].duration || 0,
                            recorded: messageData[i].recorded
                        };
                        
                    } catch (conversionError) {
                        console.warn(`Failed to load voice message ${i + 1}:`, conversionError);
                        this.voiceKeyer.messages[i] = null;
                    }
                }
            }
            
            this.logCAT(`Loaded ${this.voiceKeyer.messages.filter(m => m !== null).length} voice messages`, 'info');
        }
        
        // Update UI to reflect loaded messages
        setTimeout(() => this.updateVoiceKeyerUI(), 100);
		
		const savedAutoTx = localStorage.getItem('qmxVoiceAutoTx');
if (savedAutoTx !== null) {
    this.voiceKeyer.autoTransmit = savedAutoTx === 'true';
    const autoTxCheckbox = document.getElementById('voiceAutoTx');
    if (autoTxCheckbox) {
        autoTxCheckbox.checked = this.voiceKeyer.autoTransmit;
    }
}
        
    } catch (error) {
        console.error('Error loading voice messages:', error);
        this.logCAT(`Voice message load error: ${error.message}`, 'error');
    }
}



// Save voice messages to persistent storage
async saveVoiceMessages() {
    try {
        const messageData = [];
        
        // Convert Blobs to Base64 for storage
        for (let i = 0; i < this.voiceKeyer.messages.length; i++) {
            if (this.voiceKeyer.messages[i]) {
                try {
                    // Convert Blob to Base64
                    const blob = this.voiceKeyer.messages[i].blob;
                    const arrayBuffer = await blob.arrayBuffer();
                    const bytes = new Uint8Array(arrayBuffer);
                    let binaryString = '';
                    for (let j = 0; j < bytes.length; j++) {
                        binaryString += String.fromCharCode(bytes[j]);
                    }
                    const blobData = btoa(binaryString);
                    
                    messageData[i] = {
                        blobData: blobData,
                        duration: this.voiceKeyer.messages[i].duration,
                        recorded: this.voiceKeyer.messages[i].recorded
                    };
                    
                } catch (conversionError) {
                    console.warn(`Failed to save voice message ${i + 1}:`, conversionError);
                    messageData[i] = null;
                }
            } else {
                messageData[i] = null;
            }
        }
        
        localStorage.setItem('qmxVoiceMessages', JSON.stringify(messageData));
        console.log('Voice messages saved to localStorage');
        
    } catch (error) {
        console.error('Error saving voice messages:', error);
        this.logCAT(`Voice message save error: ${error.message}`, 'error');
        
        // If storage is full, offer to clear old messages
        if (error.name === 'QuotaExceededError') {
            if (confirm('Storage full. Clear old voice messages to save new ones?')) {
                this.clearAllVoiceMessages();
            }
        }
    }
}




// Clear all voice messages (with confirmation)
clearAllVoiceMessages() {
    if (confirm('Clear ALL voice messages? This cannot be undone.')) {
        this.voiceKeyer.messages = new Array(8).fill(null);
        localStorage.removeItem('qmxVoiceMessages');
        this.updateVoiceKeyerUI();
        this.logCAT('All voice messages cleared', 'info');
    }
}

// Export voice messages metadata
exportVoiceMessages() {
    try {
        const exportData = {
            version: '1.0',
            exportDate: new Date().toISOString(),
            messages: []
        };
        
        // Only export non-null messages
        this.voiceKeyer.messages.forEach((msg, index) => {
            if (msg) {
                exportData.messages.push({
                    slot: index + 1,
                    recorded: msg.recorded,
                    duration: msg.duration,
                    hasData: true
                });
            }
        });
        
        const jsonStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `qmx_voice_messages_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.logCAT('Voice message index exported', 'info');
        
    } catch (error) {
        this.logCAT(`Export error: ${error.message}`, 'error');
    }
}

// Import voice messages metadata
importVoiceMessages(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importData = JSON.parse(e.target.result);
            
            if (importData.messages && Array.isArray(importData.messages)) {
                const messageCount = importData.messages.length;
                
                alert(`Voice message import loaded metadata for ${messageCount} messages.\n\nNote: Audio data cannot be imported from JSON files.\nThis import only restores message slot information.`);
                
                this.logCAT(`Voice message metadata imported for ${messageCount} messages`, 'info');
            } else {
                throw new Error('Invalid file format');
            }
            
        } catch (error) {
            this.logCAT(`Import failed: ${error.message}`, 'error');
            alert('Failed to import voice message file.');
        }
    };
    
    reader.readAsText(file);
    event.target.value = '';
}



// Load step size from localStorage
loadStepSize() {
    try {
        const savedStepSize = localStorage.getItem('qmxStepSize');
        if (savedStepSize) {
            const stepValue = parseInt(savedStepSize);
            if (stepValue && stepValue > 0) {
                this.stepSize = stepValue;
                this.originalStepSize = stepValue;
                
                // Update the dropdown to show the saved value
                const stepSelect = document.getElementById('stepSize');
                if (stepSelect) {
                    stepSelect.value = stepValue.toString();
                }
                
                this.logCAT(`Loaded step size: ${stepValue} Hz`, 'info');
            }
        }
    } catch (error) {
        console.error('Error loading step size:', error);
        // Use default if loading fails
        this.stepSize = 1;
        this.originalStepSize = 1;
    }
}

// Save step size to localStorage
saveStepSize() {
    try {
        localStorage.setItem('qmxStepSize', this.originalStepSize.toString());
        console.log(`Step size saved: ${this.originalStepSize} Hz`);
    } catch (error) {
        console.error('Error saving step size:', error);
    }
}

// Initialize CW Keyer system
initCWKeyer() {
    try {
        console.log('Initializing CW Keyer...');
        
        const messageInput = document.getElementById('cwMessageInput');
        const charCount = document.getElementById('cwCharCount');
        
        messageInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
            charCount.textContent = e.target.value.length;
        });
        
        // --- UPDATED: Control button logic ---
        document.getElementById('cwStore').addEventListener('click', () => this.storeCWMessage());
        document.getElementById('cwSend').addEventListener('click', () => this.sendCWMessage());
        document.getElementById('cwClear').addEventListener('click', () => this.clearCWMessage());

        document.getElementById('cwEdit').addEventListener('click', () => {
            this.cwKeyer.isEditing = !this.cwKeyer.isEditing;
            this.updateCWKeyerUI();
            if (this.cwKeyer.isEditing) {
                this.logCAT('CW Edit Mode: ON. Select a message slot to edit.', 'info');
            } else {
                this.logCAT('CW Edit Mode: OFF.', 'info');
            }
        });
        
        // --- UPDATED: Memory slot button logic ---
        document.querySelectorAll('.cw-msg-btn').forEach((btn) => {
            btn.addEventListener('click', () => {
                const slotNumber = parseInt(btn.dataset.slot);
                this.selectCWSlot(slotNumber);

                if (this.cwKeyer.isEditing) {
                    this.openCwEditModal(slotNumber); // Open the new modal for editing
                } else {
                    if (this.connected) this.sendCWMessage();
                    else this.logCAT('Cannot send: Radio not connected.', 'error');
                }
            });
        });

        // --- NEW: Add listeners for the new modal ---
        const cwModalInput = document.getElementById('cwMessageModalInput');
        const cwModalCharCount = document.getElementById('cwModalCharCount');
        cwModalInput.addEventListener('input', () => {
            cwModalCharCount.textContent = cwModalInput.value.length;
        });

        document.getElementById('saveCwEdit').addEventListener('click', () => this.saveCwEdit());
        document.getElementById('cancelCwEdit').addEventListener('click', () => this.closeCwEditModal());
        
        // --- (Existing management and keyboard shortcut code remains the same) ---
        document.getElementById('cwExportBtn').addEventListener('click', () => this.exportCWMessages());
        document.getElementById('cwImportBtn').addEventListener('click', () => document.getElementById('cwImportFile').click());
        document.getElementById('cwImportFile').addEventListener('change', (e) => this.importCWMessages(e));
        document.getElementById('cwClearAllBtn').addEventListener('click', () => this.clearAllCWMessages());
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); this.storeCWMessage(); }
            else if (e.ctrlKey && e.key === 'Enter') { e.preventDefault(); this.sendCWMessage(); }
        });
		
		// Initialize cloned CW speed knob
this.initCWSpeedKnobClone();

// Add second keyer toggle listener
const keyerToggle2 = document.getElementById('keyerModeToggle2');
if (keyerToggle2) {
    keyerToggle2.addEventListener('click', () => {
        this.toggleKeyerMode();
    });
}
        
        this.updateCWKeyerUI();
        this.logCAT('CW Keyer Memory initialized', 'info');
        
    } catch (error) {
        console.error('Error initializing CW keyer:', error);
    }
}




// --- NEW Methods for CW Edit Modal ---

openCwEditModal(slotNumber) {
    this.cwKeyer.editingSlot = slotNumber; // Remember which slot we're editing
    const messageData = this.cwKeyer.messages[slotNumber - 1];

    // Populate modal fields
    document.getElementById('editCwChannelNumber').textContent = slotNumber;
    const messageInput = document.getElementById('cwMessageModalInput');
    const labelInput = document.getElementById('cwLabelModalInput');
    
    if (messageData) {
        messageInput.value = messageData.text || '';
        labelInput.value = messageData.label || '';
    } else {
        messageInput.value = '';
        labelInput.value = '';
    }
    document.getElementById('cwModalCharCount').textContent = messageInput.value.length;

    // Show the modal and overlay
    document.getElementById('modalOverlay').classList.add('active');
    document.getElementById('cwEditModal').classList.add('active');
    labelInput.focus();
}

closeCwEditModal() {
    document.getElementById('modalOverlay').classList.remove('active');
    document.getElementById('cwEditModal').classList.remove('active');
    this.cwKeyer.isEditing = false; // Always exit edit mode on close
    this.updateCWKeyerUI();
}

saveCwEdit() {
    const slot = this.cwKeyer.editingSlot;
    if (!slot) return;

    const messageText = document.getElementById('cwMessageModalInput').value.trim().toUpperCase();
    const labelText = document.getElementById('cwLabelModalInput').value.trim();

    if (!messageText) {
        alert('Message text cannot be empty.');
        return;
    }

    this.cwKeyer.messages[slot - 1] = {
        text: messageText,
        label: labelText,
        stored: new Date().toISOString()
    };

    this.saveCWMessages();
    this.logCAT(`CW${slot} updated. Label: "${labelText}"`, 'info');
    this.closeCwEditModal();
}

// Replace the old editCWMessage function with this empty one, as its logic has moved
editCWMessage() {
    // This function's logic is now handled by openCwEditModal()
    // It is kept to prevent errors if called from old code paths.
}
















// Store CW message in current slot
storeCWMessage() {
    const messageInput = document.getElementById('cwMessageInput');
    const message = messageInput.value.trim().toUpperCase();
    
    if (!message) {
        this.logCAT('Enter a message to store', 'error');
        messageInput.focus();
        return;
    }
    
    if (message.length > 80) {
        this.logCAT('Message too long (max 80 characters)', 'error');
        return;
    }
    
    const slot = this.cwKeyer.currentSlot;
    const existingMessage = this.cwKeyer.messages[slot - 1];
    
    if (existingMessage && existingMessage.text) {
        if (!confirm(`Overwrite CW${slot}?\n\nCurrent: "${existingMessage.text}"\nReplace with: "${message}"`)) {
            return;
        }
    }
    
    this.cwKeyer.messages[slot - 1] = {
        text: message,
        stored: new Date().toISOString()
    };
    
    this.saveCWMessages();
    this.updateCWKeyerUI();
    
    this.logCAT(`CW${slot} stored: "${message}" (${message.length} chars)`, 'info');
    
    // Clear input after storing
    messageInput.value = '';
    document.getElementById('cwCharCount').textContent = '0';
	 // --- ADD THESE LINES ---
    // Exit editing mode after storing a message
    this.cwKeyer.isEditing = false;
    this.updateCWKeyerUI(); 

}

// Send CW message from current slot
async sendCWMessage() {
  
  // --- ADD THESE LINES ---
    // Exit editing mode if user decides to send instead
    this.cwKeyer.isEditing = false;
    this.updateCWKeyerUI();

  if (!this.connected) {
        this.logCAT('Connect radio first', 'error');
        return;
    }
    
    if (this.cwKeyer.isSending) {
        this.logCAT('CW transmission in progress', 'error');
        return;
    }
    
    const slot = this.cwKeyer.currentSlot;
    const messageData = this.cwKeyer.messages[slot - 1];
    
    if (!messageData || !messageData.text) {
        this.logCAT(`CW${slot} is empty`, 'error');
        return;
    }
    
    const message = messageData.text;
    
    try {
        this.cwKeyer.isSending = true;
        this.cwKeyer.sendingMessage = message;
        this.updateCWKeyerUI();
        
        // Send KY command
        await this.sendCommand(`KY ${message}`);
        this.logCAT(`Sending CW${slot}: "${message}"`, 'info');
        
        // Monitor sending status
        this.monitorCWSending();
        
    } catch (error) {
        this.cwKeyer.isSending = false;
        this.updateCWKeyerUI();
        this.logCAT(`CW send error: ${error.message}`, 'error');
    }
}

// Monitor CW sending status
monitorCWSending() {
    if (!this.cwKeyer.isSending) return;
    
    // Request buffer status
    this.sendCommand('KY').then(() => {
        // Status will be processed in processResponse()
        setTimeout(() => {
            if (this.cwKeyer.isSending) {
                this.monitorCWSending();
            }
        }, 250);
    }).catch(() => {
        this.cwKeyer.isSending = false;
        this.updateCWKeyerUI();
    });
}

// Edit CW message
editCWMessage() {
    const slot = this.cwKeyer.currentSlot;
    const messageData = this.cwKeyer.messages[slot - 1];
    
    const messageInput = document.getElementById('cwMessageInput');
    
    if (messageData && messageData.text) {
        messageInput.value = messageData.text;
        document.getElementById('cwCharCount').textContent = messageData.text.length;
    } else {
        messageInput.value = '';
        document.getElementById('cwCharCount').textContent = '0';
    }
    
    messageInput.focus();
    messageInput.select();
    
    this.logCAT(`Editing CW${slot}`, 'info');
}

// Clear CW message
clearCWMessage() {
   
 // --- ADD THESE LINES ---
    // Exit editing mode if user decides to clear instead
    this.cwKeyer.isEditing = false;
    this.updateCWKeyerUI();

   const slot = this.cwKeyer.currentSlot;
    const messageData = this.cwKeyer.messages[slot - 1];
    
    if (messageData && messageData.text) {
        if (confirm(`Clear CW${slot}?\n\nMessage: "${messageData.text}"`)) {
            this.cwKeyer.messages[slot - 1] = null;
            this.saveCWMessages();
            this.updateCWKeyerUI();
            this.logCAT(`CW${slot} cleared`, 'info');
        }
    } else {
        this.logCAT(`CW${slot} is already empty`, 'info');
    }
}

// Select CW message slot
selectCWSlot(slot) {
    this.cwKeyer.currentSlot = slot;
    this.updateCWKeyerUI();
    this.logCAT(`CW message slot ${slot} selected`, 'info');
}

// Update CW Keyer UI
updateCWKeyerUI() {
    const slotIndicator = document.getElementById('cwCurrentMessage');
    const currentMessage = this.cwKeyer.messages[this.cwKeyer.currentSlot - 1];
    
    if (slotIndicator) {
        const hasMessage = currentMessage && currentMessage.text;
        const preview = hasMessage ? (currentMessage.label || currentMessage.text) : 'EMPTY';
        const previewText = preview.length > 20 ? preview.substring(0, 17) + '...' : preview;
        slotIndicator.textContent = `CW MSG ${this.cwKeyer.currentSlot} (${previewText})`;
    }
    
    // --- UPDATED: Logic to display labels on buttons ---
    document.querySelectorAll('.cw-msg-btn').forEach((btn, index) => {
        const slot = index + 1;
        const messageData = this.cwKeyer.messages[index];
        
        btn.classList.remove('cw-msg-active', 'cw-msg-occupied');
        
        if (slot === this.cwKeyer.currentSlot) {
            btn.classList.add('cw-msg-active');
        }
        
        if (messageData && messageData.text) {
            btn.classList.add('cw-msg-occupied');
            // Use the label if it exists, otherwise show character count
            const labelContent = messageData.label ? messageData.label : `${messageData.text.length}ch`;
            btn.innerHTML = `CW${slot}<span class="cw-msg-label">${labelContent}</span>`;
            btn.title = `CW${slot}: "${messageData.text}" (${messageData.text.length} chars)\nLabel: ${messageData.label || 'None'}`;
        } else {
            btn.innerHTML = `CW${slot}`;
            btn.title = `CW${slot}: Empty`;
        }
    });
    
    const sendBtn = document.getElementById('cwSend');
    const statusDiv = document.getElementById('cwKeyerStatus');
    
    if (sendBtn && statusDiv) {
        if (this.cwKeyer.isSending) {
            sendBtn.textContent = 'SENDING...';
            sendBtn.disabled = true;
            statusDiv.textContent = `Sending...`;
            statusDiv.style.color = 'var(--accent-color)';
            document.body.classList.add('cw-sending');
        } else {
            sendBtn.textContent = 'SEND';
            sendBtn.disabled = false;
            statusDiv.textContent = this.connected ? 'Ready' : 'Not connected';
            statusDiv.style.color = '#888';
            document.body.classList.remove('cw-sending');
        }
    }

    // Add visual feedback for editing mode
    const editBtn = document.getElementById('cwEdit');
    const keyerPanel = document.getElementById('cwKeyerPanel');

    if (this.cwKeyer.isEditing) {
        editBtn.classList.remove('btn-secondary');
        editBtn.classList.add('btn-primary');
        keyerPanel.style.boxShadow = '0 0 15px var(--accent-color)';
    } else {
        editBtn.classList.remove('btn-primary');
        editBtn.classList.add('btn-secondary');
        keyerPanel.style.boxShadow = '';
    }
}
// Load CW messages from localStorage
loadCWMessages() {
    try {
        const savedMessages = localStorage.getItem('qmxCWMessages');
        if (savedMessages) {
            this.cwKeyer.messages = JSON.parse(savedMessages);
            const messageCount = this.cwKeyer.messages.filter(m => m !== null).length;
            this.logCAT(`Loaded ${messageCount} CW messages`, 'info');
        }
        
        // Update UI after loading
        setTimeout(() => this.updateCWKeyerUI(), 100);
        
    } catch (error) {
        console.error('Error loading CW messages:', error);
        this.logCAT(`CW message load error: ${error.message}`, 'error');
    }
}

// Save CW messages to localStorage
saveCWMessages() {
    try {
        localStorage.setItem('qmxCWMessages', JSON.stringify(this.cwKeyer.messages));
    } catch (error) {
        console.error('Error saving CW messages:', error);
        this.logCAT(`CW message save error: ${error.message}`, 'error');
    }
}

// Clear all CW messages
clearAllCWMessages() {
    const usedSlots = this.cwKeyer.messages.filter(m => m !== null).length;
    
    if (usedSlots === 0) {
        this.logCAT('No CW messages to clear', 'info');
        return;
    }
    
    if (confirm(`Clear ALL CW messages?\n\nThis will delete ${usedSlots} stored messages.\nThis action cannot be undone!`)) {
        this.cwKeyer.messages = new Array(8).fill(null);
        this.saveCWMessages();
        this.updateCWKeyerUI();
        this.logCAT(`Cleared all ${usedSlots} CW messages`, 'info');
    }
}

// Export CW messages
exportCWMessages() {
    try {
        const exportData = {
            version: '1.0',
            exportDate: new Date().toISOString(),
            messages: this.cwKeyer.messages
        };
        
        const jsonStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `qmx_cw_messages_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.logCAT('CW messages exported', 'info');
        
    } catch (error) {
        this.logCAT(`Export error: ${error.message}`, 'error');
    }
}

// Import CW messages
importCWMessages(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importData = JSON.parse(e.target.result);
            
            if (importData.messages && Array.isArray(importData.messages)) {
                if (confirm('This will replace all current CW messages. Continue?')) {
                    this.cwKeyer.messages = importData.messages;
                    this.saveCWMessages();
                    this.updateCWKeyerUI();
                    
                    const messageCount = this.cwKeyer.messages.filter(m => m !== null).length;
                    this.logCAT(`CW messages imported: ${messageCount} messages`, 'info');
                }
            } else {
                throw new Error('Invalid file format');
            }
            
        } catch (error) {
            this.logCAT(`Import failed: ${error.message}`, 'error');
            alert('Failed to import CW message file.');
        }
    };
    
    reader.readAsText(file);
    event.target.value = '';
}


async restoreVolumeAfterPlayback() {
    if (this.voiceKeyer.volumeBeforePlayback !== undefined && this.voiceKeyer.volumeBeforePlayback !== null) {
        this.volumeLevel = this.voiceKeyer.volumeBeforePlayback;
        this.updateVolumeUI();
        
        // Send restored volume to radio if connected
        if (this.connected) {
            await this.sendVolumeCommand();
        }
        
        this.logCAT(`Volume restored to ${this.volumeLevel}%`, 'info');
        this.voiceKeyer.volumeBeforePlayback = null;
    }
}




initCWSpeedKnobClone() {
    try {
        const cwSpeedKnob = document.getElementById('cwSpeedKnob');
        if (!cwSpeedKnob) {
            console.error('CW Speed knob clone not found');
            return;
        }
        
        // Set initial position to match main knob
        cwSpeedKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        this.updateCWSpeedCloneUI();
        
        // Add event listeners
        cwSpeedKnob.addEventListener('mousedown', this.startCWSpeedCloneAdjust.bind(this));
        cwSpeedKnob.addEventListener('touchstart', this.startCWSpeedCloneAdjust.bind(this), { passive: false });
        cwSpeedKnob.addEventListener('wheel', this.handleCWSpeedCloneWheel.bind(this));
        cwSpeedKnob.addEventListener('keydown', this.handleCWSpeedCloneKeyboard.bind(this));
        cwSpeedKnob.setAttribute('aria-valuenow', this.rfGainLevel);
		  cwSpeedKnob.addEventListener('mouseenter', () => {
            this.enableCWSpeedHoverKeys();
        });
        cwSpeedKnob.addEventListener('mouseleave', () => {
            this.disableCWSpeedHoverKeys();
        });
        
        
        console.log('CW Speed knob clone initialized');
    } catch (error) {
        console.error('Error initializing CW speed knob clone:', error);
    }
}

startCWSpeedCloneAdjust(e) {
    if (this.keyerMode === 'straight') return;
    
    e.preventDefault();
    this.isRFGainAdjusting = true;
    const rect = e.target.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    this.boundContinueCWSpeedCloneAdjust = this.continueCWSpeedCloneAdjust.bind(this);
    this.boundStopCWSpeedCloneAdjust = this.stopCWSpeedCloneAdjust.bind(this);
    
    if (e.type === 'mousedown') {
        this.rfGainLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
        document.addEventListener('mousemove', this.boundContinueCWSpeedCloneAdjust);
        document.addEventListener('mouseup', this.boundStopCWSpeedCloneAdjust);
    } else if (e.type === 'touchstart') {
        const t = e.touches[0];
        this.rfGainLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
        document.addEventListener('touchmove', this.boundContinueCWSpeedCloneAdjust, { passive: false });
        document.addEventListener('touchend', this.boundStopCWSpeedCloneAdjust);
    }
}

continueCWSpeedCloneAdjust(e) {
    if (!this.isRFGainAdjusting) return;
    if (this.rfGainAnimationFrame) {
        cancelAnimationFrame(this.rfGainAnimationFrame);
    }
    
    this.rfGainAnimationFrame = requestAnimationFrame(() => {
        const cwSpeedKnob = document.getElementById('cwSpeedKnob');
        const rect = cwSpeedKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        let currentX, currentY;
        if (e.type === 'mousemove') {
            currentX = e.clientX;
            currentY = e.clientY;
        } else if (e.type === 'touchmove') {
            e.preventDefault();
            const t = e.touches[0];
            currentX = t.clientX;
            currentY = t.clientY;
        }
        
        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
        let deltaAngle = currentAngle - this.rfGainLastAngle;
        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
        
        const sensitivity = 0.7;
        deltaAngle *= sensitivity;
        
        const newRotation = this.rfGainKnobRotation + (deltaAngle * 180 / Math.PI);
        this.rfGainKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
        
        // Update both knobs
        cwSpeedKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        
        const newRFGainLevel = Math.round(((this.rfGainKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
        if (newRFGainLevel !== this.rfGainLevel) {
            this.rfGainLevel = newRFGainLevel;
            this.updateRFGainLevel();
            this.updateCWSpeedCloneUI();
            this.sendRFGainDynamically();
        }
        
        this.rfGainLastAngle = currentAngle;
        this.rfGainAnimationFrame = null;
    });
}

stopCWSpeedCloneAdjust() {
    this.isRFGainAdjusting = false;
    if (this.rfGainAnimationFrame) {
        cancelAnimationFrame(this.rfGainAnimationFrame);
        this.rfGainAnimationFrame = null;
    }
    if (this.boundContinueCWSpeedCloneAdjust && this.boundStopCWSpeedCloneAdjust) {
        document.removeEventListener('mousemove', this.boundContinueCWSpeedCloneAdjust);
        document.removeEventListener('mouseup', this.boundStopCWSpeedCloneAdjust);
        document.removeEventListener('touchmove', this.boundContinueCWSpeedCloneAdjust);
        document.removeEventListener('touchend', this.boundStopCWSpeedCloneAdjust);
        this.boundContinueCWSpeedCloneAdjust = null;
        this.boundStopCWSpeedCloneAdjust = null;
    }
    this.sendRFGainCommand();
}

handleCWSpeedCloneWheel(e) {
    if (this.keyerMode === 'straight') return;
    
    e.preventDefault();
    let steps = e.deltaY > 0 ? -1 : 1;
    const cwSpeedDelta = steps * 1;
    const currentCWSpeed = Math.round((this.rfGainLevel / 100) * 50);
    const newCWSpeed = Math.max(0, Math.min(50, currentCWSpeed + cwSpeedDelta));
    this.rfGainLevel = (newCWSpeed / 50) * 100;
    this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
    
    if (this.rfGainAnimationFrame) {
        cancelAnimationFrame(this.rfGainAnimationFrame);
    }
    this.rfGainAnimationFrame = requestAnimationFrame(() => {
        document.getElementById('cwSpeedKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        this.updateRFGainLevel();
        this.updateCWSpeedCloneUI();
        this.sendRFGainCommand();
        this.rfGainAnimationFrame = null;
    });
}

handleCWSpeedCloneKeyboard(e) {
    if (this.keyerMode === 'straight') return;
    
    if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        e.preventDefault();
        this.adjustRFGain(-5);
        this.updateCWSpeedCloneUI();
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        e.preventDefault();
        this.adjustRFGain(5);
        this.updateCWSpeedCloneUI();
    }
}

updateCWSpeedCloneUI() {
    const cwSpeedKnob = document.getElementById('cwSpeedKnob');
    const cwSpeedLevel = document.getElementById('cwSpeedLevel');
    const keyerToggle2 = document.getElementById('keyerModeToggle2');
    const cwSpeedContainer = cwSpeedKnob?.parentElement;
    
    if (!cwSpeedKnob || !cwSpeedLevel) return;
    
    const cwSpeed = Math.round((this.rfGainLevel / 100) * 50);
    
    // Update knob rotation
    cwSpeedKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
    
    // Update toggle switch
    if (keyerToggle2) {
        if (this.keyerMode === 'bug') {
            keyerToggle2.classList.add('bug');
        } else {
            keyerToggle2.classList.remove('bug');
        }
    }
    
    // Update label
    if (cwSpeed === 0) {
        cwSpeedLevel.textContent = 'STRAIGHT';
        cwSpeedLevel.style.color = '#ff4757';
    } else {
        cwSpeedLevel.textContent = `${cwSpeed} WPM`;
        cwSpeedLevel.style.color = '#00ff88';
    }
    
    // Disable/enable knob based on mode
    if (cwSpeedContainer) {
        if (this.keyerMode === 'straight') {
            cwSpeedContainer.classList.add('keyer-straight');
            cwSpeedKnob.style.opacity = '0.5';
            cwSpeedKnob.style.pointerEvents = 'none';
        } else {
            cwSpeedContainer.classList.remove('keyer-straight');
            cwSpeedKnob.style.opacity = '1';
            cwSpeedKnob.style.pointerEvents = 'auto';
        }
    }
}


enableCWSpeedHoverKeys() {
    if (this.keyerMode === 'straight') return;
    
    this.isCWSpeedHoverActive = true;
    
    if (!this.boundHandleCWSpeedHoverKeys) {
        this.boundHandleCWSpeedHoverKeys = this.handleCWSpeedHoverKeys.bind(this);
    }
    
    document.addEventListener('keydown', this.boundHandleCWSpeedHoverKeys);
    
    // Visual feedback
    const rfGainKnob = document.getElementById('rfGainKnob');
    const cwSpeedKnob = document.getElementById('cwSpeedKnob');
    
    if (rfGainKnob) {
        rfGainKnob.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 255, 136, 0.6)';
    }
    if (cwSpeedKnob) {
        cwSpeedKnob.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 255, 136, 0.6)';
    }
}

disableCWSpeedHoverKeys() {
    this.isCWSpeedHoverActive = false;
    
    if (this.boundHandleCWSpeedHoverKeys) {
        document.removeEventListener('keydown', this.boundHandleCWSpeedHoverKeys);
    }
    
    // Remove visual feedback
    const rfGainKnob = document.getElementById('rfGainKnob');
    const cwSpeedKnob = document.getElementById('cwSpeedKnob');
    
    if (rfGainKnob) {
        rfGainKnob.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3)';
    }
    if (cwSpeedKnob) {
        cwSpeedKnob.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3)';
    }
}

handleCWSpeedHoverKeys(e) {
    if (!this.isCWSpeedHoverActive || this.keyerMode === 'straight') return;
    
    // Only handle arrow keys
    if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
    
    e.preventDefault();
    
    let delta = 0;
    if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        delta = -1; // -1 WPM
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        delta = 1; // +1 WPM
    }
    
    if (delta !== 0) {
        const currentCWSpeed = Math.round((this.rfGainLevel / 100) * 50);
        const newCWSpeed = Math.max(0, Math.min(50, currentCWSpeed + delta));
        this.rfGainLevel = (newCWSpeed / 50) * 100;
        this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
        
        // Update both knobs
        const rfGainKnob = document.getElementById('rfGainKnob');
        const cwSpeedKnob = document.getElementById('cwSpeedKnob');
        
        if (rfGainKnob) {
            rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        }
        if (cwSpeedKnob) {
            cwSpeedKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
        }
        
        this.updateRFGainLevel();
        this.sendRFGainCommand();
        
        // Brief visual feedback
        this.provideCWSpeedKeyFeedback();
    }
}

provideCWSpeedKeyFeedback() {
    const rfGainKnob = document.getElementById('rfGainKnob');
    const cwSpeedKnob = document.getElementById('cwSpeedKnob');
    
    // Brief bright glow
    const brightGlow = '0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3), 0 0 25px rgba(0, 255, 136, 1)';
    const hoverGlow = '0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 255, 136, 0.6)';
    
    if (rfGainKnob) rfGainKnob.style.boxShadow = brightGlow;
    if (cwSpeedKnob) cwSpeedKnob.style.boxShadow = brightGlow;
    
    setTimeout(() => {
        if (this.isCWSpeedHoverActive) {
            if (rfGainKnob) rfGainKnob.style.boxShadow = hoverGlow;
            if (cwSpeedKnob) cwSpeedKnob.style.boxShadow = hoverGlow;
        }
    }, 150);
}










	//------------------------------------------------		
			
           cleanup() {
		     this.saveStepSize();
    if (this.timeSyncInterval) clearInterval(this.timeSyncInterval);
    if (this.clockUpdateInterval) clearInterval(this.clockUpdateInterval);
    if (this.timeCommandTimeout) clearTimeout(this.timeCommandTimeout);
    
    if (this.boundHandleTuningHoverKeys) {
        document.removeEventListener('keydown', this.boundHandleTuningHoverKeys);
    }

    // Voice keyer cleanup (remove the duplicate)
    if (this.voiceKeyer.isRecording) {
        this.stopVoiceRecording();
    }
    if (this.voiceKeyer.isPlaying) {
        this.stopVoiceKeyer();
    }
    
    // Save voice messages before cleanup
    if (this.voiceKeyer.messages.some(msg => msg !== null)) {
        this.saveVoiceMessages();
    }
	if (this.cwKeyer.messages.some(msg => msg !== null)) {
    this.saveCWMessages();
    }
	
	  if (this.boundHandleCWSpeedHoverKeys) {
        document.removeEventListener('keydown', this.boundHandleCWSpeedHoverKeys);
    }
	
} // Add this closing brace for cleanup()

} // This closes the QMXInterface class

// Move this OUTSIDE the class:
document.addEventListener('DOMContentLoaded', () => {
    try {
        new QMXInterface();
    } catch (error) {
        console.error('Failed to initialize QMX Interface:', error);
    }
});





   </script>

<div class="modal-overlay" id="modalOverlay"></div>

<!-- Frequency Input Modal -->
<div class="freq-input-modal" id="freqInputModal">
    <div class="freq-modal-content">
        <h3>Direct Frequency Entry</h3>
        
        <!-- Format buttons -->
        <div class="freq-format-buttons">
            <button class="freq-format-btn active" data-format="mhz">MHz</button>
            <button class="freq-format-btn" data-format="khz">kHz</button>
            <button class="freq-format-btn" data-format="hz">Hz</button>
        </div>
        
        <!-- Input field -->
        <input type="text" id="freqDisplayInput" class="freq-display-input" placeholder="Enter frequency...">
        <div id="freqError" class="freq-error"></div>
        
        <!-- Keypad -->
        <div class="freq-keypad">
            <button class="freq-key" data-key="1">1</button>
            <button class="freq-key" data-key="2">2</button>
            <button class="freq-key" data-key="3">3</button>
            <button class="freq-key" data-key="4">4</button>
            <button class="freq-key" data-key="5">5</button>
            <button class="freq-key" data-key="6">6</button>
            <button class="freq-key" data-key="7">7</button>
            <button class="freq-key" data-key="8">8</button>
            <button class="freq-key" data-key="9">9</button>
            <button class="freq-key" data-key="0">0</button>
            <button class="freq-key" data-key=".">.</button>
            <button class="freq-key" data-key="backspace">⌫</button>
        </div>
        
        <!-- Action buttons -->
        <div class="freq-modal-buttons">
            <button class="btn btn-primary" id="freqSetBtn">Set</button>
            <button class="btn btn-secondary" id="freqClearBtn">Clear</button>
            <button class="btn btn-secondary" id="freqCancelBtn">Cancel</button>
        </div>
    </div>
</div>

<!-- Permanent Frequency Input Panel -->
<div id="freqInputPermanentPanel" class="panel" style="display: none;">
    <h3>Direct Frequency Entry</h3>
    
    <!-- Mode selector -->
    <div class="control-group" style="margin-bottom: 15px;">
        <label>Input Mode</label>
        <select id="freqInputMode">
            <option value="popup">Click LCD (Popup)</option>
            <option value="permanent">Always Visible</option>
        </select>
    </div>
    
    <!-- Format buttons -->
    <div class="freq-format-buttons">
        <button class="freq-format-btn active" data-target="permanent" data-format="mhz">MHz</button>
        <button class="freq-format-btn" data-target="permanent" data-format="khz">kHz</button>
        <button class="freq-format-btn" data-target="permanent" data-format="hz">Hz</button>
    </div>
    
    <!-- Input field -->
    <input type="text" id="freqDisplayInputPerm" class="freq-display-input" placeholder="Enter frequency...">
    <div id="freqErrorPerm" class="freq-error"></div>
    
    <!-- Keypad -->
    <div class="freq-keypad">
        <button class="freq-key" data-target="permanent" data-key="1">1</button>
        <button class="freq-key" data-target="permanent" data-key="2">2</button>
        <button class="freq-key" data-target="permanent" data-key="3">3</button>
        <button class="freq-key" data-target="permanent" data-key="4">4</button>
        <button class="freq-key" data-target="permanent" data-key="5">5</button>
        <button class="freq-key" data-target="permanent" data-key="6">6</button>
        <button class="freq-key" data-target="permanent" data-key="7">7</button>
        <button class="freq-key" data-target="permanent" data-key="8">8</button>
        <button class="freq-key" data-target="permanent" data-key="9">9</button>
        <button class="freq-key" data-target="permanent" data-key="0">0</button>
        <button class="freq-key" data-target="permanent" data-key=".">.</button>
        <button class="freq-key" data-target="permanent" data-key="backspace">⌫</button>
    </div>
    
    <!-- Action buttons -->
    <div class="freq-modal-buttons">
        <button class="btn btn-primary" id="freqSetBtnPerm">Set</button>
        <button class="btn btn-secondary" id="freqClearBtnPerm">Clear</button>
    </div>
</div>

</body>
</html>